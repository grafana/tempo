---
aliases:
- /docs/tempo/latest/metrics-generator/cardinality
title: Cardinality
menuTitle: Cardinality
description: What is cardinality and how it is impacted by metrics generation?
weight: 100
---

# Cardinality

Cardinality refers to the total combination of key/value pairs, such as labels and label values for a given metric series or log stream, and how many unique combinations they generate.
For more information on cardinality, see the [What are cardinality spikes and why do they matter?](/blog/2022/02/15/what-are-cardinality-spikes-and-why-do-they-matter/) blog post.

Because writes to a TSDB database are in series, high cardinality does not make a big difference to performance at ingest. However, cardinality can have a major impact on querying where, the higher the cardinality, the more items are required to be iterated over.

Cardinality can pose a problem when you have many services.
There isn't a direct formula or solution to this issue.
The following guide should help estimate the cardinality that metrics generator will create.

## Traces collection and metrics

Tempo’s server-side metrics generation adds functionality to the collection of traces by creating Prometheus-based metrics that track a variety of metrics such as:

- Total span call counts
- Span latency histograms
- Total span size count

The metrics generator also allows you to create metrics which define the relationship between services via edges and nodes.
Each of these metrics are queryable via a set of Prometheus labels (key/value pairs).

Each new value for a label increases the number of active series associated with a metric. (To learn more about active series, see the [Trace active series]({{< relref "./active-series" >}}) documentation.)

This is also known as an increase in cardinality, and the number of active series generated for a metric is directly proportional to the number of labels that exist for that metrics alongside the number of values each label has added.

In a non-modified instance of the metrics generator, there are a small number of labels that are added automatically.
Because labels like `span_kind` and `status_code` only have a small number of valid values, the largest variable for the number of active series produced for each metric will depend on the number of service names and span names associated with trace spans.

The metrics generator can also be configured to also add extra labels on metrics, using span attribute key/value pairs which are mapped directly to these labels see the [custom span attribute documentation]({{< relref "../configuration#metrics-generator" >}}).

Be careful when configuring custom attributes: the greater the number of values seen in a specific attribute, the greater the number of active series will be produced.

Let's say that you are adding a custom attribute that includes unique customer IDs as a metrics label. If you have 100 customers, this could potentially multiple the number of active series generated by up to 100 (for example, going from 25,000 active series to 2.5M).
Always consider which attributes will actually be useful as labels for querying metrics, as well as the cardinality that they will increase metrics by.

## Estimate cardinality from traces for Service Graphs

The amount of edges depends on the number of nodes in the system and the direction of the requests between them.
Let’s call this amount hops. Every hope will be a unique combination of client + server labels.

For example:
- A system with 3 nodes `(A, B, C)` of which A only calls B and B only calls C will have 2 hops `(A → B, B → C)`
- A system with 3 nodes `(A, B, C)` that call each other (i.e., all bidirectional link) will have 6 hops `(A → B, B → A, B → C, C → B, A → C, C → A)`

We can’t calculate the amount of hops automatically based upon the nodes,
but it should be a value between `#services - 1` and `#services!`.

If we know the amount of hops in a system, we can calculate the cardinality of the generated
[service graphs]({{< relref "./service_graphs" >}}):

```
  traces_service_graph_request_total: #hops
  traces_service_graph_request_failed_total: #hops
  traces_service_graph_request_server_seconds: 3 buckets * #hops
  traces_service_graph_request_client_seconds: 3 buckets * #hops
  traces_service_graph_unpaired_spans_total: #services (absolute worst case)
  traces_service_graph_dropped_spans_total: #services (absolute worst case)
```

Finally, we get the following cardinality estimation:

```
  Sum: 8 * #hops + 2 * #services
```

## Dry-running the metrics-generator

An often most reliable solution is by running the metrics-generator in a dry-run mode.
Using the dry-run mode generates metrics but does not collecting them, thus not writing them to a metrics storage.
The override `metrics_generator_disable_collection` is defined for this use-case.

To get an estimate, run the metrics-generator normally and set the override to `true`.
Then, check `tempo_metrics_generator_registry_active_series` to get an estimation of the active series for that set-up.
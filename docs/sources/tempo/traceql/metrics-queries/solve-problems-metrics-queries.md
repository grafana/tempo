---
title: Solve problems with trace metrics queries
menuTitle: Use cases
description: Solve problems with trace metrics queries
weight: 600
keywords:
  - metrics query
  - TraceQL metrics
---

# Solve problems with trace metrics queries

Or, TraceQL metrics for the PromQL user

You can query data generated by TraceQL metrics in a similar way that you would query results stored in Mimir.
TraceQL metrics provides calculated metrics on trace span data, without requiring you to utilize an telemetry signal.

This page provides an example of how you can investigate the rate of incoming requests using both PromQL and TraceQL.

## RED metrics and queries

The Tempo metrics-generator emits metrics with pre-configured labels for Rate, Error, and Duration (RED) metrics and service graph edges.
Generated metric labels vary, but always include the service name (in service graph metrics, as a client and/or a server type).
For more information, refer to the [metrics-generator documentation](../../metrics-generator/).

You can use these metrics to get an overview of application performance.
The metrics can be directly correlated to the trace spans that are available for querying.

TraceQL metrics provide functionality that lets you make a variety of requests directly to Tempo instead of requiring the metrics-generator component.

{{< admonition type="note" >}}
TraceQL metrics are constrained to a 24-hour range window, and aren't available as a Grafana Managed Alerts source. For any metrics that require a longer time range, be used as the basis for Alerts or that are required for more than 30 days retention, use the metrics-generator to store these metrics in Mimir and continue to use PromQL for querying.
{{< /admonition >}}

## Investigate the rate of incoming requests

Let's say that you want to know how many requests are being serviced both by your application, but also by each service that comprises your application.
This allows you to ensure that your application is scaled appropriately, can help with forecasting capacity planning, and can show you which services may be having problems and are taking up load in fail-over scenarios.
These are usually ascertained via metrics that provide the R in RED (Rate), with counters that increase each time a service is called.

If you are familiar with PromQL, then you're used to constructing queries.
You can create an equivalent queries in TraceQL.
Here's the two queries for the different data sources (PromQL for Mimir and TraceQL for Tempo), shown side by side over a 6 hour time-range.

![Equivalent PromQL and TraceQL queries](/media/docs/tempo/traceql/TraceQL-metrics-query-example-1.png)

### How the query looks in PromQL

The Tempo metrics-generator outputs a metric, `traces_spanmetrics_calls_total`, a counter than increases each time a named span in a service is called.
Because RED data generated by the metrics-generator includes the service name and span kind, you can use this to only show call counts when a service was called externally by filtering via the `SERVER` span kind, thus showing the total number of times the service has been called.

You can use the PromQL `rate()` and `sum()` functions to examine the counter and determine the per-second rate of calls occurring, summing them by each service (summing by the `SERVER` span kind).
In the example, we also narrow down the results by ensuring we only look at data in a particular Kubernetes namespace (`ditl-demo-prod`).

```
sum by (service_name)(rate(traces_spanmetrics_calls_total{service_namespace="ditl-demo-prod", span_kind="SPAN_KIND_SERVER"}[2m]))
```

### How the query looks in TraceQL

Tempo's TraceQL metrics queries let you similarly examine all relevant traces spans matching the span selectors that filtering spans that occur in a particular Kubernetes namespace (`ditl-demo-prod`), and only spans of kind `SERVER`. The results of this selector is piped to the TraceQL rate function, which applies the rate calculation across these spans. Again, by ensuring that the rate is carried out by service name, this generates results that match those of the PromQL query and show us the rate of calls occurring on a service.

```
{ resource.service.namespace="ditl-demo-prod" && kind=server } | rate() by (resource.service.name)
```

{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='jsonPatch', url='', help='"JSONPatch defines a JSON Patch."'),
  '#withExpression':: d.fn(help="\"expression will be evaluated by CEL to create a [JSON patch](https://jsonpatch.com/). ref: https://github.com/google/cel-spec\\n\\nexpression must return an array of JSONPatch values.\\n\\nFor example, this CEL expression returns a JSON patch to conditionally modify a value:\\n\\n\\t  [\\n\\t    JSONPatch{op: \\\"test\\\", path: \\\"/spec/example\\\", value: \\\"Red\\\"},\\n\\t    JSONPatch{op: \\\"replace\\\", path: \\\"/spec/example\\\", value: \\\"Green\\\"}\\n\\t  ]\\n\\nTo define an object for the patch value, use Object types. For example:\\n\\n\\t  [\\n\\t    JSONPatch{\\n\\t      op: \\\"add\\\",\\n\\t      path: \\\"/spec/selector\\\",\\n\\t      value: Object.spec.selector{matchLabels: {\\\"environment\\\": \\\"test\\\"}}\\n\\t    }\\n\\t  ]\\n\\nTo use strings containing '/' and '~' as JSONPatch path keys, use \\\"jsonpatch.escapeKey\\\". For example:\\n\\n\\t  [\\n\\t    JSONPatch{\\n\\t      op: \\\"add\\\",\\n\\t      path: \\\"/metadata/labels/\\\" + jsonpatch.escapeKey(\\\"example.com/environment\\\"),\\n\\t      value: \\\"test\\\"\\n\\t    },\\n\\t  ]\\n\\nCEL expressions have access to the types needed to create JSON patches and objects:\\n\\n- 'JSONPatch' - CEL type of JSON Patch operations. JSONPatch has the fields 'op', 'from', 'path' and 'value'.\\n  See [JSON patch](https://jsonpatch.com/) for more details. The 'value' field may be set to any of: string,\\n  integer, array, map or object.  If set, the 'path' and 'from' fields must be set to a\\n  [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901/) string, where the 'jsonpatch.escapeKey()' CEL\\n  function may be used to escape path keys containing '/' and '~'.\\n- 'Object' - CEL type of the resource object. - 'Object.\u003cfieldName\u003e' - CEL type of object field (such as 'Object.spec') - 'Object.\u003cfieldName1\u003e.\u003cfieldName2\u003e...\u003cfieldNameN\u003e` - CEL type of nested field (such as 'Object.spec.containers')\\n\\nCEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:\\n\\n- 'object' - The object from the incoming request. The value is null for DELETE requests. - 'oldObject' - The existing object. The value is null for CREATE requests. - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)). - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind. - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources. - 'variables' - Map of composited variables, from its name to its lazily evaluated value.\\n  For example, a variable named 'foo' can be accessed as 'variables.foo'.\\n- 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.\\n  See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz\\n- 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the\\n  request resource.\\n\\nCEL expressions have access to [Kubernetes CEL function libraries](https://kubernetes.io/docs/reference/using-api/cel/#cel-options-language-features-and-libraries) as well as:\\n\\n- 'jsonpatch.escapeKey' - Performs JSONPatch key escaping. '~' and  '/' are escaped as '~0' and `~1' respectively).\\n\\nOnly property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible. Required.\"", args=[d.arg(name='expression', type=d.T.string)]),
  withExpression(expression): { expression: expression },
  '#mixin': 'ignore',
  mixin: self,
}

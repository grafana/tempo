// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/tempopb/tempo.proto

package tempopb

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	v1 "github.com/grafana/tempo/pkg/tempopb/common/v1"
	v11 "github.com/grafana/tempo/pkg/tempopb/trace/v1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type PushErrorReason int32

const (
	PushErrorReason_NO_ERROR        PushErrorReason = 0
	PushErrorReason_MAX_LIVE_TRACES PushErrorReason = 1
	PushErrorReason_TRACE_TOO_LARGE PushErrorReason = 2
	PushErrorReason_UNKNOWN_ERROR   PushErrorReason = 3
)

var PushErrorReason_name = map[int32]string{
	0: "NO_ERROR",
	1: "MAX_LIVE_TRACES",
	2: "TRACE_TOO_LARGE",
	3: "UNKNOWN_ERROR",
}

var PushErrorReason_value = map[string]int32{
	"NO_ERROR":        0,
	"MAX_LIVE_TRACES": 1,
	"TRACE_TOO_LARGE": 2,
	"UNKNOWN_ERROR":   3,
}

func (x PushErrorReason) String() string {
	return proto.EnumName(PushErrorReason_name, int32(x))
}

func (PushErrorReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{0}
}

type DedicatedColumn_Scope int32

const (
	DedicatedColumn_SPAN     DedicatedColumn_Scope = 0
	DedicatedColumn_RESOURCE DedicatedColumn_Scope = 1
)

var DedicatedColumn_Scope_name = map[int32]string{
	0: "SPAN",
	1: "RESOURCE",
}

var DedicatedColumn_Scope_value = map[string]int32{
	"SPAN":     0,
	"RESOURCE": 1,
}

func (x DedicatedColumn_Scope) String() string {
	return proto.EnumName(DedicatedColumn_Scope_name, int32(x))
}

func (DedicatedColumn_Scope) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{5, 0}
}

type DedicatedColumn_Type int32

const (
	DedicatedColumn_STRING DedicatedColumn_Type = 0
)

var DedicatedColumn_Type_name = map[int32]string{
	0: "STRING",
}

var DedicatedColumn_Type_value = map[string]int32{
	"STRING": 0,
}

func (x DedicatedColumn_Type) String() string {
	return proto.EnumName(DedicatedColumn_Type_name, int32(x))
}

func (DedicatedColumn_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{5, 1}
}

// Read
type TraceByIDRequest struct {
	TraceID    []byte `protobuf:"bytes,1,opt,name=traceID,proto3" json:"traceID,omitempty"`
	BlockStart string `protobuf:"bytes,2,opt,name=blockStart,proto3" json:"blockStart,omitempty"`
	BlockEnd   string `protobuf:"bytes,3,opt,name=blockEnd,proto3" json:"blockEnd,omitempty"`
	QueryMode  string `protobuf:"bytes,5,opt,name=queryMode,proto3" json:"queryMode,omitempty"`
}

func (m *TraceByIDRequest) Reset()         { *m = TraceByIDRequest{} }
func (m *TraceByIDRequest) String() string { return proto.CompactTextString(m) }
func (*TraceByIDRequest) ProtoMessage()    {}
func (*TraceByIDRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{0}
}
func (m *TraceByIDRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceByIDRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceByIDRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceByIDRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceByIDRequest.Merge(m, src)
}
func (m *TraceByIDRequest) XXX_Size() int {
	return m.Size()
}
func (m *TraceByIDRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceByIDRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TraceByIDRequest proto.InternalMessageInfo

func (m *TraceByIDRequest) GetTraceID() []byte {
	if m != nil {
		return m.TraceID
	}
	return nil
}

func (m *TraceByIDRequest) GetBlockStart() string {
	if m != nil {
		return m.BlockStart
	}
	return ""
}

func (m *TraceByIDRequest) GetBlockEnd() string {
	if m != nil {
		return m.BlockEnd
	}
	return ""
}

func (m *TraceByIDRequest) GetQueryMode() string {
	if m != nil {
		return m.QueryMode
	}
	return ""
}

type TraceByIDResponse struct {
	Trace   *Trace            `protobuf:"bytes,1,opt,name=trace,proto3" json:"trace,omitempty"`
	Metrics *TraceByIDMetrics `protobuf:"bytes,2,opt,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *TraceByIDResponse) Reset()         { *m = TraceByIDResponse{} }
func (m *TraceByIDResponse) String() string { return proto.CompactTextString(m) }
func (*TraceByIDResponse) ProtoMessage()    {}
func (*TraceByIDResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{1}
}
func (m *TraceByIDResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceByIDResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceByIDResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceByIDResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceByIDResponse.Merge(m, src)
}
func (m *TraceByIDResponse) XXX_Size() int {
	return m.Size()
}
func (m *TraceByIDResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceByIDResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TraceByIDResponse proto.InternalMessageInfo

func (m *TraceByIDResponse) GetTrace() *Trace {
	if m != nil {
		return m.Trace
	}
	return nil
}

func (m *TraceByIDResponse) GetMetrics() *TraceByIDMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type TraceByIDMetrics struct {
}

func (m *TraceByIDMetrics) Reset()         { *m = TraceByIDMetrics{} }
func (m *TraceByIDMetrics) String() string { return proto.CompactTextString(m) }
func (*TraceByIDMetrics) ProtoMessage()    {}
func (*TraceByIDMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{2}
}
func (m *TraceByIDMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceByIDMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceByIDMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceByIDMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceByIDMetrics.Merge(m, src)
}
func (m *TraceByIDMetrics) XXX_Size() int {
	return m.Size()
}
func (m *TraceByIDMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceByIDMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_TraceByIDMetrics proto.InternalMessageInfo

// SearchRequest takes no block parameters and implies a "recent traces" search
type SearchRequest struct {
	// case insensitive partial match
	Tags          map[string]string `protobuf:"bytes,1,rep,name=Tags,proto3" json:"Tags" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MinDurationMs uint32            `protobuf:"varint,2,opt,name=MinDurationMs,proto3" json:"MinDurationMs,omitempty"`
	MaxDurationMs uint32            `protobuf:"varint,3,opt,name=MaxDurationMs,proto3" json:"MaxDurationMs,omitempty"`
	Limit         uint32            `protobuf:"varint,4,opt,name=Limit,proto3" json:"Limit,omitempty"`
	Start         uint32            `protobuf:"varint,5,opt,name=start,proto3" json:"start,omitempty"`
	End           uint32            `protobuf:"varint,6,opt,name=end,proto3" json:"end,omitempty"`
	// TraceQL query
	Query           string `protobuf:"bytes,8,opt,name=Query,proto3" json:"Query,omitempty"`
	SpansPerSpanSet uint32 `protobuf:"varint,9,opt,name=SpansPerSpanSet,proto3" json:"SpansPerSpanSet,omitempty"`
}

func (m *SearchRequest) Reset()         { *m = SearchRequest{} }
func (m *SearchRequest) String() string { return proto.CompactTextString(m) }
func (*SearchRequest) ProtoMessage()    {}
func (*SearchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{3}
}
func (m *SearchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchRequest.Merge(m, src)
}
func (m *SearchRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchRequest proto.InternalMessageInfo

func (m *SearchRequest) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *SearchRequest) GetMinDurationMs() uint32 {
	if m != nil {
		return m.MinDurationMs
	}
	return 0
}

func (m *SearchRequest) GetMaxDurationMs() uint32 {
	if m != nil {
		return m.MaxDurationMs
	}
	return 0
}

func (m *SearchRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SearchRequest) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SearchRequest) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *SearchRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SearchRequest) GetSpansPerSpanSet() uint32 {
	if m != nil {
		return m.SpansPerSpanSet
	}
	return 0
}

// SearchBlockRequest takes SearchRequest parameters as well as all information
// necessary to search a block in the backend.
type SearchBlockRequest struct {
	SearchReq        *SearchRequest     `protobuf:"bytes,1,opt,name=searchReq,proto3" json:"searchReq,omitempty"`
	BlockID          string             `protobuf:"bytes,2,opt,name=blockID,proto3" json:"blockID,omitempty"`
	StartPage        uint32             `protobuf:"varint,3,opt,name=startPage,proto3" json:"startPage,omitempty"`
	PagesToSearch    uint32             `protobuf:"varint,4,opt,name=pagesToSearch,proto3" json:"pagesToSearch,omitempty"`
	Encoding         string             `protobuf:"bytes,5,opt,name=encoding,proto3" json:"encoding,omitempty"`
	IndexPageSize    uint32             `protobuf:"varint,6,opt,name=indexPageSize,proto3" json:"indexPageSize,omitempty"`
	TotalRecords     uint32             `protobuf:"varint,7,opt,name=totalRecords,proto3" json:"totalRecords,omitempty"`
	DataEncoding     string             `protobuf:"bytes,8,opt,name=dataEncoding,proto3" json:"dataEncoding,omitempty"`
	Version          string             `protobuf:"bytes,9,opt,name=version,proto3" json:"version,omitempty"`
	Size_            uint64             `protobuf:"varint,10,opt,name=size,proto3" json:"size,omitempty"`
	FooterSize       uint32             `protobuf:"varint,11,opt,name=footerSize,proto3" json:"footerSize,omitempty"`
	DedicatedColumns []*DedicatedColumn `protobuf:"bytes,12,rep,name=dedicatedColumns,proto3" json:"dedicatedColumns,omitempty"`
}

func (m *SearchBlockRequest) Reset()         { *m = SearchBlockRequest{} }
func (m *SearchBlockRequest) String() string { return proto.CompactTextString(m) }
func (*SearchBlockRequest) ProtoMessage()    {}
func (*SearchBlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{4}
}
func (m *SearchBlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchBlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchBlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchBlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchBlockRequest.Merge(m, src)
}
func (m *SearchBlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchBlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchBlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchBlockRequest proto.InternalMessageInfo

func (m *SearchBlockRequest) GetSearchReq() *SearchRequest {
	if m != nil {
		return m.SearchReq
	}
	return nil
}

func (m *SearchBlockRequest) GetBlockID() string {
	if m != nil {
		return m.BlockID
	}
	return ""
}

func (m *SearchBlockRequest) GetStartPage() uint32 {
	if m != nil {
		return m.StartPage
	}
	return 0
}

func (m *SearchBlockRequest) GetPagesToSearch() uint32 {
	if m != nil {
		return m.PagesToSearch
	}
	return 0
}

func (m *SearchBlockRequest) GetEncoding() string {
	if m != nil {
		return m.Encoding
	}
	return ""
}

func (m *SearchBlockRequest) GetIndexPageSize() uint32 {
	if m != nil {
		return m.IndexPageSize
	}
	return 0
}

func (m *SearchBlockRequest) GetTotalRecords() uint32 {
	if m != nil {
		return m.TotalRecords
	}
	return 0
}

func (m *SearchBlockRequest) GetDataEncoding() string {
	if m != nil {
		return m.DataEncoding
	}
	return ""
}

func (m *SearchBlockRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *SearchBlockRequest) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *SearchBlockRequest) GetFooterSize() uint32 {
	if m != nil {
		return m.FooterSize
	}
	return 0
}

func (m *SearchBlockRequest) GetDedicatedColumns() []*DedicatedColumn {
	if m != nil {
		return m.DedicatedColumns
	}
	return nil
}

// Configuration for a single dedicated attribute column.
type DedicatedColumn struct {
	Scope DedicatedColumn_Scope `protobuf:"varint,3,opt,name=scope,proto3,enum=tempopb.DedicatedColumn_Scope" json:"scope,omitempty"`
	Name  string                `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Type  DedicatedColumn_Type  `protobuf:"varint,1,opt,name=type,proto3,enum=tempopb.DedicatedColumn_Type" json:"type,omitempty"`
}

func (m *DedicatedColumn) Reset()         { *m = DedicatedColumn{} }
func (m *DedicatedColumn) String() string { return proto.CompactTextString(m) }
func (*DedicatedColumn) ProtoMessage()    {}
func (*DedicatedColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{5}
}
func (m *DedicatedColumn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DedicatedColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DedicatedColumn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DedicatedColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DedicatedColumn.Merge(m, src)
}
func (m *DedicatedColumn) XXX_Size() int {
	return m.Size()
}
func (m *DedicatedColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_DedicatedColumn.DiscardUnknown(m)
}

var xxx_messageInfo_DedicatedColumn proto.InternalMessageInfo

func (m *DedicatedColumn) GetScope() DedicatedColumn_Scope {
	if m != nil {
		return m.Scope
	}
	return DedicatedColumn_SPAN
}

func (m *DedicatedColumn) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DedicatedColumn) GetType() DedicatedColumn_Type {
	if m != nil {
		return m.Type
	}
	return DedicatedColumn_STRING
}

type SearchResponse struct {
	Traces  []*TraceSearchMetadata `protobuf:"bytes,1,rep,name=traces,proto3" json:"traces,omitempty"`
	Metrics *SearchMetrics         `protobuf:"bytes,2,opt,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *SearchResponse) Reset()         { *m = SearchResponse{} }
func (m *SearchResponse) String() string { return proto.CompactTextString(m) }
func (*SearchResponse) ProtoMessage()    {}
func (*SearchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{6}
}
func (m *SearchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchResponse.Merge(m, src)
}
func (m *SearchResponse) XXX_Size() int {
	return m.Size()
}
func (m *SearchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SearchResponse proto.InternalMessageInfo

func (m *SearchResponse) GetTraces() []*TraceSearchMetadata {
	if m != nil {
		return m.Traces
	}
	return nil
}

func (m *SearchResponse) GetMetrics() *SearchMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type TraceSearchMetadata struct {
	TraceID           string                   `protobuf:"bytes,1,opt,name=traceID,proto3" json:"traceID,omitempty"`
	RootServiceName   string                   `protobuf:"bytes,2,opt,name=rootServiceName,proto3" json:"rootServiceName,omitempty"`
	RootTraceName     string                   `protobuf:"bytes,3,opt,name=rootTraceName,proto3" json:"rootTraceName,omitempty"`
	StartTimeUnixNano uint64                   `protobuf:"varint,4,opt,name=startTimeUnixNano,proto3" json:"startTimeUnixNano,omitempty"`
	DurationMs        uint32                   `protobuf:"varint,5,opt,name=durationMs,proto3" json:"durationMs,omitempty"`
	SpanSet           *SpanSet                 `protobuf:"bytes,6,opt,name=spanSet,proto3" json:"spanSet,omitempty"`
	SpanSets          []*SpanSet               `protobuf:"bytes,7,rep,name=spanSets,proto3" json:"spanSets,omitempty"`
	ServiceStats      map[string]*ServiceStats `protobuf:"bytes,8,rep,name=serviceStats,proto3" json:"serviceStats,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *TraceSearchMetadata) Reset()         { *m = TraceSearchMetadata{} }
func (m *TraceSearchMetadata) String() string { return proto.CompactTextString(m) }
func (*TraceSearchMetadata) ProtoMessage()    {}
func (*TraceSearchMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{7}
}
func (m *TraceSearchMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceSearchMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceSearchMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceSearchMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceSearchMetadata.Merge(m, src)
}
func (m *TraceSearchMetadata) XXX_Size() int {
	return m.Size()
}
func (m *TraceSearchMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceSearchMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_TraceSearchMetadata proto.InternalMessageInfo

func (m *TraceSearchMetadata) GetTraceID() string {
	if m != nil {
		return m.TraceID
	}
	return ""
}

func (m *TraceSearchMetadata) GetRootServiceName() string {
	if m != nil {
		return m.RootServiceName
	}
	return ""
}

func (m *TraceSearchMetadata) GetRootTraceName() string {
	if m != nil {
		return m.RootTraceName
	}
	return ""
}

func (m *TraceSearchMetadata) GetStartTimeUnixNano() uint64 {
	if m != nil {
		return m.StartTimeUnixNano
	}
	return 0
}

func (m *TraceSearchMetadata) GetDurationMs() uint32 {
	if m != nil {
		return m.DurationMs
	}
	return 0
}

func (m *TraceSearchMetadata) GetSpanSet() *SpanSet {
	if m != nil {
		return m.SpanSet
	}
	return nil
}

func (m *TraceSearchMetadata) GetSpanSets() []*SpanSet {
	if m != nil {
		return m.SpanSets
	}
	return nil
}

func (m *TraceSearchMetadata) GetServiceStats() map[string]*ServiceStats {
	if m != nil {
		return m.ServiceStats
	}
	return nil
}

type ServiceStats struct {
	SpanCount  uint32 `protobuf:"varint,1,opt,name=spanCount,proto3" json:"spanCount,omitempty"`
	ErrorCount uint32 `protobuf:"varint,2,opt,name=errorCount,proto3" json:"errorCount,omitempty"`
}

func (m *ServiceStats) Reset()         { *m = ServiceStats{} }
func (m *ServiceStats) String() string { return proto.CompactTextString(m) }
func (*ServiceStats) ProtoMessage()    {}
func (*ServiceStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{8}
}
func (m *ServiceStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceStats.Merge(m, src)
}
func (m *ServiceStats) XXX_Size() int {
	return m.Size()
}
func (m *ServiceStats) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceStats.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceStats proto.InternalMessageInfo

func (m *ServiceStats) GetSpanCount() uint32 {
	if m != nil {
		return m.SpanCount
	}
	return 0
}

func (m *ServiceStats) GetErrorCount() uint32 {
	if m != nil {
		return m.ErrorCount
	}
	return 0
}

type SpanSet struct {
	Spans      []*Span        `protobuf:"bytes,1,rep,name=spans,proto3" json:"spans,omitempty"`
	Matched    uint32         `protobuf:"varint,2,opt,name=matched,proto3" json:"matched,omitempty"`
	Attributes []*v1.KeyValue `protobuf:"bytes,3,rep,name=attributes,proto3" json:"attributes,omitempty"`
}

func (m *SpanSet) Reset()         { *m = SpanSet{} }
func (m *SpanSet) String() string { return proto.CompactTextString(m) }
func (*SpanSet) ProtoMessage()    {}
func (*SpanSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{9}
}
func (m *SpanSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanSet.Merge(m, src)
}
func (m *SpanSet) XXX_Size() int {
	return m.Size()
}
func (m *SpanSet) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanSet.DiscardUnknown(m)
}

var xxx_messageInfo_SpanSet proto.InternalMessageInfo

func (m *SpanSet) GetSpans() []*Span {
	if m != nil {
		return m.Spans
	}
	return nil
}

func (m *SpanSet) GetMatched() uint32 {
	if m != nil {
		return m.Matched
	}
	return 0
}

func (m *SpanSet) GetAttributes() []*v1.KeyValue {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type Span struct {
	SpanID            string         `protobuf:"bytes,1,opt,name=spanID,proto3" json:"spanID,omitempty"`
	Name              string         `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	StartTimeUnixNano uint64         `protobuf:"varint,3,opt,name=startTimeUnixNano,proto3" json:"startTimeUnixNano,omitempty"`
	DurationNanos     uint64         `protobuf:"varint,4,opt,name=durationNanos,proto3" json:"durationNanos,omitempty"`
	Attributes        []*v1.KeyValue `protobuf:"bytes,5,rep,name=attributes,proto3" json:"attributes,omitempty"`
}

func (m *Span) Reset()         { *m = Span{} }
func (m *Span) String() string { return proto.CompactTextString(m) }
func (*Span) ProtoMessage()    {}
func (*Span) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{10}
}
func (m *Span) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Span) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Span.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Span) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Span.Merge(m, src)
}
func (m *Span) XXX_Size() int {
	return m.Size()
}
func (m *Span) XXX_DiscardUnknown() {
	xxx_messageInfo_Span.DiscardUnknown(m)
}

var xxx_messageInfo_Span proto.InternalMessageInfo

func (m *Span) GetSpanID() string {
	if m != nil {
		return m.SpanID
	}
	return ""
}

func (m *Span) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Span) GetStartTimeUnixNano() uint64 {
	if m != nil {
		return m.StartTimeUnixNano
	}
	return 0
}

func (m *Span) GetDurationNanos() uint64 {
	if m != nil {
		return m.DurationNanos
	}
	return 0
}

func (m *Span) GetAttributes() []*v1.KeyValue {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type SearchMetrics struct {
	InspectedTraces uint32 `protobuf:"varint,1,opt,name=inspectedTraces,proto3" json:"inspectedTraces,omitempty"`
	InspectedBytes  uint64 `protobuf:"varint,2,opt,name=inspectedBytes,proto3" json:"inspectedBytes,omitempty"`
	TotalBlocks     uint32 `protobuf:"varint,3,opt,name=totalBlocks,proto3" json:"totalBlocks,omitempty"`
	CompletedJobs   uint32 `protobuf:"varint,4,opt,name=completedJobs,proto3" json:"completedJobs,omitempty"`
	TotalJobs       uint32 `protobuf:"varint,5,opt,name=totalJobs,proto3" json:"totalJobs,omitempty"`
	TotalBlockBytes uint64 `protobuf:"varint,6,opt,name=totalBlockBytes,proto3" json:"totalBlockBytes,omitempty"`
	InspectedSpans  uint64 `protobuf:"varint,7,opt,name=inspectedSpans,proto3" json:"inspectedSpans,omitempty"`
}

func (m *SearchMetrics) Reset()         { *m = SearchMetrics{} }
func (m *SearchMetrics) String() string { return proto.CompactTextString(m) }
func (*SearchMetrics) ProtoMessage()    {}
func (*SearchMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{11}
}
func (m *SearchMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchMetrics.Merge(m, src)
}
func (m *SearchMetrics) XXX_Size() int {
	return m.Size()
}
func (m *SearchMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_SearchMetrics proto.InternalMessageInfo

func (m *SearchMetrics) GetInspectedTraces() uint32 {
	if m != nil {
		return m.InspectedTraces
	}
	return 0
}

func (m *SearchMetrics) GetInspectedBytes() uint64 {
	if m != nil {
		return m.InspectedBytes
	}
	return 0
}

func (m *SearchMetrics) GetTotalBlocks() uint32 {
	if m != nil {
		return m.TotalBlocks
	}
	return 0
}

func (m *SearchMetrics) GetCompletedJobs() uint32 {
	if m != nil {
		return m.CompletedJobs
	}
	return 0
}

func (m *SearchMetrics) GetTotalJobs() uint32 {
	if m != nil {
		return m.TotalJobs
	}
	return 0
}

func (m *SearchMetrics) GetTotalBlockBytes() uint64 {
	if m != nil {
		return m.TotalBlockBytes
	}
	return 0
}

func (m *SearchMetrics) GetInspectedSpans() uint64 {
	if m != nil {
		return m.InspectedSpans
	}
	return 0
}

type SearchTagsRequest struct {
	Scope string `protobuf:"bytes,1,opt,name=scope,proto3" json:"scope,omitempty"`
	Start uint32 `protobuf:"varint,3,opt,name=start,proto3" json:"start,omitempty"`
	End   uint32 `protobuf:"varint,4,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *SearchTagsRequest) Reset()         { *m = SearchTagsRequest{} }
func (m *SearchTagsRequest) String() string { return proto.CompactTextString(m) }
func (*SearchTagsRequest) ProtoMessage()    {}
func (*SearchTagsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{12}
}
func (m *SearchTagsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagsRequest.Merge(m, src)
}
func (m *SearchTagsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagsRequest proto.InternalMessageInfo

func (m *SearchTagsRequest) GetScope() string {
	if m != nil {
		return m.Scope
	}
	return ""
}

func (m *SearchTagsRequest) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SearchTagsRequest) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

// SearchTagsBlockRequest takes SearchTagsRequest parameters as well as all information necessary
// to search a block in the backend.
type SearchTagsBlockRequest struct {
	SearchReq        *SearchTagsRequest `protobuf:"bytes,1,opt,name=searchReq,proto3" json:"searchReq,omitempty"`
	BlockID          string             `protobuf:"bytes,2,opt,name=blockID,proto3" json:"blockID,omitempty"`
	StartPage        uint32             `protobuf:"varint,3,opt,name=startPage,proto3" json:"startPage,omitempty"`
	PagesToSearch    uint32             `protobuf:"varint,4,opt,name=pagesToSearch,proto3" json:"pagesToSearch,omitempty"`
	Encoding         string             `protobuf:"bytes,5,opt,name=encoding,proto3" json:"encoding,omitempty"`
	IndexPageSize    uint32             `protobuf:"varint,6,opt,name=indexPageSize,proto3" json:"indexPageSize,omitempty"`
	TotalRecords     uint32             `protobuf:"varint,7,opt,name=totalRecords,proto3" json:"totalRecords,omitempty"`
	DataEncoding     string             `protobuf:"bytes,8,opt,name=dataEncoding,proto3" json:"dataEncoding,omitempty"`
	Version          string             `protobuf:"bytes,9,opt,name=version,proto3" json:"version,omitempty"`
	Size_            uint64             `protobuf:"varint,10,opt,name=size,proto3" json:"size,omitempty"`
	FooterSize       uint32             `protobuf:"varint,11,opt,name=footerSize,proto3" json:"footerSize,omitempty"`
	DedicatedColumns []*DedicatedColumn `protobuf:"bytes,12,rep,name=dedicatedColumns,proto3" json:"dedicatedColumns,omitempty"`
}

func (m *SearchTagsBlockRequest) Reset()         { *m = SearchTagsBlockRequest{} }
func (m *SearchTagsBlockRequest) String() string { return proto.CompactTextString(m) }
func (*SearchTagsBlockRequest) ProtoMessage()    {}
func (*SearchTagsBlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{13}
}
func (m *SearchTagsBlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagsBlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagsBlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagsBlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagsBlockRequest.Merge(m, src)
}
func (m *SearchTagsBlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagsBlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagsBlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagsBlockRequest proto.InternalMessageInfo

func (m *SearchTagsBlockRequest) GetSearchReq() *SearchTagsRequest {
	if m != nil {
		return m.SearchReq
	}
	return nil
}

func (m *SearchTagsBlockRequest) GetBlockID() string {
	if m != nil {
		return m.BlockID
	}
	return ""
}

func (m *SearchTagsBlockRequest) GetStartPage() uint32 {
	if m != nil {
		return m.StartPage
	}
	return 0
}

func (m *SearchTagsBlockRequest) GetPagesToSearch() uint32 {
	if m != nil {
		return m.PagesToSearch
	}
	return 0
}

func (m *SearchTagsBlockRequest) GetEncoding() string {
	if m != nil {
		return m.Encoding
	}
	return ""
}

func (m *SearchTagsBlockRequest) GetIndexPageSize() uint32 {
	if m != nil {
		return m.IndexPageSize
	}
	return 0
}

func (m *SearchTagsBlockRequest) GetTotalRecords() uint32 {
	if m != nil {
		return m.TotalRecords
	}
	return 0
}

func (m *SearchTagsBlockRequest) GetDataEncoding() string {
	if m != nil {
		return m.DataEncoding
	}
	return ""
}

func (m *SearchTagsBlockRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *SearchTagsBlockRequest) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *SearchTagsBlockRequest) GetFooterSize() uint32 {
	if m != nil {
		return m.FooterSize
	}
	return 0
}

func (m *SearchTagsBlockRequest) GetDedicatedColumns() []*DedicatedColumn {
	if m != nil {
		return m.DedicatedColumns
	}
	return nil
}

type SearchTagValuesBlockRequest struct {
	SearchReq        *SearchTagValuesRequest `protobuf:"bytes,1,opt,name=searchReq,proto3" json:"searchReq,omitempty"`
	BlockID          string                  `protobuf:"bytes,2,opt,name=blockID,proto3" json:"blockID,omitempty"`
	StartPage        uint32                  `protobuf:"varint,3,opt,name=startPage,proto3" json:"startPage,omitempty"`
	PagesToSearch    uint32                  `protobuf:"varint,4,opt,name=pagesToSearch,proto3" json:"pagesToSearch,omitempty"`
	Encoding         string                  `protobuf:"bytes,5,opt,name=encoding,proto3" json:"encoding,omitempty"`
	IndexPageSize    uint32                  `protobuf:"varint,6,opt,name=indexPageSize,proto3" json:"indexPageSize,omitempty"`
	TotalRecords     uint32                  `protobuf:"varint,7,opt,name=totalRecords,proto3" json:"totalRecords,omitempty"`
	DataEncoding     string                  `protobuf:"bytes,8,opt,name=dataEncoding,proto3" json:"dataEncoding,omitempty"`
	Version          string                  `protobuf:"bytes,9,opt,name=version,proto3" json:"version,omitempty"`
	Size_            uint64                  `protobuf:"varint,10,opt,name=size,proto3" json:"size,omitempty"`
	FooterSize       uint32                  `protobuf:"varint,11,opt,name=footerSize,proto3" json:"footerSize,omitempty"`
	DedicatedColumns []*DedicatedColumn      `protobuf:"bytes,12,rep,name=dedicatedColumns,proto3" json:"dedicatedColumns,omitempty"`
}

func (m *SearchTagValuesBlockRequest) Reset()         { *m = SearchTagValuesBlockRequest{} }
func (m *SearchTagValuesBlockRequest) String() string { return proto.CompactTextString(m) }
func (*SearchTagValuesBlockRequest) ProtoMessage()    {}
func (*SearchTagValuesBlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{14}
}
func (m *SearchTagValuesBlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagValuesBlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagValuesBlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagValuesBlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagValuesBlockRequest.Merge(m, src)
}
func (m *SearchTagValuesBlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagValuesBlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagValuesBlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagValuesBlockRequest proto.InternalMessageInfo

func (m *SearchTagValuesBlockRequest) GetSearchReq() *SearchTagValuesRequest {
	if m != nil {
		return m.SearchReq
	}
	return nil
}

func (m *SearchTagValuesBlockRequest) GetBlockID() string {
	if m != nil {
		return m.BlockID
	}
	return ""
}

func (m *SearchTagValuesBlockRequest) GetStartPage() uint32 {
	if m != nil {
		return m.StartPage
	}
	return 0
}

func (m *SearchTagValuesBlockRequest) GetPagesToSearch() uint32 {
	if m != nil {
		return m.PagesToSearch
	}
	return 0
}

func (m *SearchTagValuesBlockRequest) GetEncoding() string {
	if m != nil {
		return m.Encoding
	}
	return ""
}

func (m *SearchTagValuesBlockRequest) GetIndexPageSize() uint32 {
	if m != nil {
		return m.IndexPageSize
	}
	return 0
}

func (m *SearchTagValuesBlockRequest) GetTotalRecords() uint32 {
	if m != nil {
		return m.TotalRecords
	}
	return 0
}

func (m *SearchTagValuesBlockRequest) GetDataEncoding() string {
	if m != nil {
		return m.DataEncoding
	}
	return ""
}

func (m *SearchTagValuesBlockRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *SearchTagValuesBlockRequest) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *SearchTagValuesBlockRequest) GetFooterSize() uint32 {
	if m != nil {
		return m.FooterSize
	}
	return 0
}

func (m *SearchTagValuesBlockRequest) GetDedicatedColumns() []*DedicatedColumn {
	if m != nil {
		return m.DedicatedColumns
	}
	return nil
}

type SearchTagsResponse struct {
	TagNames []string `protobuf:"bytes,1,rep,name=tagNames,proto3" json:"tagNames,omitempty"`
}

func (m *SearchTagsResponse) Reset()         { *m = SearchTagsResponse{} }
func (m *SearchTagsResponse) String() string { return proto.CompactTextString(m) }
func (*SearchTagsResponse) ProtoMessage()    {}
func (*SearchTagsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{15}
}
func (m *SearchTagsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagsResponse.Merge(m, src)
}
func (m *SearchTagsResponse) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagsResponse proto.InternalMessageInfo

func (m *SearchTagsResponse) GetTagNames() []string {
	if m != nil {
		return m.TagNames
	}
	return nil
}

type SearchTagsV2Response struct {
	Scopes []*SearchTagsV2Scope `protobuf:"bytes,1,rep,name=scopes,proto3" json:"scopes,omitempty"`
}

func (m *SearchTagsV2Response) Reset()         { *m = SearchTagsV2Response{} }
func (m *SearchTagsV2Response) String() string { return proto.CompactTextString(m) }
func (*SearchTagsV2Response) ProtoMessage()    {}
func (*SearchTagsV2Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{16}
}
func (m *SearchTagsV2Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagsV2Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagsV2Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagsV2Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagsV2Response.Merge(m, src)
}
func (m *SearchTagsV2Response) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagsV2Response) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagsV2Response.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagsV2Response proto.InternalMessageInfo

func (m *SearchTagsV2Response) GetScopes() []*SearchTagsV2Scope {
	if m != nil {
		return m.Scopes
	}
	return nil
}

type SearchTagsV2Scope struct {
	Name string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Tags []string `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty"`
}

func (m *SearchTagsV2Scope) Reset()         { *m = SearchTagsV2Scope{} }
func (m *SearchTagsV2Scope) String() string { return proto.CompactTextString(m) }
func (*SearchTagsV2Scope) ProtoMessage()    {}
func (*SearchTagsV2Scope) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{17}
}
func (m *SearchTagsV2Scope) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagsV2Scope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagsV2Scope.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagsV2Scope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagsV2Scope.Merge(m, src)
}
func (m *SearchTagsV2Scope) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagsV2Scope) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagsV2Scope.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagsV2Scope proto.InternalMessageInfo

func (m *SearchTagsV2Scope) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SearchTagsV2Scope) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type SearchTagValuesRequest struct {
	TagName string `protobuf:"bytes,1,opt,name=tagName,proto3" json:"tagName,omitempty"`
	Query   string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	Start   uint32 `protobuf:"varint,4,opt,name=start,proto3" json:"start,omitempty"`
	End     uint32 `protobuf:"varint,5,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *SearchTagValuesRequest) Reset()         { *m = SearchTagValuesRequest{} }
func (m *SearchTagValuesRequest) String() string { return proto.CompactTextString(m) }
func (*SearchTagValuesRequest) ProtoMessage()    {}
func (*SearchTagValuesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{18}
}
func (m *SearchTagValuesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagValuesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagValuesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagValuesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagValuesRequest.Merge(m, src)
}
func (m *SearchTagValuesRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagValuesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagValuesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagValuesRequest proto.InternalMessageInfo

func (m *SearchTagValuesRequest) GetTagName() string {
	if m != nil {
		return m.TagName
	}
	return ""
}

func (m *SearchTagValuesRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SearchTagValuesRequest) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SearchTagValuesRequest) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

type SearchTagValuesResponse struct {
	TagValues []string `protobuf:"bytes,1,rep,name=tagValues,proto3" json:"tagValues,omitempty"`
}

func (m *SearchTagValuesResponse) Reset()         { *m = SearchTagValuesResponse{} }
func (m *SearchTagValuesResponse) String() string { return proto.CompactTextString(m) }
func (*SearchTagValuesResponse) ProtoMessage()    {}
func (*SearchTagValuesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{19}
}
func (m *SearchTagValuesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagValuesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagValuesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagValuesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagValuesResponse.Merge(m, src)
}
func (m *SearchTagValuesResponse) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagValuesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagValuesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagValuesResponse proto.InternalMessageInfo

func (m *SearchTagValuesResponse) GetTagValues() []string {
	if m != nil {
		return m.TagValues
	}
	return nil
}

type TagValue struct {
	Type  string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *TagValue) Reset()         { *m = TagValue{} }
func (m *TagValue) String() string { return proto.CompactTextString(m) }
func (*TagValue) ProtoMessage()    {}
func (*TagValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{20}
}
func (m *TagValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagValue.Merge(m, src)
}
func (m *TagValue) XXX_Size() int {
	return m.Size()
}
func (m *TagValue) XXX_DiscardUnknown() {
	xxx_messageInfo_TagValue.DiscardUnknown(m)
}

var xxx_messageInfo_TagValue proto.InternalMessageInfo

func (m *TagValue) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *TagValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type SearchTagValuesV2Response struct {
	TagValues []*TagValue `protobuf:"bytes,1,rep,name=tagValues,proto3" json:"tagValues,omitempty"`
}

func (m *SearchTagValuesV2Response) Reset()         { *m = SearchTagValuesV2Response{} }
func (m *SearchTagValuesV2Response) String() string { return proto.CompactTextString(m) }
func (*SearchTagValuesV2Response) ProtoMessage()    {}
func (*SearchTagValuesV2Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{21}
}
func (m *SearchTagValuesV2Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagValuesV2Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagValuesV2Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagValuesV2Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagValuesV2Response.Merge(m, src)
}
func (m *SearchTagValuesV2Response) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagValuesV2Response) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagValuesV2Response.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagValuesV2Response proto.InternalMessageInfo

func (m *SearchTagValuesV2Response) GetTagValues() []*TagValue {
	if m != nil {
		return m.TagValues
	}
	return nil
}

type Trace struct {
	Batches []*v11.ResourceSpans `protobuf:"bytes,1,rep,name=batches,proto3" json:"batches,omitempty"`
}

func (m *Trace) Reset()         { *m = Trace{} }
func (m *Trace) String() string { return proto.CompactTextString(m) }
func (*Trace) ProtoMessage()    {}
func (*Trace) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{22}
}
func (m *Trace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Trace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Trace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trace.Merge(m, src)
}
func (m *Trace) XXX_Size() int {
	return m.Size()
}
func (m *Trace) XXX_DiscardUnknown() {
	xxx_messageInfo_Trace.DiscardUnknown(m)
}

var xxx_messageInfo_Trace proto.InternalMessageInfo

func (m *Trace) GetBatches() []*v11.ResourceSpans {
	if m != nil {
		return m.Batches
	}
	return nil
}

// Write
type PushResponse struct {
	ErrorsByTrace []PushErrorReason `protobuf:"varint,1,rep,packed,name=errorsByTrace,proto3,enum=tempopb.PushErrorReason" json:"errorsByTrace,omitempty"`
}

func (m *PushResponse) Reset()         { *m = PushResponse{} }
func (m *PushResponse) String() string { return proto.CompactTextString(m) }
func (*PushResponse) ProtoMessage()    {}
func (*PushResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{23}
}
func (m *PushResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PushResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PushResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushResponse.Merge(m, src)
}
func (m *PushResponse) XXX_Size() int {
	return m.Size()
}
func (m *PushResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PushResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PushResponse proto.InternalMessageInfo

func (m *PushResponse) GetErrorsByTrace() []PushErrorReason {
	if m != nil {
		return m.ErrorsByTrace
	}
	return nil
}

// PushBytesRequest pushes slices of traces, ids and searchdata. Traces are
// encoded using the
//  current BatchDecoder in ./pkg/model
type PushBytesRequest struct {
	// pre-marshalled Traces. length must match ids
	Traces []PreallocBytes `protobuf:"bytes,2,rep,name=traces,proto3,customtype=PreallocBytes" json:"traces"`
	// trace ids. length must match traces
	Ids []PreallocBytes `protobuf:"bytes,3,rep,name=ids,proto3,customtype=PreallocBytes" json:"ids"`
	// search data, length must match traces
	SearchData []PreallocBytes `protobuf:"bytes,4,rep,name=searchData,proto3,customtype=PreallocBytes" json:"searchData"`
}

func (m *PushBytesRequest) Reset()         { *m = PushBytesRequest{} }
func (m *PushBytesRequest) String() string { return proto.CompactTextString(m) }
func (*PushBytesRequest) ProtoMessage()    {}
func (*PushBytesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{24}
}
func (m *PushBytesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushBytesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PushBytesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PushBytesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushBytesRequest.Merge(m, src)
}
func (m *PushBytesRequest) XXX_Size() int {
	return m.Size()
}
func (m *PushBytesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PushBytesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PushBytesRequest proto.InternalMessageInfo

type PushSpansRequest struct {
	// just send entire OTel spans for now
	Batches []*v11.ResourceSpans `protobuf:"bytes,1,rep,name=batches,proto3" json:"batches,omitempty"`
}

func (m *PushSpansRequest) Reset()         { *m = PushSpansRequest{} }
func (m *PushSpansRequest) String() string { return proto.CompactTextString(m) }
func (*PushSpansRequest) ProtoMessage()    {}
func (*PushSpansRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{25}
}
func (m *PushSpansRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushSpansRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PushSpansRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PushSpansRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushSpansRequest.Merge(m, src)
}
func (m *PushSpansRequest) XXX_Size() int {
	return m.Size()
}
func (m *PushSpansRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PushSpansRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PushSpansRequest proto.InternalMessageInfo

func (m *PushSpansRequest) GetBatches() []*v11.ResourceSpans {
	if m != nil {
		return m.Batches
	}
	return nil
}

type TraceBytes struct {
	// pre-marshalled Traces
	Traces [][]byte `protobuf:"bytes,1,rep,name=traces,proto3" json:"traces,omitempty"`
}

func (m *TraceBytes) Reset()         { *m = TraceBytes{} }
func (m *TraceBytes) String() string { return proto.CompactTextString(m) }
func (*TraceBytes) ProtoMessage()    {}
func (*TraceBytes) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{26}
}
func (m *TraceBytes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceBytes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceBytes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceBytes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceBytes.Merge(m, src)
}
func (m *TraceBytes) XXX_Size() int {
	return m.Size()
}
func (m *TraceBytes) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceBytes.DiscardUnknown(m)
}

var xxx_messageInfo_TraceBytes proto.InternalMessageInfo

func (m *TraceBytes) GetTraces() [][]byte {
	if m != nil {
		return m.Traces
	}
	return nil
}

// this message exists for marshalling/unmarshalling convenience to/from
// parquet. in parquet we proto encode links to a column. unfortunately you
// can't encode a slice directly so we use this wrapper to generate the required
// marshalling/unmarshalling functions.
type LinkSlice struct {
	Links []*v11.Span_Link `protobuf:"bytes,1,rep,name=links,proto3" json:"links,omitempty"`
}

func (m *LinkSlice) Reset()         { *m = LinkSlice{} }
func (m *LinkSlice) String() string { return proto.CompactTextString(m) }
func (*LinkSlice) ProtoMessage()    {}
func (*LinkSlice) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{27}
}
func (m *LinkSlice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkSlice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinkSlice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LinkSlice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkSlice.Merge(m, src)
}
func (m *LinkSlice) XXX_Size() int {
	return m.Size()
}
func (m *LinkSlice) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkSlice.DiscardUnknown(m)
}

var xxx_messageInfo_LinkSlice proto.InternalMessageInfo

func (m *LinkSlice) GetLinks() []*v11.Span_Link {
	if m != nil {
		return m.Links
	}
	return nil
}

type SpanMetricsRequest struct {
	Query   string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	GroupBy string `protobuf:"bytes,2,opt,name=groupBy,proto3" json:"groupBy,omitempty"`
	Limit   uint64 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	Start   uint32 `protobuf:"varint,4,opt,name=start,proto3" json:"start,omitempty"`
	End     uint32 `protobuf:"varint,5,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *SpanMetricsRequest) Reset()         { *m = SpanMetricsRequest{} }
func (m *SpanMetricsRequest) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsRequest) ProtoMessage()    {}
func (*SpanMetricsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{28}
}
func (m *SpanMetricsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsRequest.Merge(m, src)
}
func (m *SpanMetricsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsRequest proto.InternalMessageInfo

func (m *SpanMetricsRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SpanMetricsRequest) GetGroupBy() string {
	if m != nil {
		return m.GroupBy
	}
	return ""
}

func (m *SpanMetricsRequest) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SpanMetricsRequest) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SpanMetricsRequest) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

type SpanMetricsSummaryRequest struct {
	Query   string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	GroupBy string `protobuf:"bytes,2,opt,name=groupBy,proto3" json:"groupBy,omitempty"`
	Limit   uint64 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	Start   uint32 `protobuf:"varint,4,opt,name=start,proto3" json:"start,omitempty"`
	End     uint32 `protobuf:"varint,5,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *SpanMetricsSummaryRequest) Reset()         { *m = SpanMetricsSummaryRequest{} }
func (m *SpanMetricsSummaryRequest) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsSummaryRequest) ProtoMessage()    {}
func (*SpanMetricsSummaryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{29}
}
func (m *SpanMetricsSummaryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsSummaryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsSummaryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsSummaryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsSummaryRequest.Merge(m, src)
}
func (m *SpanMetricsSummaryRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsSummaryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsSummaryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsSummaryRequest proto.InternalMessageInfo

func (m *SpanMetricsSummaryRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SpanMetricsSummaryRequest) GetGroupBy() string {
	if m != nil {
		return m.GroupBy
	}
	return ""
}

func (m *SpanMetricsSummaryRequest) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SpanMetricsSummaryRequest) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SpanMetricsSummaryRequest) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

type SpanMetricsResponse struct {
	Estimated      bool           `protobuf:"varint,1,opt,name=estimated,proto3" json:"estimated,omitempty"`
	SpanCount      uint64         `protobuf:"varint,2,opt,name=spanCount,proto3" json:"spanCount,omitempty"`
	ErrorSpanCount uint64         `protobuf:"varint,3,opt,name=errorSpanCount,proto3" json:"errorSpanCount,omitempty"`
	Metrics        []*SpanMetrics `protobuf:"bytes,4,rep,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *SpanMetricsResponse) Reset()         { *m = SpanMetricsResponse{} }
func (m *SpanMetricsResponse) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsResponse) ProtoMessage()    {}
func (*SpanMetricsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{30}
}
func (m *SpanMetricsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsResponse.Merge(m, src)
}
func (m *SpanMetricsResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsResponse proto.InternalMessageInfo

func (m *SpanMetricsResponse) GetEstimated() bool {
	if m != nil {
		return m.Estimated
	}
	return false
}

func (m *SpanMetricsResponse) GetSpanCount() uint64 {
	if m != nil {
		return m.SpanCount
	}
	return 0
}

func (m *SpanMetricsResponse) GetErrorSpanCount() uint64 {
	if m != nil {
		return m.ErrorSpanCount
	}
	return 0
}

func (m *SpanMetricsResponse) GetMetrics() []*SpanMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type RawHistogram struct {
	Bucket uint64 `protobuf:"varint,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
	Count  uint64 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *RawHistogram) Reset()         { *m = RawHistogram{} }
func (m *RawHistogram) String() string { return proto.CompactTextString(m) }
func (*RawHistogram) ProtoMessage()    {}
func (*RawHistogram) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{31}
}
func (m *RawHistogram) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawHistogram) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawHistogram.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawHistogram) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawHistogram.Merge(m, src)
}
func (m *RawHistogram) XXX_Size() int {
	return m.Size()
}
func (m *RawHistogram) XXX_DiscardUnknown() {
	xxx_messageInfo_RawHistogram.DiscardUnknown(m)
}

var xxx_messageInfo_RawHistogram proto.InternalMessageInfo

func (m *RawHistogram) GetBucket() uint64 {
	if m != nil {
		return m.Bucket
	}
	return 0
}

func (m *RawHistogram) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type KeyValue struct {
	Key   string         `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value *TraceQLStatic `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *KeyValue) Reset()         { *m = KeyValue{} }
func (m *KeyValue) String() string { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()    {}
func (*KeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{32}
}
func (m *KeyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyValue.Merge(m, src)
}
func (m *KeyValue) XXX_Size() int {
	return m.Size()
}
func (m *KeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_KeyValue proto.InternalMessageInfo

func (m *KeyValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyValue) GetValue() *TraceQLStatic {
	if m != nil {
		return m.Value
	}
	return nil
}

type SpanMetrics struct {
	LatencyHistogram []*RawHistogram `protobuf:"bytes,1,rep,name=latency_histogram,json=latencyHistogram,proto3" json:"latency_histogram,omitempty"`
	Series           []*KeyValue     `protobuf:"bytes,2,rep,name=series,proto3" json:"series,omitempty"`
	Errors           uint64          `protobuf:"varint,3,opt,name=errors,proto3" json:"errors,omitempty"`
}

func (m *SpanMetrics) Reset()         { *m = SpanMetrics{} }
func (m *SpanMetrics) String() string { return proto.CompactTextString(m) }
func (*SpanMetrics) ProtoMessage()    {}
func (*SpanMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{33}
}
func (m *SpanMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetrics.Merge(m, src)
}
func (m *SpanMetrics) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetrics proto.InternalMessageInfo

func (m *SpanMetrics) GetLatencyHistogram() []*RawHistogram {
	if m != nil {
		return m.LatencyHistogram
	}
	return nil
}

func (m *SpanMetrics) GetSeries() []*KeyValue {
	if m != nil {
		return m.Series
	}
	return nil
}

func (m *SpanMetrics) GetErrors() uint64 {
	if m != nil {
		return m.Errors
	}
	return 0
}

type SpanMetricsSummary struct {
	SpanCount      uint64      `protobuf:"varint,1,opt,name=spanCount,proto3" json:"spanCount,omitempty"`
	ErrorSpanCount uint64      `protobuf:"varint,2,opt,name=errorSpanCount,proto3" json:"errorSpanCount,omitempty"`
	Series         []*KeyValue `protobuf:"bytes,3,rep,name=series,proto3" json:"series,omitempty"`
	P99            uint64      `protobuf:"varint,4,opt,name=p99,proto3" json:"p99,omitempty"`
	P95            uint64      `protobuf:"varint,5,opt,name=p95,proto3" json:"p95,omitempty"`
	P90            uint64      `protobuf:"varint,6,opt,name=p90,proto3" json:"p90,omitempty"`
	P50            uint64      `protobuf:"varint,7,opt,name=p50,proto3" json:"p50,omitempty"`
}

func (m *SpanMetricsSummary) Reset()         { *m = SpanMetricsSummary{} }
func (m *SpanMetricsSummary) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsSummary) ProtoMessage()    {}
func (*SpanMetricsSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{34}
}
func (m *SpanMetricsSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsSummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsSummary.Merge(m, src)
}
func (m *SpanMetricsSummary) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsSummary.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsSummary proto.InternalMessageInfo

func (m *SpanMetricsSummary) GetSpanCount() uint64 {
	if m != nil {
		return m.SpanCount
	}
	return 0
}

func (m *SpanMetricsSummary) GetErrorSpanCount() uint64 {
	if m != nil {
		return m.ErrorSpanCount
	}
	return 0
}

func (m *SpanMetricsSummary) GetSeries() []*KeyValue {
	if m != nil {
		return m.Series
	}
	return nil
}

func (m *SpanMetricsSummary) GetP99() uint64 {
	if m != nil {
		return m.P99
	}
	return 0
}

func (m *SpanMetricsSummary) GetP95() uint64 {
	if m != nil {
		return m.P95
	}
	return 0
}

func (m *SpanMetricsSummary) GetP90() uint64 {
	if m != nil {
		return m.P90
	}
	return 0
}

func (m *SpanMetricsSummary) GetP50() uint64 {
	if m != nil {
		return m.P50
	}
	return 0
}

type SpanMetricsSummaryResponse struct {
	Summaries []*SpanMetricsSummary `protobuf:"bytes,1,rep,name=summaries,proto3" json:"summaries,omitempty"`
}

func (m *SpanMetricsSummaryResponse) Reset()         { *m = SpanMetricsSummaryResponse{} }
func (m *SpanMetricsSummaryResponse) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsSummaryResponse) ProtoMessage()    {}
func (*SpanMetricsSummaryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{35}
}
func (m *SpanMetricsSummaryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsSummaryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsSummaryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsSummaryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsSummaryResponse.Merge(m, src)
}
func (m *SpanMetricsSummaryResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsSummaryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsSummaryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsSummaryResponse proto.InternalMessageInfo

func (m *SpanMetricsSummaryResponse) GetSummaries() []*SpanMetricsSummary {
	if m != nil {
		return m.Summaries
	}
	return nil
}

type TraceQLStatic struct {
	Type   int32   `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	N      int64   `protobuf:"varint,2,opt,name=n,proto3" json:"n,omitempty"`
	F      float64 `protobuf:"fixed64,3,opt,name=f,proto3" json:"f,omitempty"`
	S      string  `protobuf:"bytes,4,opt,name=s,proto3" json:"s,omitempty"`
	B      bool    `protobuf:"varint,5,opt,name=b,proto3" json:"b,omitempty"`
	D      uint64  `protobuf:"varint,6,opt,name=d,proto3" json:"d,omitempty"`
	Status int32   `protobuf:"varint,7,opt,name=status,proto3" json:"status,omitempty"`
	Kind   int32   `protobuf:"varint,8,opt,name=kind,proto3" json:"kind,omitempty"`
}

func (m *TraceQLStatic) Reset()         { *m = TraceQLStatic{} }
func (m *TraceQLStatic) String() string { return proto.CompactTextString(m) }
func (*TraceQLStatic) ProtoMessage()    {}
func (*TraceQLStatic) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{36}
}
func (m *TraceQLStatic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceQLStatic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceQLStatic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceQLStatic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceQLStatic.Merge(m, src)
}
func (m *TraceQLStatic) XXX_Size() int {
	return m.Size()
}
func (m *TraceQLStatic) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceQLStatic.DiscardUnknown(m)
}

var xxx_messageInfo_TraceQLStatic proto.InternalMessageInfo

func (m *TraceQLStatic) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TraceQLStatic) GetN() int64 {
	if m != nil {
		return m.N
	}
	return 0
}

func (m *TraceQLStatic) GetF() float64 {
	if m != nil {
		return m.F
	}
	return 0
}

func (m *TraceQLStatic) GetS() string {
	if m != nil {
		return m.S
	}
	return ""
}

func (m *TraceQLStatic) GetB() bool {
	if m != nil {
		return m.B
	}
	return false
}

func (m *TraceQLStatic) GetD() uint64 {
	if m != nil {
		return m.D
	}
	return 0
}

func (m *TraceQLStatic) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *TraceQLStatic) GetKind() int32 {
	if m != nil {
		return m.Kind
	}
	return 0
}

type SpanMetricsData struct {
	ResultType string               `protobuf:"bytes,1,opt,name=resultType,proto3" json:"resultType,omitempty"`
	Result     []*SpanMetricsResult `protobuf:"bytes,2,rep,name=result,proto3" json:"result,omitempty"`
}

func (m *SpanMetricsData) Reset()         { *m = SpanMetricsData{} }
func (m *SpanMetricsData) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsData) ProtoMessage()    {}
func (*SpanMetricsData) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{37}
}
func (m *SpanMetricsData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsData.Merge(m, src)
}
func (m *SpanMetricsData) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsData) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsData.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsData proto.InternalMessageInfo

func (m *SpanMetricsData) GetResultType() string {
	if m != nil {
		return m.ResultType
	}
	return ""
}

func (m *SpanMetricsData) GetResult() []*SpanMetricsResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type SpanMetricsResult struct {
	LabelName  string                    `protobuf:"bytes,1,opt,name=labelName,proto3" json:"labelName,omitempty"`
	LabelValue string                    `protobuf:"bytes,2,opt,name=labelValue,proto3" json:"labelValue,omitempty"`
	Ts         []*SpanMetricsResultPoint `protobuf:"bytes,3,rep,name=ts,proto3" json:"ts,omitempty"`
}

func (m *SpanMetricsResult) Reset()         { *m = SpanMetricsResult{} }
func (m *SpanMetricsResult) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsResult) ProtoMessage()    {}
func (*SpanMetricsResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{38}
}
func (m *SpanMetricsResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsResult.Merge(m, src)
}
func (m *SpanMetricsResult) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsResult.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsResult proto.InternalMessageInfo

func (m *SpanMetricsResult) GetLabelName() string {
	if m != nil {
		return m.LabelName
	}
	return ""
}

func (m *SpanMetricsResult) GetLabelValue() string {
	if m != nil {
		return m.LabelValue
	}
	return ""
}

func (m *SpanMetricsResult) GetTs() []*SpanMetricsResultPoint {
	if m != nil {
		return m.Ts
	}
	return nil
}

type SpanMetricsResultPoint struct {
	Time             uint32  `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	Val              float64 `protobuf:"fixed64,2,opt,name=val,proto3" json:"val,omitempty"`
	ExemplarTraceID  []byte  `protobuf:"bytes,3,opt,name=exemplarTraceID,proto3" json:"exemplarTraceID,omitempty"`
	ExemplarDuration uint64  `protobuf:"varint,4,opt,name=exemplarDuration,proto3" json:"exemplarDuration,omitempty"`
}

func (m *SpanMetricsResultPoint) Reset()         { *m = SpanMetricsResultPoint{} }
func (m *SpanMetricsResultPoint) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsResultPoint) ProtoMessage()    {}
func (*SpanMetricsResultPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{39}
}
func (m *SpanMetricsResultPoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsResultPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsResultPoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsResultPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsResultPoint.Merge(m, src)
}
func (m *SpanMetricsResultPoint) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsResultPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsResultPoint.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsResultPoint proto.InternalMessageInfo

func (m *SpanMetricsResultPoint) GetTime() uint32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *SpanMetricsResultPoint) GetVal() float64 {
	if m != nil {
		return m.Val
	}
	return 0
}

func (m *SpanMetricsResultPoint) GetExemplarTraceID() []byte {
	if m != nil {
		return m.ExemplarTraceID
	}
	return nil
}

func (m *SpanMetricsResultPoint) GetExemplarDuration() uint64 {
	if m != nil {
		return m.ExemplarDuration
	}
	return 0
}

type QueryRangeRequest struct {
	Query      string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	Start      uint64 `protobuf:"varint,2,opt,name=start,proto3" json:"start,omitempty"`
	End        uint64 `protobuf:"varint,3,opt,name=end,proto3" json:"end,omitempty"`
	Step       uint64 `protobuf:"varint,4,opt,name=step,proto3" json:"step,omitempty"`
	ShardID    uint32 `protobuf:"varint,5,opt,name=shardID,proto3" json:"shardID,omitempty"`
	ShardCount uint32 `protobuf:"varint,6,opt,name=shardCount,proto3" json:"shardCount,omitempty"`
	QueryMode  string `protobuf:"bytes,7,opt,name=queryMode,proto3" json:"queryMode,omitempty"`
}

func (m *QueryRangeRequest) Reset()         { *m = QueryRangeRequest{} }
func (m *QueryRangeRequest) String() string { return proto.CompactTextString(m) }
func (*QueryRangeRequest) ProtoMessage()    {}
func (*QueryRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{40}
}
func (m *QueryRangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRangeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRangeRequest.Merge(m, src)
}
func (m *QueryRangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRangeRequest proto.InternalMessageInfo

func (m *QueryRangeRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *QueryRangeRequest) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *QueryRangeRequest) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *QueryRangeRequest) GetStep() uint64 {
	if m != nil {
		return m.Step
	}
	return 0
}

func (m *QueryRangeRequest) GetShardID() uint32 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *QueryRangeRequest) GetShardCount() uint32 {
	if m != nil {
		return m.ShardCount
	}
	return 0
}

func (m *QueryRangeRequest) GetQueryMode() string {
	if m != nil {
		return m.QueryMode
	}
	return ""
}

type QueryRangeResponse struct {
	Series  []*TimeSeries  `protobuf:"bytes,1,rep,name=series,proto3" json:"series,omitempty"`
	Metrics *SearchMetrics `protobuf:"bytes,2,opt,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *QueryRangeResponse) Reset()         { *m = QueryRangeResponse{} }
func (m *QueryRangeResponse) String() string { return proto.CompactTextString(m) }
func (*QueryRangeResponse) ProtoMessage()    {}
func (*QueryRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{41}
}
func (m *QueryRangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRangeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRangeResponse.Merge(m, src)
}
func (m *QueryRangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRangeResponse proto.InternalMessageInfo

func (m *QueryRangeResponse) GetSeries() []*TimeSeries {
	if m != nil {
		return m.Series
	}
	return nil
}

func (m *QueryRangeResponse) GetMetrics() *SearchMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type Sample struct {
	// Fields order MUST match promql.FPoint so that we can cast types between them.
	TimestampMs int64   `protobuf:"varint,2,opt,name=timestamp_ms,json=timestampMs,proto3" json:"timestamp_ms,omitempty"`
	Value       float64 `protobuf:"fixed64,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Sample) Reset()         { *m = Sample{} }
func (m *Sample) String() string { return proto.CompactTextString(m) }
func (*Sample) ProtoMessage()    {}
func (*Sample) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{42}
}
func (m *Sample) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sample) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sample.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sample) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sample.Merge(m, src)
}
func (m *Sample) XXX_Size() int {
	return m.Size()
}
func (m *Sample) XXX_DiscardUnknown() {
	xxx_messageInfo_Sample.DiscardUnknown(m)
}

var xxx_messageInfo_Sample proto.InternalMessageInfo

func (m *Sample) GetTimestampMs() int64 {
	if m != nil {
		return m.TimestampMs
	}
	return 0
}

func (m *Sample) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type TimeSeries struct {
	// Series labels containing name and value. Data-type aware.
	Labels []v1.KeyValue `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels"`
	// Sorted by time, oldest sample first.
	Samples []Sample `protobuf:"bytes,2,rep,name=samples,proto3" json:"samples"`
	// prom_labels are a flattened string-only version of the typed labels.
	// They are used internally and may differ from official prometheus conventions.
	PromLabels string `protobuf:"bytes,3,opt,name=prom_labels,json=promLabels,proto3" json:"prom_labels,omitempty"`
}

func (m *TimeSeries) Reset()         { *m = TimeSeries{} }
func (m *TimeSeries) String() string { return proto.CompactTextString(m) }
func (*TimeSeries) ProtoMessage()    {}
func (*TimeSeries) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{43}
}
func (m *TimeSeries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimeSeries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimeSeries.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimeSeries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeSeries.Merge(m, src)
}
func (m *TimeSeries) XXX_Size() int {
	return m.Size()
}
func (m *TimeSeries) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeSeries.DiscardUnknown(m)
}

var xxx_messageInfo_TimeSeries proto.InternalMessageInfo

func (m *TimeSeries) GetLabels() []v1.KeyValue {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *TimeSeries) GetSamples() []Sample {
	if m != nil {
		return m.Samples
	}
	return nil
}

func (m *TimeSeries) GetPromLabels() string {
	if m != nil {
		return m.PromLabels
	}
	return ""
}

func init() {
	proto.RegisterEnum("tempopb.PushErrorReason", PushErrorReason_name, PushErrorReason_value)
	proto.RegisterEnum("tempopb.DedicatedColumn_Scope", DedicatedColumn_Scope_name, DedicatedColumn_Scope_value)
	proto.RegisterEnum("tempopb.DedicatedColumn_Type", DedicatedColumn_Type_name, DedicatedColumn_Type_value)
	proto.RegisterType((*TraceByIDRequest)(nil), "tempopb.TraceByIDRequest")
	proto.RegisterType((*TraceByIDResponse)(nil), "tempopb.TraceByIDResponse")
	proto.RegisterType((*TraceByIDMetrics)(nil), "tempopb.TraceByIDMetrics")
	proto.RegisterType((*SearchRequest)(nil), "tempopb.SearchRequest")
	proto.RegisterMapType((map[string]string)(nil), "tempopb.SearchRequest.TagsEntry")
	proto.RegisterType((*SearchBlockRequest)(nil), "tempopb.SearchBlockRequest")
	proto.RegisterType((*DedicatedColumn)(nil), "tempopb.DedicatedColumn")
	proto.RegisterType((*SearchResponse)(nil), "tempopb.SearchResponse")
	proto.RegisterType((*TraceSearchMetadata)(nil), "tempopb.TraceSearchMetadata")
	proto.RegisterMapType((map[string]*ServiceStats)(nil), "tempopb.TraceSearchMetadata.ServiceStatsEntry")
	proto.RegisterType((*ServiceStats)(nil), "tempopb.ServiceStats")
	proto.RegisterType((*SpanSet)(nil), "tempopb.SpanSet")
	proto.RegisterType((*Span)(nil), "tempopb.Span")
	proto.RegisterType((*SearchMetrics)(nil), "tempopb.SearchMetrics")
	proto.RegisterType((*SearchTagsRequest)(nil), "tempopb.SearchTagsRequest")
	proto.RegisterType((*SearchTagsBlockRequest)(nil), "tempopb.SearchTagsBlockRequest")
	proto.RegisterType((*SearchTagValuesBlockRequest)(nil), "tempopb.SearchTagValuesBlockRequest")
	proto.RegisterType((*SearchTagsResponse)(nil), "tempopb.SearchTagsResponse")
	proto.RegisterType((*SearchTagsV2Response)(nil), "tempopb.SearchTagsV2Response")
	proto.RegisterType((*SearchTagsV2Scope)(nil), "tempopb.SearchTagsV2Scope")
	proto.RegisterType((*SearchTagValuesRequest)(nil), "tempopb.SearchTagValuesRequest")
	proto.RegisterType((*SearchTagValuesResponse)(nil), "tempopb.SearchTagValuesResponse")
	proto.RegisterType((*TagValue)(nil), "tempopb.TagValue")
	proto.RegisterType((*SearchTagValuesV2Response)(nil), "tempopb.SearchTagValuesV2Response")
	proto.RegisterType((*Trace)(nil), "tempopb.Trace")
	proto.RegisterType((*PushResponse)(nil), "tempopb.PushResponse")
	proto.RegisterType((*PushBytesRequest)(nil), "tempopb.PushBytesRequest")
	proto.RegisterType((*PushSpansRequest)(nil), "tempopb.PushSpansRequest")
	proto.RegisterType((*TraceBytes)(nil), "tempopb.TraceBytes")
	proto.RegisterType((*LinkSlice)(nil), "tempopb.LinkSlice")
	proto.RegisterType((*SpanMetricsRequest)(nil), "tempopb.SpanMetricsRequest")
	proto.RegisterType((*SpanMetricsSummaryRequest)(nil), "tempopb.SpanMetricsSummaryRequest")
	proto.RegisterType((*SpanMetricsResponse)(nil), "tempopb.SpanMetricsResponse")
	proto.RegisterType((*RawHistogram)(nil), "tempopb.RawHistogram")
	proto.RegisterType((*KeyValue)(nil), "tempopb.KeyValue")
	proto.RegisterType((*SpanMetrics)(nil), "tempopb.SpanMetrics")
	proto.RegisterType((*SpanMetricsSummary)(nil), "tempopb.SpanMetricsSummary")
	proto.RegisterType((*SpanMetricsSummaryResponse)(nil), "tempopb.SpanMetricsSummaryResponse")
	proto.RegisterType((*TraceQLStatic)(nil), "tempopb.TraceQLStatic")
	proto.RegisterType((*SpanMetricsData)(nil), "tempopb.SpanMetricsData")
	proto.RegisterType((*SpanMetricsResult)(nil), "tempopb.SpanMetricsResult")
	proto.RegisterType((*SpanMetricsResultPoint)(nil), "tempopb.SpanMetricsResultPoint")
	proto.RegisterType((*QueryRangeRequest)(nil), "tempopb.QueryRangeRequest")
	proto.RegisterType((*QueryRangeResponse)(nil), "tempopb.QueryRangeResponse")
	proto.RegisterType((*Sample)(nil), "tempopb.Sample")
	proto.RegisterType((*TimeSeries)(nil), "tempopb.TimeSeries")
}

func init() { proto.RegisterFile("pkg/tempopb/tempo.proto", fileDescriptor_f22805646f4f62b6) }

var fileDescriptor_f22805646f4f62b6 = []byte{
	// 2595 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x1a, 0xcb, 0x6e, 0x23, 0xc7,
	0x51, 0x23, 0xbe, 0x8b, 0x94, 0x44, 0xf5, 0xae, 0x65, 0x2e, 0x65, 0x4b, 0xca, 0x78, 0xe1, 0x28,
	0x7e, 0x50, 0x5a, 0x7a, 0x17, 0xf6, 0xda, 0x89, 0x03, 0x69, 0xa5, 0xc8, 0xb2, 0xf5, 0x72, 0x93,
	0x96, 0x8d, 0xc0, 0x80, 0x30, 0x24, 0x7b, 0xb9, 0x03, 0x91, 0x33, 0xf4, 0xcc, 0x50, 0x59, 0xe6,
	0x18, 0x20, 0x01, 0x02, 0xe4, 0x90, 0x43, 0x72, 0xf0, 0x31, 0xa7, 0x20, 0xe7, 0x9c, 0x73, 0x0a,
	0x10, 0xf8, 0x12, 0xc3, 0x40, 0x2e, 0x46, 0x0e, 0x46, 0x60, 0x1f, 0xf2, 0x01, 0xf9, 0x81, 0xa0,
	0xaa, 0xbb, 0xe7, 0x41, 0x52, 0xda, 0x6c, 0xb2, 0x46, 0x7c, 0xf0, 0x49, 0x5d, 0xd5, 0x35, 0xd5,
	0xd5, 0xf5, 0xae, 0xa6, 0xe0, 0xe9, 0xc1, 0x79, 0x77, 0x23, 0x10, 0xfd, 0x81, 0x3b, 0x68, 0xc9,
	0xbf, 0xb5, 0x81, 0xe7, 0x06, 0x2e, 0xcb, 0x29, 0x64, 0x75, 0xa9, 0xed, 0xf6, 0xfb, 0xae, 0xb3,
	0x71, 0x71, 0x6b, 0x43, 0xae, 0x24, 0x41, 0xf5, 0xe5, 0xae, 0x1d, 0x3c, 0x18, 0xb6, 0x6a, 0x6d,
	0xb7, 0xbf, 0xd1, 0x75, 0xbb, 0xee, 0x06, 0xa1, 0x5b, 0xc3, 0xfb, 0x04, 0x11, 0x40, 0x2b, 0x45,
	0x7e, 0x3d, 0xf0, 0xac, 0xb6, 0x40, 0x2e, 0xb4, 0x90, 0x58, 0xf3, 0x17, 0x06, 0x94, 0x9b, 0x08,
	0x6f, 0x8f, 0xf6, 0x77, 0xb8, 0xf8, 0x68, 0x28, 0xfc, 0x80, 0x55, 0x20, 0x47, 0x34, 0xfb, 0x3b,
	0x15, 0x63, 0xcd, 0x58, 0x2f, 0x71, 0x0d, 0xb2, 0x15, 0x80, 0x56, 0xcf, 0x6d, 0x9f, 0x37, 0x02,
	0xcb, 0x0b, 0x2a, 0xb3, 0x6b, 0xc6, 0x7a, 0x81, 0xc7, 0x30, 0xac, 0x0a, 0x79, 0x82, 0x76, 0x9d,
	0x4e, 0x25, 0x45, 0xbb, 0x21, 0xcc, 0x9e, 0x81, 0xc2, 0x47, 0x43, 0xe1, 0x8d, 0x0e, 0xdd, 0x8e,
	0xa8, 0x64, 0x68, 0x33, 0x42, 0x98, 0x0e, 0x2c, 0xc6, 0xe4, 0xf0, 0x07, 0xae, 0xe3, 0x0b, 0x76,
	0x13, 0x32, 0x74, 0x32, 0x89, 0x51, 0xac, 0xcf, 0xd7, 0x94, 0x4e, 0x6a, 0x44, 0xca, 0xe5, 0x26,
	0x7b, 0x05, 0x72, 0x7d, 0x11, 0x78, 0x76, 0xdb, 0x27, 0x89, 0x8a, 0xf5, 0x1b, 0x49, 0x3a, 0x64,
	0x79, 0x28, 0x09, 0xb8, 0xa6, 0x34, 0x59, 0xec, 0xde, 0x6a, 0xd3, 0xfc, 0x74, 0x16, 0xe6, 0x1a,
	0xc2, 0xf2, 0xda, 0x0f, 0xb4, 0x26, 0x5e, 0x87, 0x74, 0xd3, 0xea, 0xfa, 0x15, 0x63, 0x2d, 0xb5,
	0x5e, 0xac, 0xaf, 0x85, 0x7c, 0x13, 0x54, 0x35, 0x24, 0xd9, 0x75, 0x02, 0x6f, 0xb4, 0x9d, 0xfe,
	0xe4, 0x8b, 0xd5, 0x19, 0x4e, 0xdf, 0xb0, 0x9b, 0x30, 0x77, 0x68, 0x3b, 0x3b, 0x43, 0xcf, 0x0a,
	0x6c, 0xd7, 0x39, 0x94, 0xc2, 0xcd, 0xf1, 0x24, 0x92, 0xa8, 0xac, 0x87, 0x31, 0xaa, 0x94, 0xa2,
	0x8a, 0x23, 0xd9, 0x75, 0xc8, 0x1c, 0xd8, 0x7d, 0x3b, 0xa8, 0xa4, 0x69, 0x57, 0x02, 0x88, 0xf5,
	0xc9, 0x10, 0x19, 0x89, 0x25, 0x80, 0x95, 0x21, 0x25, 0x9c, 0x4e, 0x25, 0x4b, 0x38, 0x5c, 0x22,
	0xdd, 0xbb, 0xa8, 0xe8, 0x4a, 0x9e, 0xb4, 0x2e, 0x01, 0xb6, 0x0e, 0x0b, 0x8d, 0x81, 0xe5, 0xf8,
	0x27, 0xc2, 0xc3, 0xbf, 0x0d, 0x11, 0x54, 0x0a, 0xf4, 0xcd, 0x38, 0xba, 0xfa, 0x2a, 0x14, 0xc2,
	0x2b, 0x22, 0xfb, 0x73, 0x31, 0x22, 0x8b, 0x14, 0x38, 0x2e, 0x91, 0xfd, 0x85, 0xd5, 0x1b, 0x0a,
	0xe5, 0x0f, 0x12, 0x78, 0x7d, 0xf6, 0x35, 0xc3, 0xfc, 0x4b, 0x0a, 0x98, 0x54, 0xd5, 0x36, 0x7a,
	0x81, 0xd6, 0xea, 0x6d, 0x28, 0xf8, 0x5a, 0x81, 0xca, 0xb4, 0x4b, 0xd3, 0x55, 0xcb, 0x23, 0x42,
	0xf4, 0x4a, 0xf2, 0xa5, 0xfd, 0x1d, 0x75, 0x90, 0x06, 0xd1, 0xb3, 0xe8, 0xea, 0x27, 0x56, 0x57,
	0x28, 0xfd, 0x45, 0x08, 0xd4, 0xf0, 0xc0, 0xea, 0x0a, 0xbf, 0xe9, 0x4a, 0xd6, 0x4a, 0x87, 0x49,
	0x24, 0x7a, 0xae, 0x70, 0xda, 0x6e, 0xc7, 0x76, 0xba, 0xca, 0x39, 0x43, 0x18, 0x39, 0xd8, 0x4e,
	0x47, 0x3c, 0x44, 0x76, 0x0d, 0xfb, 0xa7, 0x42, 0xe9, 0x36, 0x89, 0x64, 0x26, 0x94, 0x02, 0x37,
	0xb0, 0x7a, 0x5c, 0xb4, 0x5d, 0xaf, 0xe3, 0x57, 0x72, 0x44, 0x94, 0xc0, 0x21, 0x4d, 0xc7, 0x0a,
	0xac, 0x5d, 0x7d, 0x92, 0x34, 0x48, 0x02, 0x87, 0xf7, 0xbc, 0x10, 0x9e, 0x6f, 0xbb, 0x0e, 0xd9,
	0xa3, 0xc0, 0x35, 0xc8, 0x18, 0xa4, 0x7d, 0x3c, 0x1e, 0xd6, 0x8c, 0xf5, 0x34, 0xa7, 0x35, 0x46,
	0xe4, 0x7d, 0xd7, 0x0d, 0x84, 0x47, 0x82, 0x15, 0xe9, 0xcc, 0x18, 0x86, 0xed, 0x40, 0xb9, 0x23,
	0x3a, 0x76, 0xdb, 0x0a, 0x44, 0xe7, 0x9e, 0xdb, 0x1b, 0xf6, 0x1d, 0xbf, 0x52, 0x22, 0x6f, 0xae,
	0x84, 0x2a, 0xdf, 0x49, 0x12, 0xf0, 0x89, 0x2f, 0xcc, 0x3f, 0x1b, 0xb0, 0x30, 0x46, 0xc5, 0x6e,
	0x43, 0xc6, 0x6f, 0xbb, 0x03, 0xa9, 0xf1, 0xf9, 0xfa, 0xca, 0x65, 0xec, 0x6a, 0x0d, 0xa4, 0xe2,
	0x92, 0x18, 0xef, 0xe0, 0x58, 0x7d, 0xed, 0x2b, 0xb4, 0x66, 0xb7, 0x20, 0x1d, 0x8c, 0x06, 0x32,
	0xca, 0xe7, 0xeb, 0xcf, 0x5e, 0xca, 0xa8, 0x39, 0x1a, 0x08, 0x4e, 0xa4, 0xe6, 0x2a, 0x64, 0x88,
	0x2d, 0xcb, 0x43, 0xba, 0x71, 0xb2, 0x75, 0x54, 0x9e, 0x61, 0x25, 0xc8, 0xf3, 0xdd, 0xc6, 0xf1,
	0x7b, 0xfc, 0xde, 0x6e, 0xd9, 0x30, 0x19, 0xa4, 0x91, 0x9c, 0x01, 0x64, 0x1b, 0x4d, 0xbe, 0x7f,
	0xb4, 0x57, 0x9e, 0x31, 0x1f, 0xc2, 0xbc, 0xf6, 0x2e, 0x95, 0x60, 0x6e, 0x43, 0x96, 0x72, 0x88,
	0x8e, 0xf0, 0x67, 0x92, 0x99, 0x43, 0x52, 0x1f, 0x8a, 0xc0, 0x42, 0x0b, 0x71, 0x45, 0xcb, 0x36,
	0xc7, 0x13, 0xce, 0xb8, 0xf7, 0x4e, 0x64, 0x9b, 0xbf, 0xa5, 0xe0, 0xda, 0x14, 0x8e, 0xe3, 0x99,
	0xb6, 0x10, 0x65, 0xda, 0x75, 0x58, 0xf0, 0x5c, 0x37, 0x68, 0x08, 0xef, 0xc2, 0x6e, 0x8b, 0xa3,
	0x48, 0x65, 0xe3, 0x68, 0xf4, 0x4e, 0x44, 0x11, 0x7b, 0xa2, 0x93, 0x89, 0x37, 0x89, 0x64, 0x2f,
	0xc1, 0x22, 0x85, 0x44, 0xd3, 0xee, 0x8b, 0xf7, 0x1c, 0xfb, 0xe1, 0x91, 0xe5, 0xb8, 0x14, 0x09,
	0x69, 0x3e, 0xb9, 0x81, 0x5e, 0xd5, 0x89, 0x52, 0x92, 0x4c, 0x2f, 0x31, 0x0c, 0x7b, 0x01, 0x72,
	0xbe, 0xca, 0x19, 0x59, 0xd2, 0x40, 0x39, 0xd2, 0x80, 0xc4, 0x73, 0x4d, 0xc0, 0x5e, 0x82, 0xbc,
	0x5a, 0x62, 0x4c, 0xa4, 0xa6, 0x12, 0x87, 0x14, 0x8c, 0x43, 0xc9, 0x97, 0x97, 0x6b, 0x04, 0x56,
	0xe0, 0x57, 0xf2, 0xf4, 0x45, 0xed, 0x2a, 0xbb, 0xd4, 0x1a, 0xb1, 0x0f, 0x28, 0x49, 0xf1, 0x04,
	0x8f, 0xea, 0x29, 0x2c, 0x4e, 0x90, 0x4c, 0xc9, 0x63, 0x2f, 0xc6, 0xf3, 0x58, 0xb1, 0xfe, 0x54,
	0xcc, 0xa8, 0xd1, 0xc7, 0xf1, 0xf4, 0x76, 0x00, 0xa5, 0xf8, 0x16, 0xe5, 0xa1, 0x81, 0xe5, 0xdc,
	0x73, 0x87, 0x4e, 0x40, 0x8c, 0x31, 0x0f, 0x69, 0x04, 0xea, 0x54, 0x78, 0x9e, 0xeb, 0xc9, 0x6d,
	0x59, 0x0c, 0x62, 0x18, 0xf3, 0xe7, 0x06, 0xe4, 0x94, 0x3e, 0xd8, 0x73, 0x90, 0xc1, 0x0f, 0xb5,
	0x5b, 0xce, 0x25, 0x14, 0xc6, 0xe5, 0x1e, 0x3a, 0x4f, 0xdf, 0x0a, 0xda, 0x0f, 0x44, 0x47, 0x71,
	0xd3, 0x20, 0x7b, 0x03, 0xc0, 0x0a, 0x02, 0xcf, 0x6e, 0x0d, 0x03, 0x81, 0x15, 0x05, 0x79, 0x2c,
	0x87, 0x3c, 0x54, 0x17, 0x71, 0x71, 0xab, 0xf6, 0x8e, 0x18, 0x9d, 0xe2, 0x6d, 0x78, 0x8c, 0x1c,
	0x63, 0x3d, 0x8d, 0xc7, 0xb0, 0x25, 0xc8, 0xe2, 0x41, 0xa1, 0x6f, 0x2a, 0x68, 0x6a, 0x08, 0x4f,
	0x75, 0xaf, 0xd4, 0x65, 0xee, 0x75, 0x13, 0xe6, 0xb4, 0x33, 0x21, 0xec, 0x2b, 0x47, 0x4c, 0x22,
	0xc7, 0x6e, 0x91, 0x79, 0xbc, 0x5b, 0x7c, 0x1c, 0xd6, 0x72, 0x15, 0x8c, 0x18, 0x51, 0xb6, 0xe3,
	0x0f, 0x44, 0x3b, 0x10, 0x9d, 0xa6, 0x0e, 0x7a, 0xaa, 0x77, 0x63, 0x68, 0xf6, 0x3c, 0xcc, 0x87,
	0xa8, 0xed, 0x11, 0x1e, 0x3e, 0x4b, 0xf2, 0x8d, 0x61, 0xd9, 0x1a, 0x14, 0x29, 0xbb, 0x53, 0x71,
	0xd3, 0x95, 0x3b, 0x8e, 0xc2, 0x8b, 0xb6, 0xdd, 0xfe, 0xa0, 0x27, 0x02, 0xd1, 0x79, 0xdb, 0x6d,
	0xf9, 0xba, 0xf6, 0x24, 0x90, 0xe8, 0x37, 0xf4, 0x11, 0x51, 0xc8, 0x60, 0x8b, 0x10, 0x28, 0x77,
	0xc4, 0x52, 0x8a, 0x93, 0x25, 0x71, 0xc6, 0xd1, 0x09, 0xb9, 0xa9, 0x86, 0x53, 0x0d, 0x8a, 0xcb,
	0x4d, 0x58, 0xf3, 0x5d, 0x8c, 0x07, 0x54, 0x0d, 0x56, 0x75, 0x5d, 0x94, 0xaf, 0xeb, 0x74, 0x2e,
	0x8d, 0xad, 0xd2, 0x75, 0xd8, 0x62, 0xa4, 0xa6, 0xb4, 0x18, 0xe9, 0xb0, 0xc5, 0x30, 0x3f, 0x4d,
	0xc1, 0x52, 0xc4, 0x33, 0x51, 0xed, 0x5f, 0x9b, 0xac, 0xf6, 0xd5, 0xb1, 0x7c, 0x19, 0x93, 0xe3,
	0xdb, 0x8a, 0xff, 0xcd, 0xa8, 0xf8, 0x9f, 0xa7, 0x60, 0x39, 0x34, 0x0e, 0x85, 0x57, 0xd2, 0xaa,
	0x3f, 0x98, 0xb4, 0xea, 0xea, 0xa4, 0x55, 0xe5, 0x87, 0xdf, 0x9a, 0xf6, 0x1b, 0x65, 0xda, 0x4d,
	0xdd, 0x94, 0xcb, 0xb0, 0x53, 0xad, 0x50, 0x15, 0xf2, 0x81, 0xd5, 0xc5, 0x5e, 0x41, 0x56, 0x9d,
	0x02, 0x0f, 0x61, 0xf3, 0x6d, 0xb8, 0x1e, 0x7d, 0x71, 0x5a, 0x0f, 0xbf, 0xa9, 0x43, 0x96, 0xd2,
	0x84, 0xae, 0x53, 0xd3, 0xe2, 0xfa, 0xb4, 0x2e, 0xfb, 0x3f, 0x45, 0x69, 0xbe, 0x11, 0x4f, 0x3e,
	0x6a, 0x33, 0x2c, 0x29, 0x46, 0xac, 0xa4, 0x30, 0x48, 0x07, 0x38, 0x7b, 0xcd, 0x92, 0x30, 0xb4,
	0x36, 0x07, 0xb1, 0x2c, 0x93, 0xf0, 0x2d, 0xea, 0xa4, 0xa4, 0xb8, 0x61, 0x27, 0x25, 0x41, 0x4c,
	0x61, 0x34, 0x66, 0xea, 0xf1, 0x84, 0x80, 0x28, 0xb1, 0xa5, 0xa7, 0x24, 0xb6, 0x4c, 0x94, 0xd8,
	0x5e, 0x85, 0xa7, 0x27, 0x4e, 0x54, 0xb7, 0xc7, 0xb4, 0xad, 0x91, 0x4a, 0x65, 0x11, 0xc2, 0xbc,
	0x0d, 0x79, 0xfd, 0x09, 0x5d, 0x65, 0x14, 0xa6, 0x56, 0x5a, 0x4f, 0x9f, 0x9a, 0xcc, 0x03, 0xb8,
	0x31, 0x76, 0x5c, 0x4c, 0xdd, 0x1b, 0xe3, 0x07, 0x16, 0xeb, 0x8b, 0x51, 0x63, 0xa4, 0x76, 0xe2,
	0x32, 0x6c, 0x43, 0x86, 0x4a, 0x1a, 0xbb, 0x0b, 0xb9, 0x16, 0xf5, 0x06, 0xfa, 0xbb, 0x28, 0x56,
	0xe5, 0x6b, 0xc0, 0xc5, 0xad, 0x1a, 0x17, 0xbe, 0x3b, 0xf4, 0xda, 0x82, 0x6a, 0x04, 0xd7, 0xf4,
	0xe6, 0x11, 0x94, 0x4e, 0x86, 0x7e, 0xd4, 0x32, 0xbf, 0x09, 0x73, 0xd4, 0xb4, 0xf8, 0xdb, 0xa3,
	0xa6, 0x9a, 0xcd, 0x53, 0xeb, 0xf3, 0x31, 0x07, 0x44, 0xea, 0x5d, 0xa4, 0xe0, 0xc2, 0xf2, 0x5d,
	0x87, 0x27, 0xc9, 0xcd, 0xdf, 0x19, 0x50, 0x46, 0x12, 0x2a, 0x59, 0xda, 0x7a, 0x2f, 0x87, 0x7d,
	0x38, 0x5a, 0xbb, 0xb4, 0xfd, 0x14, 0xce, 0xd1, 0x7f, 0xff, 0x62, 0x75, 0xee, 0xc4, 0x13, 0x56,
	0xaf, 0xe7, 0xb6, 0x25, 0xb5, 0x6e, 0xc0, 0xbf, 0x0b, 0x29, 0xbb, 0x23, 0x1b, 0x9b, 0x4b, 0x69,
	0x91, 0x82, 0xdd, 0x01, 0x90, 0x39, 0x67, 0xc7, 0x0a, 0xac, 0x4a, 0xfa, 0x2a, 0xfa, 0x18, 0xa1,
	0x79, 0x28, 0x45, 0x94, 0x9a, 0x50, 0x22, 0xfe, 0x0f, 0x2a, 0xbc, 0x09, 0xa0, 0xde, 0x1a, 0xb0,
	0x4a, 0x2f, 0x25, 0x66, 0x8e, 0x92, 0xbe, 0x94, 0xf9, 0x26, 0x14, 0x0e, 0x6c, 0xe7, 0xbc, 0xd1,
	0xb3, 0xdb, 0x38, 0x12, 0x65, 0x7a, 0xb6, 0x73, 0xae, 0xcf, 0x5a, 0x9e, 0x3c, 0x0b, 0xcf, 0xa8,
	0xe1, 0x07, 0x5c, 0x52, 0x9a, 0x3f, 0x33, 0x80, 0x21, 0x52, 0x0f, 0x1f, 0x51, 0x5d, 0x97, 0xee,
	0x6f, 0xc4, 0xdd, 0xbf, 0x02, 0xb9, 0xae, 0xe7, 0x0e, 0x07, 0xdb, 0x3a, 0x2c, 0x34, 0x88, 0xf4,
	0x3d, 0x7a, 0x6a, 0x90, 0xdd, 0x9b, 0x04, 0xfe, 0xe3, 0x70, 0xf9, 0xa5, 0x01, 0x37, 0x62, 0x42,
	0x34, 0x86, 0xfd, 0xbe, 0xe5, 0x8d, 0xfe, 0x3f, 0xb2, 0xfc, 0xc1, 0x80, 0x6b, 0x09, 0x85, 0x44,
	0x71, 0x2b, 0xfc, 0xc0, 0xee, 0x63, 0x4e, 0x24, 0x49, 0xf2, 0x3c, 0x42, 0x24, 0x9b, 0x78, 0xd9,
	0xf7, 0xc5, 0x9a, 0xf8, 0xe7, 0x61, 0x9e, 0xdc, 0xb9, 0x11, 0x92, 0x48, 0xd1, 0xc6, 0xb0, 0xac,
	0x16, 0x8d, 0x88, 0x69, 0xb2, 0xe0, 0xf5, 0x44, 0x0b, 0x3f, 0x31, 0x20, 0x7e, 0x1f, 0x4a, 0xdc,
	0xfa, 0xc9, 0x5b, 0xb6, 0x1f, 0xb8, 0x5d, 0xcf, 0xea, 0xa3, 0x93, 0xb4, 0x86, 0xed, 0x73, 0x21,
	0xe7, 0x88, 0x34, 0x57, 0x10, 0xde, 0xbd, 0x1d, 0x93, 0x4c, 0x02, 0xe6, 0xdb, 0x90, 0xd7, 0x4d,
	0xf0, 0x94, 0xb9, 0xe6, 0xa5, 0xe4, 0x5c, 0xb3, 0x94, 0x9c, 0xa5, 0xde, 0x3d, 0xc0, 0xe1, 0xc5,
	0x6e, 0xeb, 0x0c, 0xf4, 0x1b, 0x03, 0x8a, 0x31, 0x11, 0xd9, 0x36, 0x2c, 0xf6, 0xac, 0x40, 0x38,
	0xed, 0xd1, 0xd9, 0x03, 0x2d, 0x9e, 0xf2, 0xca, 0x68, 0x42, 0x8a, 0xcb, 0xce, 0xcb, 0x8a, 0x3e,
	0xba, 0xcd, 0xf7, 0x20, 0xeb, 0x0b, 0xcf, 0x56, 0xe1, 0x1d, 0xcf, 0x5a, 0x61, 0xef, 0xae, 0x08,
	0xf0, 0xe2, 0x32, 0x5f, 0x28, 0xc5, 0x2a, 0xc8, 0xfc, 0x6b, 0xd2, 0xbb, 0x95, 0x63, 0x4d, 0x8e,
	0x5c, 0x8f, 0xb0, 0xd6, 0xec, 0x54, 0x6b, 0x45, 0xf2, 0xa5, 0x1e, 0x25, 0x5f, 0x19, 0x52, 0x83,
	0xbb, 0x77, 0xd5, 0xc0, 0x82, 0x4b, 0x89, 0xb9, 0x43, 0x8e, 0x47, 0x98, 0x3b, 0x12, 0xb3, 0xa9,
	0xba, 0x74, 0x5c, 0x12, 0xe6, 0xce, 0xa6, 0x6a, 0xc7, 0x71, 0x69, 0xbe, 0x0f, 0xd5, 0x69, 0x71,
	0xa2, 0x5c, 0xf4, 0x2e, 0x14, 0x7c, 0x42, 0xd9, 0x62, 0x32, 0x05, 0x4c, 0xf9, 0x2e, 0xa2, 0x36,
	0x7f, 0x6b, 0xc0, 0x5c, 0xc2, 0xb0, 0x89, 0xea, 0x93, 0x51, 0xd5, 0xa7, 0x04, 0x86, 0x43, 0xca,
	0x48, 0x71, 0xc3, 0x41, 0xe8, 0x3e, 0xe9, 0xdb, 0xe0, 0xc6, 0x7d, 0x84, 0xe4, 0xa0, 0x52, 0xe0,
	0x86, 0x8f, 0x50, 0x8b, 0x2e, 0x97, 0xe7, 0x46, 0x0b, 0xa1, 0x8e, 0xba, 0x98, 0xd1, 0xa1, 0x09,
	0x31, 0xb0, 0x82, 0xa1, 0xec, 0x8f, 0x32, 0x5c, 0x41, 0x78, 0xe2, 0xb9, 0xed, 0x74, 0xa8, 0x23,
	0xca, 0x70, 0x5a, 0x9b, 0x42, 0x3e, 0x37, 0x2a, 0xc1, 0x31, 0xcd, 0x62, 0xbb, 0xe3, 0x09, 0x7f,
	0xd8, 0x0b, 0x9a, 0x51, 0x71, 0x8c, 0x61, 0xb0, 0xbd, 0x90, 0x90, 0x72, 0x9b, 0xea, 0xd4, 0x18,
	0x22, 0x0a, 0xae, 0x28, 0x31, 0x0b, 0x2e, 0x4e, 0xec, 0xa2, 0x9b, 0xf4, 0xac, 0x96, 0xe8, 0xc5,
	0xfa, 0x83, 0x08, 0x81, 0x72, 0x10, 0x70, 0x1a, 0xab, 0xc7, 0x31, 0x0c, 0xdb, 0x80, 0xd9, 0x40,
	0xbb, 0xc6, 0xea, 0xe5, 0x32, 0x9c, 0xb8, 0xb6, 0x13, 0xf0, 0xd9, 0xc0, 0xc7, 0x18, 0x5a, 0x9a,
	0xbe, 0x4d, 0xc6, 0xb0, 0x95, 0x10, 0x73, 0x9c, 0xd6, 0xe8, 0x1d, 0x17, 0x56, 0x8f, 0x0e, 0x36,
	0x38, 0x2e, 0x71, 0xe6, 0x13, 0x0f, 0x45, 0x7f, 0xd0, 0xb3, 0xbc, 0xa6, 0x7a, 0x1f, 0x4a, 0xd1,
	0x4b, 0xfc, 0x38, 0x9a, 0xbd, 0x00, 0x65, 0x8d, 0xd2, 0xef, 0xc5, 0xca, 0x39, 0x27, 0xf0, 0xe6,
	0x9f, 0x0c, 0x58, 0xa4, 0xb7, 0x5f, 0x6e, 0x39, 0x5d, 0x71, 0x75, 0x52, 0x0e, 0x93, 0xac, 0x4a,
	0x34, 0x89, 0x24, 0x2b, 0x43, 0x93, 0xde, 0x96, 0xb1, 0x8d, 0x0d, 0xc4, 0x40, 0x9d, 0x49, 0x6b,
	0x4c, 0xe8, 0xfe, 0x03, 0xcb, 0xeb, 0xec, 0xef, 0xa8, 0x74, 0xac, 0x41, 0xd4, 0x34, 0x2d, 0x65,
	0x30, 0xca, 0xce, 0x3b, 0x86, 0x49, 0xfe, 0x46, 0x90, 0x1b, 0xff, 0x8d, 0xc0, 0x07, 0x16, 0x17,
	0x5f, 0xc5, 0xca, 0x8b, 0x61, 0xf0, 0xca, 0x40, 0xb9, 0x16, 0xe5, 0x37, 0xbb, 0x2f, 0x1a, 0xb4,
	0x15, 0x86, 0xef, 0xe3, 0x3f, 0xdd, 0x6d, 0x41, 0xb6, 0x61, 0xe1, 0xb4, 0xce, 0xbe, 0x03, 0x25,
	0x34, 0x97, 0x1f, 0x58, 0xfd, 0xc1, 0x59, 0xdf, 0x57, 0xe1, 0x53, 0x0c, 0x71, 0xf2, 0x9d, 0x5e,
	0xa6, 0x5a, 0x83, 0x6c, 0xa9, 0x52, 0xea, 0xc7, 0x06, 0x40, 0x24, 0x0b, 0xbb, 0x0b, 0x59, 0x72,
	0xae, 0xc9, 0xc8, 0x9e, 0x7c, 0xd3, 0x50, 0xbf, 0x28, 0xa8, 0x0f, 0xd8, 0x06, 0xe4, 0x7c, 0x12,
	0x46, 0x67, 0xd2, 0x85, 0x48, 0x7c, 0xc2, 0x2b, 0x7a, 0x4d, 0xc5, 0x56, 0xa1, 0x38, 0xf0, 0xdc,
	0xfe, 0x99, 0x3a, 0x50, 0x3e, 0x0d, 0x02, 0xa2, 0x0e, 0x08, 0xf3, 0xc2, 0x87, 0xb0, 0x30, 0xd6,
	0xb0, 0xb1, 0x12, 0xe4, 0x8f, 0x8e, 0xcf, 0x76, 0x39, 0x3f, 0xe6, 0xe5, 0x19, 0x76, 0x0d, 0x16,
	0x0e, 0xb7, 0x3e, 0x38, 0x3b, 0xd8, 0x3f, 0xdd, 0x3d, 0x6b, 0xf2, 0xad, 0x7b, 0xbb, 0x8d, 0xb2,
	0x81, 0x48, 0x5a, 0x9f, 0x35, 0x8f, 0x8f, 0xcf, 0x0e, 0xb6, 0xf8, 0xde, 0x6e, 0x79, 0x96, 0x2d,
	0xc2, 0xdc, 0x7b, 0x47, 0xef, 0x1c, 0x1d, 0xbf, 0x7f, 0xa4, 0x3e, 0x4e, 0xd5, 0x7f, 0x65, 0x40,
	0x16, 0xd9, 0x0b, 0x8f, 0xfd, 0x10, 0x0a, 0x61, 0xdb, 0xc7, 0x6e, 0x24, 0xba, 0xc5, 0x78, 0x2b,
	0x58, 0x7d, 0x2a, 0xb1, 0xa5, 0xad, 0x6c, 0xce, 0xb0, 0x2d, 0x28, 0x86, 0xc4, 0xa7, 0xf5, 0xff,
	0x86, 0x45, 0xfd, 0x9f, 0x06, 0x94, 0x95, 0x81, 0xf7, 0x84, 0x23, 0x3c, 0x2b, 0x70, 0x43, 0xc1,
	0xa8, 0x67, 0x1b, 0xe3, 0x1a, 0x6f, 0x00, 0x2f, 0x17, 0x6c, 0x1f, 0x60, 0x4f, 0x04, 0xba, 0x5e,
	0x2e, 0x4f, 0x4f, 0x10, 0x92, 0xc7, 0x33, 0x97, 0x64, 0x0f, 0xcd, 0x6a, 0x0f, 0x20, 0xf2, 0x70,
	0x16, 0xe5, 0xbb, 0x89, 0xa8, 0xad, 0x2e, 0x4f, 0xdd, 0x0b, 0x6f, 0xfa, 0xfb, 0x34, 0xe4, 0x70,
	0xc3, 0x16, 0x1e, 0x7b, 0x0b, 0xe6, 0x7e, 0x64, 0x3b, 0x9d, 0xf0, 0xe7, 0x2e, 0x36, 0xe5, 0xf7,
	0x31, 0xcd, 0xb6, 0x3a, 0x6d, 0x2b, 0x66, 0x82, 0x92, 0x7e, 0x40, 0x6f, 0x0b, 0x27, 0x60, 0x97,
	0xfc, 0x6a, 0x53, 0x7d, 0x7a, 0x02, 0x1f, 0xb2, 0xd8, 0x85, 0x62, 0xec, 0x17, 0xa1, 0xb8, 0xb6,
	0x26, 0x7e, 0x27, 0xba, 0x8a, 0xcd, 0x1e, 0x40, 0x34, 0x45, 0xb2, 0x2b, 0xde, 0x93, 0xaa, 0xcb,
	0x53, 0xf7, 0x42, 0x46, 0xef, 0xe8, 0x2b, 0xc9, 0x71, 0xf4, 0x4a, 0x56, 0xcf, 0x4e, 0x1d, 0x6f,
	0x63, 0xcc, 0x4e, 0x61, 0x61, 0x6c, 0x7a, 0x63, 0x8f, 0x7a, 0x14, 0xa9, 0xae, 0x5d, 0x4e, 0x10,
	0xf2, 0xfd, 0x71, 0x6c, 0x66, 0xd6, 0x53, 0xe1, 0xa3, 0x39, 0x9b, 0x97, 0x11, 0xc4, 0x65, 0xae,
	0xff, 0x2b, 0x05, 0xe5, 0x46, 0xe0, 0x09, 0xab, 0x6f, 0x3b, 0x5d, 0xed, 0x32, 0x6f, 0x40, 0x56,
	0x3d, 0xa5, 0x3c, 0xae, 0x89, 0x37, 0x0d, 0x8c, 0x87, 0x27, 0x62, 0x9b, 0x4d, 0x83, 0x1d, 0x3e,
	0x41, 0xeb, 0x6c, 0x1a, 0xec, 0x83, 0xaf, 0xc7, 0x3e, 0x9b, 0x06, 0xfb, 0xf0, 0xeb, 0xb3, 0xd0,
	0xa6, 0xc1, 0x4e, 0x60, 0x51, 0xe5, 0x8a, 0x27, 0x92, 0x1d, 0x36, 0x8d, 0xfa, 0x1f, 0x0d, 0xc8,
	0xe9, 0x8c, 0x75, 0x36, 0xb5, 0xb3, 0x36, 0xaf, 0xea, 0x37, 0xd5, 0x31, 0xcf, 0x5d, 0x49, 0xf3,
	0xc4, 0xb3, 0xda, 0x76, 0xe5, 0x93, 0x2f, 0x57, 0x8c, 0xcf, 0xbe, 0x5c, 0x31, 0xfe, 0xf1, 0xe5,
	0x8a, 0xf1, 0xeb, 0xaf, 0x56, 0x66, 0x3e, 0xfb, 0x6a, 0x65, 0xe6, 0xf3, 0xaf, 0x56, 0x66, 0x5a,
	0x59, 0xfa, 0x77, 0x86, 0x57, 0xfe, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x39, 0xe8, 0x42, 0x13, 0x4f,
	0x21, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PusherClient is the client API for Pusher service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PusherClient interface {
	// different versions of PushBytes expect the trace data to be pushed in
	// different formats
	PushBytes(ctx context.Context, in *PushBytesRequest, opts ...grpc.CallOption) (*PushResponse, error)
	PushBytesV2(ctx context.Context, in *PushBytesRequest, opts ...grpc.CallOption) (*PushResponse, error)
}

type pusherClient struct {
	cc *grpc.ClientConn
}

func NewPusherClient(cc *grpc.ClientConn) PusherClient {
	return &pusherClient{cc}
}

func (c *pusherClient) PushBytes(ctx context.Context, in *PushBytesRequest, opts ...grpc.CallOption) (*PushResponse, error) {
	out := new(PushResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Pusher/PushBytes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pusherClient) PushBytesV2(ctx context.Context, in *PushBytesRequest, opts ...grpc.CallOption) (*PushResponse, error) {
	out := new(PushResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Pusher/PushBytesV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PusherServer is the server API for Pusher service.
type PusherServer interface {
	// different versions of PushBytes expect the trace data to be pushed in
	// different formats
	PushBytes(context.Context, *PushBytesRequest) (*PushResponse, error)
	PushBytesV2(context.Context, *PushBytesRequest) (*PushResponse, error)
}

// UnimplementedPusherServer can be embedded to have forward compatible implementations.
type UnimplementedPusherServer struct {
}

func (*UnimplementedPusherServer) PushBytes(ctx context.Context, req *PushBytesRequest) (*PushResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushBytes not implemented")
}
func (*UnimplementedPusherServer) PushBytesV2(ctx context.Context, req *PushBytesRequest) (*PushResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushBytesV2 not implemented")
}

func RegisterPusherServer(s *grpc.Server, srv PusherServer) {
	s.RegisterService(&_Pusher_serviceDesc, srv)
}

func _Pusher_PushBytes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushBytesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PusherServer).PushBytes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Pusher/PushBytes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PusherServer).PushBytes(ctx, req.(*PushBytesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pusher_PushBytesV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushBytesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PusherServer).PushBytesV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Pusher/PushBytesV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PusherServer).PushBytesV2(ctx, req.(*PushBytesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Pusher_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tempopb.Pusher",
	HandlerType: (*PusherServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PushBytes",
			Handler:    _Pusher_PushBytes_Handler,
		},
		{
			MethodName: "PushBytesV2",
			Handler:    _Pusher_PushBytesV2_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/tempopb/tempo.proto",
}

// MetricsGeneratorClient is the client API for MetricsGenerator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MetricsGeneratorClient interface {
	PushSpans(ctx context.Context, in *PushSpansRequest, opts ...grpc.CallOption) (*PushResponse, error)
	GetMetrics(ctx context.Context, in *SpanMetricsRequest, opts ...grpc.CallOption) (*SpanMetricsResponse, error)
	QueryRange(ctx context.Context, in *QueryRangeRequest, opts ...grpc.CallOption) (*QueryRangeResponse, error)
}

type metricsGeneratorClient struct {
	cc *grpc.ClientConn
}

func NewMetricsGeneratorClient(cc *grpc.ClientConn) MetricsGeneratorClient {
	return &metricsGeneratorClient{cc}
}

func (c *metricsGeneratorClient) PushSpans(ctx context.Context, in *PushSpansRequest, opts ...grpc.CallOption) (*PushResponse, error) {
	out := new(PushResponse)
	err := c.cc.Invoke(ctx, "/tempopb.MetricsGenerator/PushSpans", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metricsGeneratorClient) GetMetrics(ctx context.Context, in *SpanMetricsRequest, opts ...grpc.CallOption) (*SpanMetricsResponse, error) {
	out := new(SpanMetricsResponse)
	err := c.cc.Invoke(ctx, "/tempopb.MetricsGenerator/GetMetrics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metricsGeneratorClient) QueryRange(ctx context.Context, in *QueryRangeRequest, opts ...grpc.CallOption) (*QueryRangeResponse, error) {
	out := new(QueryRangeResponse)
	err := c.cc.Invoke(ctx, "/tempopb.MetricsGenerator/QueryRange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MetricsGeneratorServer is the server API for MetricsGenerator service.
type MetricsGeneratorServer interface {
	PushSpans(context.Context, *PushSpansRequest) (*PushResponse, error)
	GetMetrics(context.Context, *SpanMetricsRequest) (*SpanMetricsResponse, error)
	QueryRange(context.Context, *QueryRangeRequest) (*QueryRangeResponse, error)
}

// UnimplementedMetricsGeneratorServer can be embedded to have forward compatible implementations.
type UnimplementedMetricsGeneratorServer struct {
}

func (*UnimplementedMetricsGeneratorServer) PushSpans(ctx context.Context, req *PushSpansRequest) (*PushResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushSpans not implemented")
}
func (*UnimplementedMetricsGeneratorServer) GetMetrics(ctx context.Context, req *SpanMetricsRequest) (*SpanMetricsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMetrics not implemented")
}
func (*UnimplementedMetricsGeneratorServer) QueryRange(ctx context.Context, req *QueryRangeRequest) (*QueryRangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRange not implemented")
}

func RegisterMetricsGeneratorServer(s *grpc.Server, srv MetricsGeneratorServer) {
	s.RegisterService(&_MetricsGenerator_serviceDesc, srv)
}

func _MetricsGenerator_PushSpans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushSpansRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricsGeneratorServer).PushSpans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.MetricsGenerator/PushSpans",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricsGeneratorServer).PushSpans(ctx, req.(*PushSpansRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetricsGenerator_GetMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpanMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricsGeneratorServer).GetMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.MetricsGenerator/GetMetrics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricsGeneratorServer).GetMetrics(ctx, req.(*SpanMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetricsGenerator_QueryRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricsGeneratorServer).QueryRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.MetricsGenerator/QueryRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricsGeneratorServer).QueryRange(ctx, req.(*QueryRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MetricsGenerator_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tempopb.MetricsGenerator",
	HandlerType: (*MetricsGeneratorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PushSpans",
			Handler:    _MetricsGenerator_PushSpans_Handler,
		},
		{
			MethodName: "GetMetrics",
			Handler:    _MetricsGenerator_GetMetrics_Handler,
		},
		{
			MethodName: "QueryRange",
			Handler:    _MetricsGenerator_QueryRange_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/tempopb/tempo.proto",
}

// QuerierClient is the client API for Querier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QuerierClient interface {
	FindTraceByID(ctx context.Context, in *TraceByIDRequest, opts ...grpc.CallOption) (*TraceByIDResponse, error)
	SearchRecent(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	SearchBlock(ctx context.Context, in *SearchBlockRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	SearchTags(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (*SearchTagsResponse, error)
	SearchTagsV2(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (*SearchTagsV2Response, error)
	SearchTagValues(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (*SearchTagValuesResponse, error)
	SearchTagValuesV2(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (*SearchTagValuesV2Response, error)
}

type querierClient struct {
	cc *grpc.ClientConn
}

func NewQuerierClient(cc *grpc.ClientConn) QuerierClient {
	return &querierClient{cc}
}

func (c *querierClient) FindTraceByID(ctx context.Context, in *TraceByIDRequest, opts ...grpc.CallOption) (*TraceByIDResponse, error) {
	out := new(TraceByIDResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/FindTraceByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchRecent(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	out := new(SearchResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchRecent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchBlock(ctx context.Context, in *SearchBlockRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	out := new(SearchResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchTags(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (*SearchTagsResponse, error) {
	out := new(SearchTagsResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchTagsV2(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (*SearchTagsV2Response, error) {
	out := new(SearchTagsV2Response)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchTagsV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchTagValues(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (*SearchTagValuesResponse, error) {
	out := new(SearchTagValuesResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchTagValues", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchTagValuesV2(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (*SearchTagValuesV2Response, error) {
	out := new(SearchTagValuesV2Response)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchTagValuesV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QuerierServer is the server API for Querier service.
type QuerierServer interface {
	FindTraceByID(context.Context, *TraceByIDRequest) (*TraceByIDResponse, error)
	SearchRecent(context.Context, *SearchRequest) (*SearchResponse, error)
	SearchBlock(context.Context, *SearchBlockRequest) (*SearchResponse, error)
	SearchTags(context.Context, *SearchTagsRequest) (*SearchTagsResponse, error)
	SearchTagsV2(context.Context, *SearchTagsRequest) (*SearchTagsV2Response, error)
	SearchTagValues(context.Context, *SearchTagValuesRequest) (*SearchTagValuesResponse, error)
	SearchTagValuesV2(context.Context, *SearchTagValuesRequest) (*SearchTagValuesV2Response, error)
}

// UnimplementedQuerierServer can be embedded to have forward compatible implementations.
type UnimplementedQuerierServer struct {
}

func (*UnimplementedQuerierServer) FindTraceByID(ctx context.Context, req *TraceByIDRequest) (*TraceByIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindTraceByID not implemented")
}
func (*UnimplementedQuerierServer) SearchRecent(ctx context.Context, req *SearchRequest) (*SearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchRecent not implemented")
}
func (*UnimplementedQuerierServer) SearchBlock(ctx context.Context, req *SearchBlockRequest) (*SearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchBlock not implemented")
}
func (*UnimplementedQuerierServer) SearchTags(ctx context.Context, req *SearchTagsRequest) (*SearchTagsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchTags not implemented")
}
func (*UnimplementedQuerierServer) SearchTagsV2(ctx context.Context, req *SearchTagsRequest) (*SearchTagsV2Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchTagsV2 not implemented")
}
func (*UnimplementedQuerierServer) SearchTagValues(ctx context.Context, req *SearchTagValuesRequest) (*SearchTagValuesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchTagValues not implemented")
}
func (*UnimplementedQuerierServer) SearchTagValuesV2(ctx context.Context, req *SearchTagValuesRequest) (*SearchTagValuesV2Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchTagValuesV2 not implemented")
}

func RegisterQuerierServer(s *grpc.Server, srv QuerierServer) {
	s.RegisterService(&_Querier_serviceDesc, srv)
}

func _Querier_FindTraceByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TraceByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).FindTraceByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/FindTraceByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).FindTraceByID(ctx, req.(*TraceByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchRecent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchRecent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchRecent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchRecent(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchBlock(ctx, req.(*SearchBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchTags(ctx, req.(*SearchTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchTagsV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchTagsV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchTagsV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchTagsV2(ctx, req.(*SearchTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchTagValues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchTagValuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchTagValues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchTagValues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchTagValues(ctx, req.(*SearchTagValuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchTagValuesV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchTagValuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchTagValuesV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchTagValuesV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchTagValuesV2(ctx, req.(*SearchTagValuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Querier_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tempopb.Querier",
	HandlerType: (*QuerierServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FindTraceByID",
			Handler:    _Querier_FindTraceByID_Handler,
		},
		{
			MethodName: "SearchRecent",
			Handler:    _Querier_SearchRecent_Handler,
		},
		{
			MethodName: "SearchBlock",
			Handler:    _Querier_SearchBlock_Handler,
		},
		{
			MethodName: "SearchTags",
			Handler:    _Querier_SearchTags_Handler,
		},
		{
			MethodName: "SearchTagsV2",
			Handler:    _Querier_SearchTagsV2_Handler,
		},
		{
			MethodName: "SearchTagValues",
			Handler:    _Querier_SearchTagValues_Handler,
		},
		{
			MethodName: "SearchTagValuesV2",
			Handler:    _Querier_SearchTagValuesV2_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/tempopb/tempo.proto",
}

// StreamingQuerierClient is the client API for StreamingQuerier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StreamingQuerierClient interface {
	Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchClient, error)
	SearchTags(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagsClient, error)
	SearchTagsV2(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagsV2Client, error)
	SearchTagValues(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagValuesClient, error)
	SearchTagValuesV2(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagValuesV2Client, error)
	MetricsQueryRange(ctx context.Context, in *QueryRangeRequest, opts ...grpc.CallOption) (StreamingQuerier_MetricsQueryRangeClient, error)
}

type streamingQuerierClient struct {
	cc *grpc.ClientConn
}

func NewStreamingQuerierClient(cc *grpc.ClientConn) StreamingQuerierClient {
	return &streamingQuerierClient{cc}
}

func (c *streamingQuerierClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamingQuerier_serviceDesc.Streams[0], "/tempopb.StreamingQuerier/Search", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingQuerierSearchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingQuerier_SearchClient interface {
	Recv() (*SearchResponse, error)
	grpc.ClientStream
}

type streamingQuerierSearchClient struct {
	grpc.ClientStream
}

func (x *streamingQuerierSearchClient) Recv() (*SearchResponse, error) {
	m := new(SearchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamingQuerierClient) SearchTags(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamingQuerier_serviceDesc.Streams[1], "/tempopb.StreamingQuerier/SearchTags", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingQuerierSearchTagsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingQuerier_SearchTagsClient interface {
	Recv() (*SearchTagsResponse, error)
	grpc.ClientStream
}

type streamingQuerierSearchTagsClient struct {
	grpc.ClientStream
}

func (x *streamingQuerierSearchTagsClient) Recv() (*SearchTagsResponse, error) {
	m := new(SearchTagsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamingQuerierClient) SearchTagsV2(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagsV2Client, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamingQuerier_serviceDesc.Streams[2], "/tempopb.StreamingQuerier/SearchTagsV2", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingQuerierSearchTagsV2Client{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingQuerier_SearchTagsV2Client interface {
	Recv() (*SearchTagsV2Response, error)
	grpc.ClientStream
}

type streamingQuerierSearchTagsV2Client struct {
	grpc.ClientStream
}

func (x *streamingQuerierSearchTagsV2Client) Recv() (*SearchTagsV2Response, error) {
	m := new(SearchTagsV2Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamingQuerierClient) SearchTagValues(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagValuesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamingQuerier_serviceDesc.Streams[3], "/tempopb.StreamingQuerier/SearchTagValues", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingQuerierSearchTagValuesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingQuerier_SearchTagValuesClient interface {
	Recv() (*SearchTagValuesResponse, error)
	grpc.ClientStream
}

type streamingQuerierSearchTagValuesClient struct {
	grpc.ClientStream
}

func (x *streamingQuerierSearchTagValuesClient) Recv() (*SearchTagValuesResponse, error) {
	m := new(SearchTagValuesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamingQuerierClient) SearchTagValuesV2(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagValuesV2Client, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamingQuerier_serviceDesc.Streams[4], "/tempopb.StreamingQuerier/SearchTagValuesV2", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingQuerierSearchTagValuesV2Client{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingQuerier_SearchTagValuesV2Client interface {
	Recv() (*SearchTagValuesV2Response, error)
	grpc.ClientStream
}

type streamingQuerierSearchTagValuesV2Client struct {
	grpc.ClientStream
}

func (x *streamingQuerierSearchTagValuesV2Client) Recv() (*SearchTagValuesV2Response, error) {
	m := new(SearchTagValuesV2Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamingQuerierClient) MetricsQueryRange(ctx context.Context, in *QueryRangeRequest, opts ...grpc.CallOption) (StreamingQuerier_MetricsQueryRangeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamingQuerier_serviceDesc.Streams[5], "/tempopb.StreamingQuerier/MetricsQueryRange", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingQuerierMetricsQueryRangeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingQuerier_MetricsQueryRangeClient interface {
	Recv() (*QueryRangeResponse, error)
	grpc.ClientStream
}

type streamingQuerierMetricsQueryRangeClient struct {
	grpc.ClientStream
}

func (x *streamingQuerierMetricsQueryRangeClient) Recv() (*QueryRangeResponse, error) {
	m := new(QueryRangeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StreamingQuerierServer is the server API for StreamingQuerier service.
type StreamingQuerierServer interface {
	Search(*SearchRequest, StreamingQuerier_SearchServer) error
	SearchTags(*SearchTagsRequest, StreamingQuerier_SearchTagsServer) error
	SearchTagsV2(*SearchTagsRequest, StreamingQuerier_SearchTagsV2Server) error
	SearchTagValues(*SearchTagValuesRequest, StreamingQuerier_SearchTagValuesServer) error
	SearchTagValuesV2(*SearchTagValuesRequest, StreamingQuerier_SearchTagValuesV2Server) error
	MetricsQueryRange(*QueryRangeRequest, StreamingQuerier_MetricsQueryRangeServer) error
}

// UnimplementedStreamingQuerierServer can be embedded to have forward compatible implementations.
type UnimplementedStreamingQuerierServer struct {
}

func (*UnimplementedStreamingQuerierServer) Search(req *SearchRequest, srv StreamingQuerier_SearchServer) error {
	return status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (*UnimplementedStreamingQuerierServer) SearchTags(req *SearchTagsRequest, srv StreamingQuerier_SearchTagsServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchTags not implemented")
}
func (*UnimplementedStreamingQuerierServer) SearchTagsV2(req *SearchTagsRequest, srv StreamingQuerier_SearchTagsV2Server) error {
	return status.Errorf(codes.Unimplemented, "method SearchTagsV2 not implemented")
}
func (*UnimplementedStreamingQuerierServer) SearchTagValues(req *SearchTagValuesRequest, srv StreamingQuerier_SearchTagValuesServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchTagValues not implemented")
}
func (*UnimplementedStreamingQuerierServer) SearchTagValuesV2(req *SearchTagValuesRequest, srv StreamingQuerier_SearchTagValuesV2Server) error {
	return status.Errorf(codes.Unimplemented, "method SearchTagValuesV2 not implemented")
}
func (*UnimplementedStreamingQuerierServer) MetricsQueryRange(req *QueryRangeRequest, srv StreamingQuerier_MetricsQueryRangeServer) error {
	return status.Errorf(codes.Unimplemented, "method MetricsQueryRange not implemented")
}

func RegisterStreamingQuerierServer(s *grpc.Server, srv StreamingQuerierServer) {
	s.RegisterService(&_StreamingQuerier_serviceDesc, srv)
}

func _StreamingQuerier_Search_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingQuerierServer).Search(m, &streamingQuerierSearchServer{stream})
}

type StreamingQuerier_SearchServer interface {
	Send(*SearchResponse) error
	grpc.ServerStream
}

type streamingQuerierSearchServer struct {
	grpc.ServerStream
}

func (x *streamingQuerierSearchServer) Send(m *SearchResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _StreamingQuerier_SearchTags_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchTagsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingQuerierServer).SearchTags(m, &streamingQuerierSearchTagsServer{stream})
}

type StreamingQuerier_SearchTagsServer interface {
	Send(*SearchTagsResponse) error
	grpc.ServerStream
}

type streamingQuerierSearchTagsServer struct {
	grpc.ServerStream
}

func (x *streamingQuerierSearchTagsServer) Send(m *SearchTagsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _StreamingQuerier_SearchTagsV2_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchTagsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingQuerierServer).SearchTagsV2(m, &streamingQuerierSearchTagsV2Server{stream})
}

type StreamingQuerier_SearchTagsV2Server interface {
	Send(*SearchTagsV2Response) error
	grpc.ServerStream
}

type streamingQuerierSearchTagsV2Server struct {
	grpc.ServerStream
}

func (x *streamingQuerierSearchTagsV2Server) Send(m *SearchTagsV2Response) error {
	return x.ServerStream.SendMsg(m)
}

func _StreamingQuerier_SearchTagValues_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchTagValuesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingQuerierServer).SearchTagValues(m, &streamingQuerierSearchTagValuesServer{stream})
}

type StreamingQuerier_SearchTagValuesServer interface {
	Send(*SearchTagValuesResponse) error
	grpc.ServerStream
}

type streamingQuerierSearchTagValuesServer struct {
	grpc.ServerStream
}

func (x *streamingQuerierSearchTagValuesServer) Send(m *SearchTagValuesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _StreamingQuerier_SearchTagValuesV2_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchTagValuesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingQuerierServer).SearchTagValuesV2(m, &streamingQuerierSearchTagValuesV2Server{stream})
}

type StreamingQuerier_SearchTagValuesV2Server interface {
	Send(*SearchTagValuesV2Response) error
	grpc.ServerStream
}

type streamingQuerierSearchTagValuesV2Server struct {
	grpc.ServerStream
}

func (x *streamingQuerierSearchTagValuesV2Server) Send(m *SearchTagValuesV2Response) error {
	return x.ServerStream.SendMsg(m)
}

func _StreamingQuerier_MetricsQueryRange_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(QueryRangeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingQuerierServer).MetricsQueryRange(m, &streamingQuerierMetricsQueryRangeServer{stream})
}

type StreamingQuerier_MetricsQueryRangeServer interface {
	Send(*QueryRangeResponse) error
	grpc.ServerStream
}

type streamingQuerierMetricsQueryRangeServer struct {
	grpc.ServerStream
}

func (x *streamingQuerierMetricsQueryRangeServer) Send(m *QueryRangeResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _StreamingQuerier_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tempopb.StreamingQuerier",
	HandlerType: (*StreamingQuerierServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Search",
			Handler:       _StreamingQuerier_Search_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchTags",
			Handler:       _StreamingQuerier_SearchTags_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchTagsV2",
			Handler:       _StreamingQuerier_SearchTagsV2_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchTagValues",
			Handler:       _StreamingQuerier_SearchTagValues_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchTagValuesV2",
			Handler:       _StreamingQuerier_SearchTagValuesV2_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MetricsQueryRange",
			Handler:       _StreamingQuerier_MetricsQueryRange_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/tempopb/tempo.proto",
}

// MetricsClient is the client API for Metrics service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MetricsClient interface {
	SpanMetricsSummary(ctx context.Context, in *SpanMetricsSummaryRequest, opts ...grpc.CallOption) (*SpanMetricsSummaryResponse, error)
	QueryRange(ctx context.Context, in *QueryRangeRequest, opts ...grpc.CallOption) (*QueryRangeResponse, error)
}

type metricsClient struct {
	cc *grpc.ClientConn
}

func NewMetricsClient(cc *grpc.ClientConn) MetricsClient {
	return &metricsClient{cc}
}

func (c *metricsClient) SpanMetricsSummary(ctx context.Context, in *SpanMetricsSummaryRequest, opts ...grpc.CallOption) (*SpanMetricsSummaryResponse, error) {
	out := new(SpanMetricsSummaryResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Metrics/SpanMetricsSummary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metricsClient) QueryRange(ctx context.Context, in *QueryRangeRequest, opts ...grpc.CallOption) (*QueryRangeResponse, error) {
	out := new(QueryRangeResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Metrics/QueryRange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MetricsServer is the server API for Metrics service.
type MetricsServer interface {
	SpanMetricsSummary(context.Context, *SpanMetricsSummaryRequest) (*SpanMetricsSummaryResponse, error)
	QueryRange(context.Context, *QueryRangeRequest) (*QueryRangeResponse, error)
}

// UnimplementedMetricsServer can be embedded to have forward compatible implementations.
type UnimplementedMetricsServer struct {
}

func (*UnimplementedMetricsServer) SpanMetricsSummary(ctx context.Context, req *SpanMetricsSummaryRequest) (*SpanMetricsSummaryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SpanMetricsSummary not implemented")
}
func (*UnimplementedMetricsServer) QueryRange(ctx context.Context, req *QueryRangeRequest) (*QueryRangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRange not implemented")
}

func RegisterMetricsServer(s *grpc.Server, srv MetricsServer) {
	s.RegisterService(&_Metrics_serviceDesc, srv)
}

func _Metrics_SpanMetricsSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpanMetricsSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricsServer).SpanMetricsSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Metrics/SpanMetricsSummary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricsServer).SpanMetricsSummary(ctx, req.(*SpanMetricsSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metrics_QueryRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricsServer).QueryRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Metrics/QueryRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricsServer).QueryRange(ctx, req.(*QueryRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Metrics_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tempopb.Metrics",
	HandlerType: (*MetricsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SpanMetricsSummary",
			Handler:    _Metrics_SpanMetricsSummary_Handler,
		},
		{
			MethodName: "QueryRange",
			Handler:    _Metrics_QueryRange_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/tempopb/tempo.proto",
}

func (m *TraceByIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceByIDRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceByIDRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.QueryMode) > 0 {
		i -= len(m.QueryMode)
		copy(dAtA[i:], m.QueryMode)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.QueryMode)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BlockEnd) > 0 {
		i -= len(m.BlockEnd)
		copy(dAtA[i:], m.BlockEnd)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.BlockEnd)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BlockStart) > 0 {
		i -= len(m.BlockStart)
		copy(dAtA[i:], m.BlockStart)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.BlockStart)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TraceID) > 0 {
		i -= len(m.TraceID)
		copy(dAtA[i:], m.TraceID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.TraceID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TraceByIDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceByIDResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceByIDResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Trace != nil {
		{
			size, err := m.Trace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TraceByIDMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceByIDMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceByIDMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SearchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SpansPerSpanSet != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.SpansPerSpanSet))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x42
	}
	if m.End != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x30
	}
	if m.Start != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x28
	}
	if m.Limit != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxDurationMs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.MaxDurationMs))
		i--
		dAtA[i] = 0x18
	}
	if m.MinDurationMs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.MinDurationMs))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTempo(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTempo(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTempo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SearchBlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchBlockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchBlockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DedicatedColumns) > 0 {
		for iNdEx := len(m.DedicatedColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DedicatedColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.FooterSize != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.FooterSize))
		i--
		dAtA[i] = 0x58
	}
	if m.Size_ != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.DataEncoding) > 0 {
		i -= len(m.DataEncoding)
		copy(dAtA[i:], m.DataEncoding)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.DataEncoding)))
		i--
		dAtA[i] = 0x42
	}
	if m.TotalRecords != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalRecords))
		i--
		dAtA[i] = 0x38
	}
	if m.IndexPageSize != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.IndexPageSize))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Encoding) > 0 {
		i -= len(m.Encoding)
		copy(dAtA[i:], m.Encoding)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Encoding)))
		i--
		dAtA[i] = 0x2a
	}
	if m.PagesToSearch != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.PagesToSearch))
		i--
		dAtA[i] = 0x20
	}
	if m.StartPage != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StartPage))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BlockID) > 0 {
		i -= len(m.BlockID)
		copy(dAtA[i:], m.BlockID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.BlockID)))
		i--
		dAtA[i] = 0x12
	}
	if m.SearchReq != nil {
		{
			size, err := m.SearchReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DedicatedColumn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DedicatedColumn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DedicatedColumn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Scope != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Scope))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SearchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Traces) > 0 {
		for iNdEx := len(m.Traces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Traces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TraceSearchMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceSearchMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceSearchMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ServiceStats) > 0 {
		for k := range m.ServiceStats {
			v := m.ServiceStats[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTempo(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTempo(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTempo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.SpanSets) > 0 {
		for iNdEx := len(m.SpanSets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpanSets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.SpanSet != nil {
		{
			size, err := m.SpanSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.DurationMs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.DurationMs))
		i--
		dAtA[i] = 0x28
	}
	if m.StartTimeUnixNano != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StartTimeUnixNano))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RootTraceName) > 0 {
		i -= len(m.RootTraceName)
		copy(dAtA[i:], m.RootTraceName)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.RootTraceName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RootServiceName) > 0 {
		i -= len(m.RootServiceName)
		copy(dAtA[i:], m.RootServiceName)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.RootServiceName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TraceID) > 0 {
		i -= len(m.TraceID)
		copy(dAtA[i:], m.TraceID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.TraceID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ErrorCount != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.ErrorCount))
		i--
		dAtA[i] = 0x10
	}
	if m.SpanCount != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.SpanCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpanSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Matched != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Matched))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Span) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Span) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Span) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.DurationNanos != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.DurationNanos))
		i--
		dAtA[i] = 0x20
	}
	if m.StartTimeUnixNano != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StartTimeUnixNano))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpanID) > 0 {
		i -= len(m.SpanID)
		copy(dAtA[i:], m.SpanID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.SpanID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InspectedSpans != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.InspectedSpans))
		i--
		dAtA[i] = 0x38
	}
	if m.TotalBlockBytes != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalBlockBytes))
		i--
		dAtA[i] = 0x30
	}
	if m.TotalJobs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalJobs))
		i--
		dAtA[i] = 0x28
	}
	if m.CompletedJobs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.CompletedJobs))
		i--
		dAtA[i] = 0x20
	}
	if m.TotalBlocks != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalBlocks))
		i--
		dAtA[i] = 0x18
	}
	if m.InspectedBytes != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.InspectedBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.InspectedTraces != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.InspectedTraces))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x20
	}
	if m.Start != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Scope) > 0 {
		i -= len(m.Scope)
		copy(dAtA[i:], m.Scope)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Scope)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagsBlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagsBlockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagsBlockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DedicatedColumns) > 0 {
		for iNdEx := len(m.DedicatedColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DedicatedColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.FooterSize != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.FooterSize))
		i--
		dAtA[i] = 0x58
	}
	if m.Size_ != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.DataEncoding) > 0 {
		i -= len(m.DataEncoding)
		copy(dAtA[i:], m.DataEncoding)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.DataEncoding)))
		i--
		dAtA[i] = 0x42
	}
	if m.TotalRecords != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalRecords))
		i--
		dAtA[i] = 0x38
	}
	if m.IndexPageSize != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.IndexPageSize))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Encoding) > 0 {
		i -= len(m.Encoding)
		copy(dAtA[i:], m.Encoding)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Encoding)))
		i--
		dAtA[i] = 0x2a
	}
	if m.PagesToSearch != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.PagesToSearch))
		i--
		dAtA[i] = 0x20
	}
	if m.StartPage != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StartPage))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BlockID) > 0 {
		i -= len(m.BlockID)
		copy(dAtA[i:], m.BlockID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.BlockID)))
		i--
		dAtA[i] = 0x12
	}
	if m.SearchReq != nil {
		{
			size, err := m.SearchReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagValuesBlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagValuesBlockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagValuesBlockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DedicatedColumns) > 0 {
		for iNdEx := len(m.DedicatedColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DedicatedColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.FooterSize != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.FooterSize))
		i--
		dAtA[i] = 0x58
	}
	if m.Size_ != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.DataEncoding) > 0 {
		i -= len(m.DataEncoding)
		copy(dAtA[i:], m.DataEncoding)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.DataEncoding)))
		i--
		dAtA[i] = 0x42
	}
	if m.TotalRecords != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalRecords))
		i--
		dAtA[i] = 0x38
	}
	if m.IndexPageSize != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.IndexPageSize))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Encoding) > 0 {
		i -= len(m.Encoding)
		copy(dAtA[i:], m.Encoding)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Encoding)))
		i--
		dAtA[i] = 0x2a
	}
	if m.PagesToSearch != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.PagesToSearch))
		i--
		dAtA[i] = 0x20
	}
	if m.StartPage != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StartPage))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BlockID) > 0 {
		i -= len(m.BlockID)
		copy(dAtA[i:], m.BlockID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.BlockID)))
		i--
		dAtA[i] = 0x12
	}
	if m.SearchReq != nil {
		{
			size, err := m.SearchReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TagNames) > 0 {
		for iNdEx := len(m.TagNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TagNames[iNdEx])
			copy(dAtA[i:], m.TagNames[iNdEx])
			i = encodeVarintTempo(dAtA, i, uint64(len(m.TagNames[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagsV2Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagsV2Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagsV2Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Scopes) > 0 {
		for iNdEx := len(m.Scopes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Scopes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagsV2Scope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagsV2Scope) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagsV2Scope) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintTempo(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagValuesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagValuesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagValuesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x28
	}
	if m.Start != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TagName) > 0 {
		i -= len(m.TagName)
		copy(dAtA[i:], m.TagName)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.TagName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagValuesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagValuesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagValuesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TagValues) > 0 {
		for iNdEx := len(m.TagValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TagValues[iNdEx])
			copy(dAtA[i:], m.TagValues[iNdEx])
			i = encodeVarintTempo(dAtA, i, uint64(len(m.TagValues[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TagValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagValuesV2Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagValuesV2Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagValuesV2Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TagValues) > 0 {
		for iNdEx := len(m.TagValues) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TagValues[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Trace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Trace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Batches) > 0 {
		for iNdEx := len(m.Batches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Batches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PushResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorsByTrace) > 0 {
		dAtA10 := make([]byte, len(m.ErrorsByTrace)*10)
		var j9 int
		for _, num := range m.ErrorsByTrace {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintTempo(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PushBytesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushBytesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushBytesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SearchData) > 0 {
		for iNdEx := len(m.SearchData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.SearchData[iNdEx].Size()
				i -= size
				if _, err := m.SearchData[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Ids) > 0 {
		for iNdEx := len(m.Ids) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.Ids[iNdEx].Size()
				i -= size
				if _, err := m.Ids[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Traces) > 0 {
		for iNdEx := len(m.Traces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.Traces[iNdEx].Size()
				i -= size
				if _, err := m.Traces[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *PushSpansRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushSpansRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushSpansRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Batches) > 0 {
		for iNdEx := len(m.Batches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Batches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TraceBytes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceBytes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceBytes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Traces) > 0 {
		for iNdEx := len(m.Traces) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Traces[iNdEx])
			copy(dAtA[i:], m.Traces[iNdEx])
			i = encodeVarintTempo(dAtA, i, uint64(len(m.Traces[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LinkSlice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkSlice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LinkSlice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Links) > 0 {
		for iNdEx := len(m.Links) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Links[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x28
	}
	if m.Start != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x20
	}
	if m.Limit != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if len(m.GroupBy) > 0 {
		i -= len(m.GroupBy)
		copy(dAtA[i:], m.GroupBy)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.GroupBy)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsSummaryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsSummaryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsSummaryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x28
	}
	if m.Start != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x20
	}
	if m.Limit != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if len(m.GroupBy) > 0 {
		i -= len(m.GroupBy)
		copy(dAtA[i:], m.GroupBy)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.GroupBy)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metrics) > 0 {
		for iNdEx := len(m.Metrics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metrics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ErrorSpanCount != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.ErrorSpanCount))
		i--
		dAtA[i] = 0x18
	}
	if m.SpanCount != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.SpanCount))
		i--
		dAtA[i] = 0x10
	}
	if m.Estimated {
		i--
		if m.Estimated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RawHistogram) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawHistogram) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawHistogram) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.Bucket != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Bucket))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *KeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Errors != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Errors))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Series) > 0 {
		for iNdEx := len(m.Series) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Series[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.LatencyHistogram) > 0 {
		for iNdEx := len(m.LatencyHistogram) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LatencyHistogram[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.P50 != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.P50))
		i--
		dAtA[i] = 0x38
	}
	if m.P90 != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.P90))
		i--
		dAtA[i] = 0x30
	}
	if m.P95 != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.P95))
		i--
		dAtA[i] = 0x28
	}
	if m.P99 != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.P99))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Series) > 0 {
		for iNdEx := len(m.Series) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Series[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ErrorSpanCount != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.ErrorSpanCount))
		i--
		dAtA[i] = 0x10
	}
	if m.SpanCount != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.SpanCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsSummaryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsSummaryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsSummaryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Summaries) > 0 {
		for iNdEx := len(m.Summaries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Summaries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TraceQLStatic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceQLStatic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceQLStatic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x40
	}
	if m.Status != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if m.D != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.D))
		i--
		dAtA[i] = 0x30
	}
	if m.B {
		i--
		if m.B {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.S) > 0 {
		i -= len(m.S)
		copy(dAtA[i:], m.S)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.S)))
		i--
		dAtA[i] = 0x22
	}
	if m.F != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.F))))
		i--
		dAtA[i] = 0x19
	}
	if m.N != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.N))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ResultType) > 0 {
		i -= len(m.ResultType)
		copy(dAtA[i:], m.ResultType)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.ResultType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ts) > 0 {
		for iNdEx := len(m.Ts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.LabelValue) > 0 {
		i -= len(m.LabelValue)
		copy(dAtA[i:], m.LabelValue)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.LabelValue)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.LabelName) > 0 {
		i -= len(m.LabelName)
		copy(dAtA[i:], m.LabelName)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.LabelName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsResultPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsResultPoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsResultPoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExemplarDuration != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.ExemplarDuration))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ExemplarTraceID) > 0 {
		i -= len(m.ExemplarTraceID)
		copy(dAtA[i:], m.ExemplarTraceID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.ExemplarTraceID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Val != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Val))))
		i--
		dAtA[i] = 0x11
	}
	if m.Time != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.QueryMode) > 0 {
		i -= len(m.QueryMode)
		copy(dAtA[i:], m.QueryMode)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.QueryMode)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ShardCount != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.ShardCount))
		i--
		dAtA[i] = 0x30
	}
	if m.ShardID != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x28
	}
	if m.Step != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Step))
		i--
		dAtA[i] = 0x20
	}
	if m.End != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x18
	}
	if m.Start != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Series) > 0 {
		for iNdEx := len(m.Series) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Series[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Sample) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sample) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sample) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimestampMs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TimestampMs))
		i--
		dAtA[i] = 0x10
	}
	if m.Value != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *TimeSeries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeSeries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimeSeries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PromLabels) > 0 {
		i -= len(m.PromLabels)
		copy(dAtA[i:], m.PromLabels)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.PromLabels)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Samples) > 0 {
		for iNdEx := len(m.Samples) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Samples[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Labels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTempo(dAtA []byte, offset int, v uint64) int {
	offset -= sovTempo(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TraceByIDRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TraceID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.BlockStart)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.BlockEnd)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.QueryMode)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *TraceByIDResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Trace != nil {
		l = m.Trace.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *TraceByIDMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SearchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTempo(uint64(len(k))) + 1 + len(v) + sovTempo(uint64(len(v)))
			n += mapEntrySize + 1 + sovTempo(uint64(mapEntrySize))
		}
	}
	if m.MinDurationMs != 0 {
		n += 1 + sovTempo(uint64(m.MinDurationMs))
	}
	if m.MaxDurationMs != 0 {
		n += 1 + sovTempo(uint64(m.MaxDurationMs))
	}
	if m.Limit != 0 {
		n += 1 + sovTempo(uint64(m.Limit))
	}
	if m.Start != 0 {
		n += 1 + sovTempo(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTempo(uint64(m.End))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.SpansPerSpanSet != 0 {
		n += 1 + sovTempo(uint64(m.SpansPerSpanSet))
	}
	return n
}

func (m *SearchBlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SearchReq != nil {
		l = m.SearchReq.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.BlockID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.StartPage != 0 {
		n += 1 + sovTempo(uint64(m.StartPage))
	}
	if m.PagesToSearch != 0 {
		n += 1 + sovTempo(uint64(m.PagesToSearch))
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.IndexPageSize != 0 {
		n += 1 + sovTempo(uint64(m.IndexPageSize))
	}
	if m.TotalRecords != 0 {
		n += 1 + sovTempo(uint64(m.TotalRecords))
	}
	l = len(m.DataEncoding)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovTempo(uint64(m.Size_))
	}
	if m.FooterSize != 0 {
		n += 1 + sovTempo(uint64(m.FooterSize))
	}
	if len(m.DedicatedColumns) > 0 {
		for _, e := range m.DedicatedColumns {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *DedicatedColumn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTempo(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Scope != 0 {
		n += 1 + sovTempo(uint64(m.Scope))
	}
	return n
}

func (m *SearchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Traces) > 0 {
		for _, e := range m.Traces {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *TraceSearchMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TraceID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.RootServiceName)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.RootTraceName)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.StartTimeUnixNano != 0 {
		n += 1 + sovTempo(uint64(m.StartTimeUnixNano))
	}
	if m.DurationMs != 0 {
		n += 1 + sovTempo(uint64(m.DurationMs))
	}
	if m.SpanSet != nil {
		l = m.SpanSet.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	if len(m.SpanSets) > 0 {
		for _, e := range m.SpanSets {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if len(m.ServiceStats) > 0 {
		for k, v := range m.ServiceStats {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTempo(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTempo(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTempo(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ServiceStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpanCount != 0 {
		n += 1 + sovTempo(uint64(m.SpanCount))
	}
	if m.ErrorCount != 0 {
		n += 1 + sovTempo(uint64(m.ErrorCount))
	}
	return n
}

func (m *SpanSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Matched != 0 {
		n += 1 + sovTempo(uint64(m.Matched))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *Span) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpanID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.StartTimeUnixNano != 0 {
		n += 1 + sovTempo(uint64(m.StartTimeUnixNano))
	}
	if m.DurationNanos != 0 {
		n += 1 + sovTempo(uint64(m.DurationNanos))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SearchMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InspectedTraces != 0 {
		n += 1 + sovTempo(uint64(m.InspectedTraces))
	}
	if m.InspectedBytes != 0 {
		n += 1 + sovTempo(uint64(m.InspectedBytes))
	}
	if m.TotalBlocks != 0 {
		n += 1 + sovTempo(uint64(m.TotalBlocks))
	}
	if m.CompletedJobs != 0 {
		n += 1 + sovTempo(uint64(m.CompletedJobs))
	}
	if m.TotalJobs != 0 {
		n += 1 + sovTempo(uint64(m.TotalJobs))
	}
	if m.TotalBlockBytes != 0 {
		n += 1 + sovTempo(uint64(m.TotalBlockBytes))
	}
	if m.InspectedSpans != 0 {
		n += 1 + sovTempo(uint64(m.InspectedSpans))
	}
	return n
}

func (m *SearchTagsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Scope)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovTempo(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTempo(uint64(m.End))
	}
	return n
}

func (m *SearchTagsBlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SearchReq != nil {
		l = m.SearchReq.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.BlockID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.StartPage != 0 {
		n += 1 + sovTempo(uint64(m.StartPage))
	}
	if m.PagesToSearch != 0 {
		n += 1 + sovTempo(uint64(m.PagesToSearch))
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.IndexPageSize != 0 {
		n += 1 + sovTempo(uint64(m.IndexPageSize))
	}
	if m.TotalRecords != 0 {
		n += 1 + sovTempo(uint64(m.TotalRecords))
	}
	l = len(m.DataEncoding)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovTempo(uint64(m.Size_))
	}
	if m.FooterSize != 0 {
		n += 1 + sovTempo(uint64(m.FooterSize))
	}
	if len(m.DedicatedColumns) > 0 {
		for _, e := range m.DedicatedColumns {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SearchTagValuesBlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SearchReq != nil {
		l = m.SearchReq.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.BlockID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.StartPage != 0 {
		n += 1 + sovTempo(uint64(m.StartPage))
	}
	if m.PagesToSearch != 0 {
		n += 1 + sovTempo(uint64(m.PagesToSearch))
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.IndexPageSize != 0 {
		n += 1 + sovTempo(uint64(m.IndexPageSize))
	}
	if m.TotalRecords != 0 {
		n += 1 + sovTempo(uint64(m.TotalRecords))
	}
	l = len(m.DataEncoding)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovTempo(uint64(m.Size_))
	}
	if m.FooterSize != 0 {
		n += 1 + sovTempo(uint64(m.FooterSize))
	}
	if len(m.DedicatedColumns) > 0 {
		for _, e := range m.DedicatedColumns {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SearchTagsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TagNames) > 0 {
		for _, s := range m.TagNames {
			l = len(s)
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SearchTagsV2Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Scopes) > 0 {
		for _, e := range m.Scopes {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SearchTagsV2Scope) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SearchTagValuesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TagName)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovTempo(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTempo(uint64(m.End))
	}
	return n
}

func (m *SearchTagValuesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TagValues) > 0 {
		for _, s := range m.TagValues {
			l = len(s)
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *TagValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *SearchTagValuesV2Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TagValues) > 0 {
		for _, e := range m.TagValues {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *Trace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Batches) > 0 {
		for _, e := range m.Batches {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *PushResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ErrorsByTrace) > 0 {
		l = 0
		for _, e := range m.ErrorsByTrace {
			l += sovTempo(uint64(e))
		}
		n += 1 + sovTempo(uint64(l)) + l
	}
	return n
}

func (m *PushBytesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Traces) > 0 {
		for _, e := range m.Traces {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if len(m.Ids) > 0 {
		for _, e := range m.Ids {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if len(m.SearchData) > 0 {
		for _, e := range m.SearchData {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *PushSpansRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Batches) > 0 {
		for _, e := range m.Batches {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *TraceBytes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Traces) > 0 {
		for _, b := range m.Traces {
			l = len(b)
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *LinkSlice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Links) > 0 {
		for _, e := range m.Links {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SpanMetricsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.GroupBy)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovTempo(uint64(m.Limit))
	}
	if m.Start != 0 {
		n += 1 + sovTempo(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTempo(uint64(m.End))
	}
	return n
}

func (m *SpanMetricsSummaryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.GroupBy)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovTempo(uint64(m.Limit))
	}
	if m.Start != 0 {
		n += 1 + sovTempo(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTempo(uint64(m.End))
	}
	return n
}

func (m *SpanMetricsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Estimated {
		n += 2
	}
	if m.SpanCount != 0 {
		n += 1 + sovTempo(uint64(m.SpanCount))
	}
	if m.ErrorSpanCount != 0 {
		n += 1 + sovTempo(uint64(m.ErrorSpanCount))
	}
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *RawHistogram) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bucket != 0 {
		n += 1 + sovTempo(uint64(m.Bucket))
	}
	if m.Count != 0 {
		n += 1 + sovTempo(uint64(m.Count))
	}
	return n
}

func (m *KeyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *SpanMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LatencyHistogram) > 0 {
		for _, e := range m.LatencyHistogram {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if len(m.Series) > 0 {
		for _, e := range m.Series {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Errors != 0 {
		n += 1 + sovTempo(uint64(m.Errors))
	}
	return n
}

func (m *SpanMetricsSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpanCount != 0 {
		n += 1 + sovTempo(uint64(m.SpanCount))
	}
	if m.ErrorSpanCount != 0 {
		n += 1 + sovTempo(uint64(m.ErrorSpanCount))
	}
	if len(m.Series) > 0 {
		for _, e := range m.Series {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.P99 != 0 {
		n += 1 + sovTempo(uint64(m.P99))
	}
	if m.P95 != 0 {
		n += 1 + sovTempo(uint64(m.P95))
	}
	if m.P90 != 0 {
		n += 1 + sovTempo(uint64(m.P90))
	}
	if m.P50 != 0 {
		n += 1 + sovTempo(uint64(m.P50))
	}
	return n
}

func (m *SpanMetricsSummaryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Summaries) > 0 {
		for _, e := range m.Summaries {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *TraceQLStatic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTempo(uint64(m.Type))
	}
	if m.N != 0 {
		n += 1 + sovTempo(uint64(m.N))
	}
	if m.F != 0 {
		n += 9
	}
	l = len(m.S)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.B {
		n += 2
	}
	if m.D != 0 {
		n += 1 + sovTempo(uint64(m.D))
	}
	if m.Status != 0 {
		n += 1 + sovTempo(uint64(m.Status))
	}
	if m.Kind != 0 {
		n += 1 + sovTempo(uint64(m.Kind))
	}
	return n
}

func (m *SpanMetricsData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResultType)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SpanMetricsResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LabelName)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.LabelValue)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if len(m.Ts) > 0 {
		for _, e := range m.Ts {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SpanMetricsResultPoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovTempo(uint64(m.Time))
	}
	if m.Val != 0 {
		n += 9
	}
	l = len(m.ExemplarTraceID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.ExemplarDuration != 0 {
		n += 1 + sovTempo(uint64(m.ExemplarDuration))
	}
	return n
}

func (m *QueryRangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovTempo(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTempo(uint64(m.End))
	}
	if m.Step != 0 {
		n += 1 + sovTempo(uint64(m.Step))
	}
	if m.ShardID != 0 {
		n += 1 + sovTempo(uint64(m.ShardID))
	}
	if m.ShardCount != 0 {
		n += 1 + sovTempo(uint64(m.ShardCount))
	}
	l = len(m.QueryMode)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *QueryRangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Series) > 0 {
		for _, e := range m.Series {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *Sample) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 9
	}
	if m.TimestampMs != 0 {
		n += 1 + sovTempo(uint64(m.TimestampMs))
	}
	return n
}

func (m *TimeSeries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if len(m.Samples) > 0 {
		for _, e := range m.Samples {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	l = len(m.PromLabels)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func sovTempo(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTempo(x uint64) (n int) {
	return sovTempo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TraceByIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceByIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceByIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraceID = append(m.TraceID[:0], dAtA[iNdEx:postIndex]...)
			if m.TraceID == nil {
				m.TraceID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockStart", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockStart = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockEnd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockEnd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceByIDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceByIDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceByIDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Trace == nil {
				m.Trace = &Trace{}
			}
			if err := m.Trace.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &TraceByIDMetrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceByIDMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceByIDMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceByIDMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTempo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTempo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTempo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTempo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTempo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTempo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTempo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTempo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTempo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDurationMs", wireType)
			}
			m.MinDurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinDurationMs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDurationMs", wireType)
			}
			m.MaxDurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDurationMs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpansPerSpanSet", wireType)
			}
			m.SpansPerSpanSet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpansPerSpanSet |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchBlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchBlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchBlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SearchReq == nil {
				m.SearchReq = &SearchRequest{}
			}
			if err := m.SearchReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPage", wireType)
			}
			m.StartPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PagesToSearch", wireType)
			}
			m.PagesToSearch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PagesToSearch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPageSize", wireType)
			}
			m.IndexPageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexPageSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRecords", wireType)
			}
			m.TotalRecords = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRecords |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataEncoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataEncoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FooterSize", wireType)
			}
			m.FooterSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FooterSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DedicatedColumns = append(m.DedicatedColumns, &DedicatedColumn{})
			if err := m.DedicatedColumns[len(m.DedicatedColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DedicatedColumn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DedicatedColumn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DedicatedColumn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= DedicatedColumn_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			m.Scope = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scope |= DedicatedColumn_Scope(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Traces = append(m.Traces, &TraceSearchMetadata{})
			if err := m.Traces[len(m.Traces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &SearchMetrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceSearchMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceSearchMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceSearchMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootTraceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootTraceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimeUnixNano", wireType)
			}
			m.StartTimeUnixNano = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimeUnixNano |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationMs", wireType)
			}
			m.DurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurationMs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpanSet == nil {
				m.SpanSet = &SpanSet{}
			}
			if err := m.SpanSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpanSets = append(m.SpanSets, &SpanSet{})
			if err := m.SpanSets[len(m.SpanSets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceStats == nil {
				m.ServiceStats = make(map[string]*ServiceStats)
			}
			var mapkey string
			var mapvalue *ServiceStats
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTempo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTempo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTempo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTempo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTempo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTempo
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTempo
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ServiceStats{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTempo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTempo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ServiceStats[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanCount", wireType)
			}
			m.SpanCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpanCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCount", wireType)
			}
			m.ErrorCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, &Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Matched", wireType)
			}
			m.Matched = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Matched |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &v1.KeyValue{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Span) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Span: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Span: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpanID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimeUnixNano", wireType)
			}
			m.StartTimeUnixNano = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimeUnixNano |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationNanos", wireType)
			}
			m.DurationNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurationNanos |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &v1.KeyValue{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InspectedTraces", wireType)
			}
			m.InspectedTraces = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InspectedTraces |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InspectedBytes", wireType)
			}
			m.InspectedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InspectedBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBlocks", wireType)
			}
			m.TotalBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBlocks |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedJobs", wireType)
			}
			m.CompletedJobs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletedJobs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalJobs", wireType)
			}
			m.TotalJobs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalJobs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBlockBytes", wireType)
			}
			m.TotalBlockBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBlockBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InspectedSpans", wireType)
			}
			m.InspectedSpans = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InspectedSpans |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scope = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagsBlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagsBlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagsBlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SearchReq == nil {
				m.SearchReq = &SearchTagsRequest{}
			}
			if err := m.SearchReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPage", wireType)
			}
			m.StartPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PagesToSearch", wireType)
			}
			m.PagesToSearch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PagesToSearch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPageSize", wireType)
			}
			m.IndexPageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexPageSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRecords", wireType)
			}
			m.TotalRecords = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRecords |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataEncoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataEncoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FooterSize", wireType)
			}
			m.FooterSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FooterSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DedicatedColumns = append(m.DedicatedColumns, &DedicatedColumn{})
			if err := m.DedicatedColumns[len(m.DedicatedColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagValuesBlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagValuesBlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagValuesBlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SearchReq == nil {
				m.SearchReq = &SearchTagValuesRequest{}
			}
			if err := m.SearchReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPage", wireType)
			}
			m.StartPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PagesToSearch", wireType)
			}
			m.PagesToSearch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PagesToSearch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPageSize", wireType)
			}
			m.IndexPageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexPageSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRecords", wireType)
			}
			m.TotalRecords = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRecords |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataEncoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataEncoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FooterSize", wireType)
			}
			m.FooterSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FooterSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DedicatedColumns = append(m.DedicatedColumns, &DedicatedColumn{})
			if err := m.DedicatedColumns[len(m.DedicatedColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagNames = append(m.TagNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagsV2Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagsV2Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagsV2Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scopes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scopes = append(m.Scopes, &SearchTagsV2Scope{})
			if err := m.Scopes[len(m.Scopes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagsV2Scope) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagsV2Scope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagsV2Scope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagValuesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagValuesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagValuesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagValuesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagValuesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagValuesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagValues = append(m.TagValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagValuesV2Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagValuesV2Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagValuesV2Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagValues = append(m.TagValues, &TagValue{})
			if err := m.TagValues[len(m.TagValues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Batches = append(m.Batches, &v11.ResourceSpans{})
			if err := m.Batches[len(m.Batches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v PushErrorReason
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTempo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= PushErrorReason(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ErrorsByTrace = append(m.ErrorsByTrace, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTempo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTempo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTempo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ErrorsByTrace) == 0 {
					m.ErrorsByTrace = make([]PushErrorReason, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v PushErrorReason
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTempo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= PushErrorReason(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ErrorsByTrace = append(m.ErrorsByTrace, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorsByTrace", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushBytesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushBytesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushBytesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traces", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v PreallocBytes
			m.Traces = append(m.Traces, v)
			if err := m.Traces[len(m.Traces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v PreallocBytes
			m.Ids = append(m.Ids, v)
			if err := m.Ids[len(m.Ids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v PreallocBytes
			m.SearchData = append(m.SearchData, v)
			if err := m.SearchData[len(m.SearchData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushSpansRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushSpansRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushSpansRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Batches = append(m.Batches, &v11.ResourceSpans{})
			if err := m.Batches[len(m.Batches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceBytes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceBytes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceBytes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traces", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Traces = append(m.Traces, make([]byte, postIndex-iNdEx))
			copy(m.Traces[len(m.Traces)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkSlice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkSlice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkSlice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Links = append(m.Links, &v11.Span_Link{})
			if err := m.Links[len(m.Links)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsSummaryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsSummaryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsSummaryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Estimated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Estimated = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanCount", wireType)
			}
			m.SpanCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpanCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorSpanCount", wireType)
			}
			m.ErrorSpanCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorSpanCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, &SpanMetrics{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawHistogram) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawHistogram: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawHistogram: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			m.Bucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &TraceQLStatic{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyHistogram", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatencyHistogram = append(m.LatencyHistogram, &RawHistogram{})
			if err := m.LatencyHistogram[len(m.LatencyHistogram)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Series = append(m.Series, &KeyValue{})
			if err := m.Series[len(m.Series)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			m.Errors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanCount", wireType)
			}
			m.SpanCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpanCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorSpanCount", wireType)
			}
			m.ErrorSpanCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorSpanCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Series = append(m.Series, &KeyValue{})
			if err := m.Series[len(m.Series)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field P99", wireType)
			}
			m.P99 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.P99 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field P95", wireType)
			}
			m.P95 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.P95 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field P90", wireType)
			}
			m.P90 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.P90 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field P50", wireType)
			}
			m.P50 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.P50 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsSummaryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsSummaryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsSummaryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summaries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summaries = append(m.Summaries, &SpanMetricsSummary{})
			if err := m.Summaries[len(m.Summaries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceQLStatic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceQLStatic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceQLStatic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			m.N = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.N |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.F = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.B = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field D", wireType)
			}
			m.D = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.D |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResultType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &SpanMetricsResult{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabelName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabelValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ts = append(m.Ts, &SpanMetricsResultPoint{})
			if err := m.Ts[len(m.Ts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsResultPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsResultPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsResultPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Val = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExemplarTraceID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExemplarTraceID = append(m.ExemplarTraceID[:0], dAtA[iNdEx:postIndex]...)
			if m.ExemplarTraceID == nil {
				m.ExemplarTraceID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExemplarDuration", wireType)
			}
			m.ExemplarDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExemplarDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			m.Step = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Step |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardCount", wireType)
			}
			m.ShardCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Series = append(m.Series, &TimeSeries{})
			if err := m.Series[len(m.Series)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &SearchMetrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sample) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sample: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sample: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMs", wireType)
			}
			m.TimestampMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeSeries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeSeries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeSeries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, v1.KeyValue{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Samples", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Samples = append(m.Samples, Sample{})
			if err := m.Samples[len(m.Samples)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromLabels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PromLabels = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTempo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTempo
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTempo
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTempo
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTempo        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTempo          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTempo = fmt.Errorf("proto: unexpected end of group")
)

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/tempopb/tempo.proto

package tempopb

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	v1 "github.com/grafana/tempo/pkg/tempopb/common/v1"
	v11 "github.com/grafana/tempo/pkg/tempopb/trace/v1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type PushErrorReason int32

const (
	PushErrorReason_NO_ERROR        PushErrorReason = 0
	PushErrorReason_MAX_LIVE_TRACES PushErrorReason = 1
	PushErrorReason_TRACE_TOO_LARGE PushErrorReason = 2
	PushErrorReason_UNKNOWN_ERROR   PushErrorReason = 3
)

var PushErrorReason_name = map[int32]string{
	0: "NO_ERROR",
	1: "MAX_LIVE_TRACES",
	2: "TRACE_TOO_LARGE",
	3: "UNKNOWN_ERROR",
}

var PushErrorReason_value = map[string]int32{
	"NO_ERROR":        0,
	"MAX_LIVE_TRACES": 1,
	"TRACE_TOO_LARGE": 2,
	"UNKNOWN_ERROR":   3,
}

func (x PushErrorReason) String() string {
	return proto.EnumName(PushErrorReason_name, int32(x))
}

func (PushErrorReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{0}
}

type DedicatedColumn_Scope int32

const (
	DedicatedColumn_SPAN     DedicatedColumn_Scope = 0
	DedicatedColumn_RESOURCE DedicatedColumn_Scope = 1
)

var DedicatedColumn_Scope_name = map[int32]string{
	0: "SPAN",
	1: "RESOURCE",
}

var DedicatedColumn_Scope_value = map[string]int32{
	"SPAN":     0,
	"RESOURCE": 1,
}

func (x DedicatedColumn_Scope) String() string {
	return proto.EnumName(DedicatedColumn_Scope_name, int32(x))
}

func (DedicatedColumn_Scope) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{5, 0}
}

type DedicatedColumn_Type int32

const (
	DedicatedColumn_STRING DedicatedColumn_Type = 0
)

var DedicatedColumn_Type_name = map[int32]string{
	0: "STRING",
}

var DedicatedColumn_Type_value = map[string]int32{
	"STRING": 0,
}

func (x DedicatedColumn_Type) String() string {
	return proto.EnumName(DedicatedColumn_Type_name, int32(x))
}

func (DedicatedColumn_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{5, 1}
}

// Read
type TraceByIDRequest struct {
	TraceID    []byte `protobuf:"bytes,1,opt,name=traceID,proto3" json:"traceID,omitempty"`
	BlockStart string `protobuf:"bytes,2,opt,name=blockStart,proto3" json:"blockStart,omitempty"`
	BlockEnd   string `protobuf:"bytes,3,opt,name=blockEnd,proto3" json:"blockEnd,omitempty"`
	QueryMode  string `protobuf:"bytes,5,opt,name=queryMode,proto3" json:"queryMode,omitempty"`
}

func (m *TraceByIDRequest) Reset()         { *m = TraceByIDRequest{} }
func (m *TraceByIDRequest) String() string { return proto.CompactTextString(m) }
func (*TraceByIDRequest) ProtoMessage()    {}
func (*TraceByIDRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{0}
}
func (m *TraceByIDRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceByIDRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceByIDRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceByIDRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceByIDRequest.Merge(m, src)
}
func (m *TraceByIDRequest) XXX_Size() int {
	return m.Size()
}
func (m *TraceByIDRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceByIDRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TraceByIDRequest proto.InternalMessageInfo

func (m *TraceByIDRequest) GetTraceID() []byte {
	if m != nil {
		return m.TraceID
	}
	return nil
}

func (m *TraceByIDRequest) GetBlockStart() string {
	if m != nil {
		return m.BlockStart
	}
	return ""
}

func (m *TraceByIDRequest) GetBlockEnd() string {
	if m != nil {
		return m.BlockEnd
	}
	return ""
}

func (m *TraceByIDRequest) GetQueryMode() string {
	if m != nil {
		return m.QueryMode
	}
	return ""
}

type TraceByIDResponse struct {
	Trace   *Trace            `protobuf:"bytes,1,opt,name=trace,proto3" json:"trace,omitempty"`
	Metrics *TraceByIDMetrics `protobuf:"bytes,2,opt,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *TraceByIDResponse) Reset()         { *m = TraceByIDResponse{} }
func (m *TraceByIDResponse) String() string { return proto.CompactTextString(m) }
func (*TraceByIDResponse) ProtoMessage()    {}
func (*TraceByIDResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{1}
}
func (m *TraceByIDResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceByIDResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceByIDResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceByIDResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceByIDResponse.Merge(m, src)
}
func (m *TraceByIDResponse) XXX_Size() int {
	return m.Size()
}
func (m *TraceByIDResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceByIDResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TraceByIDResponse proto.InternalMessageInfo

func (m *TraceByIDResponse) GetTrace() *Trace {
	if m != nil {
		return m.Trace
	}
	return nil
}

func (m *TraceByIDResponse) GetMetrics() *TraceByIDMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type TraceByIDMetrics struct {
}

func (m *TraceByIDMetrics) Reset()         { *m = TraceByIDMetrics{} }
func (m *TraceByIDMetrics) String() string { return proto.CompactTextString(m) }
func (*TraceByIDMetrics) ProtoMessage()    {}
func (*TraceByIDMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{2}
}
func (m *TraceByIDMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceByIDMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceByIDMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceByIDMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceByIDMetrics.Merge(m, src)
}
func (m *TraceByIDMetrics) XXX_Size() int {
	return m.Size()
}
func (m *TraceByIDMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceByIDMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_TraceByIDMetrics proto.InternalMessageInfo

// SearchRequest takes no block parameters and implies a "recent traces" search
type SearchRequest struct {
	// case insensitive partial match
	Tags          map[string]string `protobuf:"bytes,1,rep,name=Tags,proto3" json:"Tags" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MinDurationMs uint32            `protobuf:"varint,2,opt,name=MinDurationMs,proto3" json:"MinDurationMs,omitempty"`
	MaxDurationMs uint32            `protobuf:"varint,3,opt,name=MaxDurationMs,proto3" json:"MaxDurationMs,omitempty"`
	Limit         uint32            `protobuf:"varint,4,opt,name=Limit,proto3" json:"Limit,omitempty"`
	Start         uint32            `protobuf:"varint,5,opt,name=start,proto3" json:"start,omitempty"`
	End           uint32            `protobuf:"varint,6,opt,name=end,proto3" json:"end,omitempty"`
	// TraceQL query
	Query           string `protobuf:"bytes,8,opt,name=Query,proto3" json:"Query,omitempty"`
	SpansPerSpanSet uint32 `protobuf:"varint,9,opt,name=SpansPerSpanSet,proto3" json:"SpansPerSpanSet,omitempty"`
}

func (m *SearchRequest) Reset()         { *m = SearchRequest{} }
func (m *SearchRequest) String() string { return proto.CompactTextString(m) }
func (*SearchRequest) ProtoMessage()    {}
func (*SearchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{3}
}
func (m *SearchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchRequest.Merge(m, src)
}
func (m *SearchRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchRequest proto.InternalMessageInfo

func (m *SearchRequest) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *SearchRequest) GetMinDurationMs() uint32 {
	if m != nil {
		return m.MinDurationMs
	}
	return 0
}

func (m *SearchRequest) GetMaxDurationMs() uint32 {
	if m != nil {
		return m.MaxDurationMs
	}
	return 0
}

func (m *SearchRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SearchRequest) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SearchRequest) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *SearchRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SearchRequest) GetSpansPerSpanSet() uint32 {
	if m != nil {
		return m.SpansPerSpanSet
	}
	return 0
}

// SearchBlockRequest takes SearchRequest parameters as well as all information necessary
// to search a block in the backend.
type SearchBlockRequest struct {
	SearchReq        *SearchRequest     `protobuf:"bytes,1,opt,name=searchReq,proto3" json:"searchReq,omitempty"`
	BlockID          string             `protobuf:"bytes,2,opt,name=blockID,proto3" json:"blockID,omitempty"`
	StartPage        uint32             `protobuf:"varint,3,opt,name=startPage,proto3" json:"startPage,omitempty"`
	PagesToSearch    uint32             `protobuf:"varint,4,opt,name=pagesToSearch,proto3" json:"pagesToSearch,omitempty"`
	Encoding         string             `protobuf:"bytes,5,opt,name=encoding,proto3" json:"encoding,omitempty"`
	IndexPageSize    uint32             `protobuf:"varint,6,opt,name=indexPageSize,proto3" json:"indexPageSize,omitempty"`
	TotalRecords     uint32             `protobuf:"varint,7,opt,name=totalRecords,proto3" json:"totalRecords,omitempty"`
	DataEncoding     string             `protobuf:"bytes,8,opt,name=dataEncoding,proto3" json:"dataEncoding,omitempty"`
	Version          string             `protobuf:"bytes,9,opt,name=version,proto3" json:"version,omitempty"`
	Size_            uint64             `protobuf:"varint,10,opt,name=size,proto3" json:"size,omitempty"`
	FooterSize       uint32             `protobuf:"varint,11,opt,name=footerSize,proto3" json:"footerSize,omitempty"`
	DedicatedColumns []*DedicatedColumn `protobuf:"bytes,12,rep,name=dedicatedColumns,proto3" json:"dedicatedColumns,omitempty"`
}

func (m *SearchBlockRequest) Reset()         { *m = SearchBlockRequest{} }
func (m *SearchBlockRequest) String() string { return proto.CompactTextString(m) }
func (*SearchBlockRequest) ProtoMessage()    {}
func (*SearchBlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{4}
}
func (m *SearchBlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchBlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchBlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchBlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchBlockRequest.Merge(m, src)
}
func (m *SearchBlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchBlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchBlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchBlockRequest proto.InternalMessageInfo

func (m *SearchBlockRequest) GetSearchReq() *SearchRequest {
	if m != nil {
		return m.SearchReq
	}
	return nil
}

func (m *SearchBlockRequest) GetBlockID() string {
	if m != nil {
		return m.BlockID
	}
	return ""
}

func (m *SearchBlockRequest) GetStartPage() uint32 {
	if m != nil {
		return m.StartPage
	}
	return 0
}

func (m *SearchBlockRequest) GetPagesToSearch() uint32 {
	if m != nil {
		return m.PagesToSearch
	}
	return 0
}

func (m *SearchBlockRequest) GetEncoding() string {
	if m != nil {
		return m.Encoding
	}
	return ""
}

func (m *SearchBlockRequest) GetIndexPageSize() uint32 {
	if m != nil {
		return m.IndexPageSize
	}
	return 0
}

func (m *SearchBlockRequest) GetTotalRecords() uint32 {
	if m != nil {
		return m.TotalRecords
	}
	return 0
}

func (m *SearchBlockRequest) GetDataEncoding() string {
	if m != nil {
		return m.DataEncoding
	}
	return ""
}

func (m *SearchBlockRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *SearchBlockRequest) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *SearchBlockRequest) GetFooterSize() uint32 {
	if m != nil {
		return m.FooterSize
	}
	return 0
}

func (m *SearchBlockRequest) GetDedicatedColumns() []*DedicatedColumn {
	if m != nil {
		return m.DedicatedColumns
	}
	return nil
}

// Configuration for a single dedicated attribute column.
type DedicatedColumn struct {
	Scope DedicatedColumn_Scope `protobuf:"varint,3,opt,name=scope,proto3,enum=tempopb.DedicatedColumn_Scope" json:"scope,omitempty"`
	Name  string                `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Type  DedicatedColumn_Type  `protobuf:"varint,1,opt,name=type,proto3,enum=tempopb.DedicatedColumn_Type" json:"type,omitempty"`
}

func (m *DedicatedColumn) Reset()         { *m = DedicatedColumn{} }
func (m *DedicatedColumn) String() string { return proto.CompactTextString(m) }
func (*DedicatedColumn) ProtoMessage()    {}
func (*DedicatedColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{5}
}
func (m *DedicatedColumn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DedicatedColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DedicatedColumn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DedicatedColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DedicatedColumn.Merge(m, src)
}
func (m *DedicatedColumn) XXX_Size() int {
	return m.Size()
}
func (m *DedicatedColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_DedicatedColumn.DiscardUnknown(m)
}

var xxx_messageInfo_DedicatedColumn proto.InternalMessageInfo

func (m *DedicatedColumn) GetScope() DedicatedColumn_Scope {
	if m != nil {
		return m.Scope
	}
	return DedicatedColumn_SPAN
}

func (m *DedicatedColumn) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DedicatedColumn) GetType() DedicatedColumn_Type {
	if m != nil {
		return m.Type
	}
	return DedicatedColumn_STRING
}

type SearchResponse struct {
	Traces  []*TraceSearchMetadata `protobuf:"bytes,1,rep,name=traces,proto3" json:"traces,omitempty"`
	Metrics *SearchMetrics         `protobuf:"bytes,2,opt,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *SearchResponse) Reset()         { *m = SearchResponse{} }
func (m *SearchResponse) String() string { return proto.CompactTextString(m) }
func (*SearchResponse) ProtoMessage()    {}
func (*SearchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{6}
}
func (m *SearchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchResponse.Merge(m, src)
}
func (m *SearchResponse) XXX_Size() int {
	return m.Size()
}
func (m *SearchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SearchResponse proto.InternalMessageInfo

func (m *SearchResponse) GetTraces() []*TraceSearchMetadata {
	if m != nil {
		return m.Traces
	}
	return nil
}

func (m *SearchResponse) GetMetrics() *SearchMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type TraceSearchMetadata struct {
	TraceID           string     `protobuf:"bytes,1,opt,name=traceID,proto3" json:"traceID,omitempty"`
	RootServiceName   string     `protobuf:"bytes,2,opt,name=rootServiceName,proto3" json:"rootServiceName,omitempty"`
	RootTraceName     string     `protobuf:"bytes,3,opt,name=rootTraceName,proto3" json:"rootTraceName,omitempty"`
	StartTimeUnixNano uint64     `protobuf:"varint,4,opt,name=startTimeUnixNano,proto3" json:"startTimeUnixNano,omitempty"`
	DurationMs        uint32     `protobuf:"varint,5,opt,name=durationMs,proto3" json:"durationMs,omitempty"`
	SpanSet           *SpanSet   `protobuf:"bytes,6,opt,name=spanSet,proto3" json:"spanSet,omitempty"`
	SpanSets          []*SpanSet `protobuf:"bytes,7,rep,name=spanSets,proto3" json:"spanSets,omitempty"`
}

func (m *TraceSearchMetadata) Reset()         { *m = TraceSearchMetadata{} }
func (m *TraceSearchMetadata) String() string { return proto.CompactTextString(m) }
func (*TraceSearchMetadata) ProtoMessage()    {}
func (*TraceSearchMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{7}
}
func (m *TraceSearchMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceSearchMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceSearchMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceSearchMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceSearchMetadata.Merge(m, src)
}
func (m *TraceSearchMetadata) XXX_Size() int {
	return m.Size()
}
func (m *TraceSearchMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceSearchMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_TraceSearchMetadata proto.InternalMessageInfo

func (m *TraceSearchMetadata) GetTraceID() string {
	if m != nil {
		return m.TraceID
	}
	return ""
}

func (m *TraceSearchMetadata) GetRootServiceName() string {
	if m != nil {
		return m.RootServiceName
	}
	return ""
}

func (m *TraceSearchMetadata) GetRootTraceName() string {
	if m != nil {
		return m.RootTraceName
	}
	return ""
}

func (m *TraceSearchMetadata) GetStartTimeUnixNano() uint64 {
	if m != nil {
		return m.StartTimeUnixNano
	}
	return 0
}

func (m *TraceSearchMetadata) GetDurationMs() uint32 {
	if m != nil {
		return m.DurationMs
	}
	return 0
}

func (m *TraceSearchMetadata) GetSpanSet() *SpanSet {
	if m != nil {
		return m.SpanSet
	}
	return nil
}

func (m *TraceSearchMetadata) GetSpanSets() []*SpanSet {
	if m != nil {
		return m.SpanSets
	}
	return nil
}

type SpanSet struct {
	Spans      []*Span        `protobuf:"bytes,1,rep,name=spans,proto3" json:"spans,omitempty"`
	Matched    uint32         `protobuf:"varint,2,opt,name=matched,proto3" json:"matched,omitempty"`
	Attributes []*v1.KeyValue `protobuf:"bytes,3,rep,name=attributes,proto3" json:"attributes,omitempty"`
}

func (m *SpanSet) Reset()         { *m = SpanSet{} }
func (m *SpanSet) String() string { return proto.CompactTextString(m) }
func (*SpanSet) ProtoMessage()    {}
func (*SpanSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{8}
}
func (m *SpanSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanSet.Merge(m, src)
}
func (m *SpanSet) XXX_Size() int {
	return m.Size()
}
func (m *SpanSet) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanSet.DiscardUnknown(m)
}

var xxx_messageInfo_SpanSet proto.InternalMessageInfo

func (m *SpanSet) GetSpans() []*Span {
	if m != nil {
		return m.Spans
	}
	return nil
}

func (m *SpanSet) GetMatched() uint32 {
	if m != nil {
		return m.Matched
	}
	return 0
}

func (m *SpanSet) GetAttributes() []*v1.KeyValue {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type Span struct {
	SpanID            string         `protobuf:"bytes,1,opt,name=spanID,proto3" json:"spanID,omitempty"`
	Name              string         `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	StartTimeUnixNano uint64         `protobuf:"varint,3,opt,name=startTimeUnixNano,proto3" json:"startTimeUnixNano,omitempty"`
	DurationNanos     uint64         `protobuf:"varint,4,opt,name=durationNanos,proto3" json:"durationNanos,omitempty"`
	Attributes        []*v1.KeyValue `protobuf:"bytes,5,rep,name=attributes,proto3" json:"attributes,omitempty"`
}

func (m *Span) Reset()         { *m = Span{} }
func (m *Span) String() string { return proto.CompactTextString(m) }
func (*Span) ProtoMessage()    {}
func (*Span) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{9}
}
func (m *Span) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Span) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Span.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Span) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Span.Merge(m, src)
}
func (m *Span) XXX_Size() int {
	return m.Size()
}
func (m *Span) XXX_DiscardUnknown() {
	xxx_messageInfo_Span.DiscardUnknown(m)
}

var xxx_messageInfo_Span proto.InternalMessageInfo

func (m *Span) GetSpanID() string {
	if m != nil {
		return m.SpanID
	}
	return ""
}

func (m *Span) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Span) GetStartTimeUnixNano() uint64 {
	if m != nil {
		return m.StartTimeUnixNano
	}
	return 0
}

func (m *Span) GetDurationNanos() uint64 {
	if m != nil {
		return m.DurationNanos
	}
	return 0
}

func (m *Span) GetAttributes() []*v1.KeyValue {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type SearchMetrics struct {
	InspectedTraces uint32 `protobuf:"varint,1,opt,name=inspectedTraces,proto3" json:"inspectedTraces,omitempty"`
	InspectedBytes  uint64 `protobuf:"varint,2,opt,name=inspectedBytes,proto3" json:"inspectedBytes,omitempty"`
	TotalBlocks     uint32 `protobuf:"varint,3,opt,name=totalBlocks,proto3" json:"totalBlocks,omitempty"`
	CompletedJobs   uint32 `protobuf:"varint,4,opt,name=completedJobs,proto3" json:"completedJobs,omitempty"`
	TotalJobs       uint32 `protobuf:"varint,5,opt,name=totalJobs,proto3" json:"totalJobs,omitempty"`
	TotalBlockBytes uint64 `protobuf:"varint,6,opt,name=totalBlockBytes,proto3" json:"totalBlockBytes,omitempty"`
}

func (m *SearchMetrics) Reset()         { *m = SearchMetrics{} }
func (m *SearchMetrics) String() string { return proto.CompactTextString(m) }
func (*SearchMetrics) ProtoMessage()    {}
func (*SearchMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{10}
}
func (m *SearchMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchMetrics.Merge(m, src)
}
func (m *SearchMetrics) XXX_Size() int {
	return m.Size()
}
func (m *SearchMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_SearchMetrics proto.InternalMessageInfo

func (m *SearchMetrics) GetInspectedTraces() uint32 {
	if m != nil {
		return m.InspectedTraces
	}
	return 0
}

func (m *SearchMetrics) GetInspectedBytes() uint64 {
	if m != nil {
		return m.InspectedBytes
	}
	return 0
}

func (m *SearchMetrics) GetTotalBlocks() uint32 {
	if m != nil {
		return m.TotalBlocks
	}
	return 0
}

func (m *SearchMetrics) GetCompletedJobs() uint32 {
	if m != nil {
		return m.CompletedJobs
	}
	return 0
}

func (m *SearchMetrics) GetTotalJobs() uint32 {
	if m != nil {
		return m.TotalJobs
	}
	return 0
}

func (m *SearchMetrics) GetTotalBlockBytes() uint64 {
	if m != nil {
		return m.TotalBlockBytes
	}
	return 0
}

type SearchTagsRequest struct {
	Scope string `protobuf:"bytes,1,opt,name=scope,proto3" json:"scope,omitempty"`
}

func (m *SearchTagsRequest) Reset()         { *m = SearchTagsRequest{} }
func (m *SearchTagsRequest) String() string { return proto.CompactTextString(m) }
func (*SearchTagsRequest) ProtoMessage()    {}
func (*SearchTagsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{11}
}
func (m *SearchTagsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagsRequest.Merge(m, src)
}
func (m *SearchTagsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagsRequest proto.InternalMessageInfo

func (m *SearchTagsRequest) GetScope() string {
	if m != nil {
		return m.Scope
	}
	return ""
}

type SearchTagsResponse struct {
	TagNames []string `protobuf:"bytes,1,rep,name=tagNames,proto3" json:"tagNames,omitempty"`
}

func (m *SearchTagsResponse) Reset()         { *m = SearchTagsResponse{} }
func (m *SearchTagsResponse) String() string { return proto.CompactTextString(m) }
func (*SearchTagsResponse) ProtoMessage()    {}
func (*SearchTagsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{12}
}
func (m *SearchTagsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagsResponse.Merge(m, src)
}
func (m *SearchTagsResponse) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagsResponse proto.InternalMessageInfo

func (m *SearchTagsResponse) GetTagNames() []string {
	if m != nil {
		return m.TagNames
	}
	return nil
}

type SearchTagsV2Response struct {
	Scopes []*SearchTagsV2Scope `protobuf:"bytes,1,rep,name=scopes,proto3" json:"scopes,omitempty"`
}

func (m *SearchTagsV2Response) Reset()         { *m = SearchTagsV2Response{} }
func (m *SearchTagsV2Response) String() string { return proto.CompactTextString(m) }
func (*SearchTagsV2Response) ProtoMessage()    {}
func (*SearchTagsV2Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{13}
}
func (m *SearchTagsV2Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagsV2Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagsV2Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagsV2Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagsV2Response.Merge(m, src)
}
func (m *SearchTagsV2Response) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagsV2Response) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagsV2Response.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagsV2Response proto.InternalMessageInfo

func (m *SearchTagsV2Response) GetScopes() []*SearchTagsV2Scope {
	if m != nil {
		return m.Scopes
	}
	return nil
}

type SearchTagsV2Scope struct {
	Name string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Tags []string `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty"`
}

func (m *SearchTagsV2Scope) Reset()         { *m = SearchTagsV2Scope{} }
func (m *SearchTagsV2Scope) String() string { return proto.CompactTextString(m) }
func (*SearchTagsV2Scope) ProtoMessage()    {}
func (*SearchTagsV2Scope) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{14}
}
func (m *SearchTagsV2Scope) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagsV2Scope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagsV2Scope.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagsV2Scope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagsV2Scope.Merge(m, src)
}
func (m *SearchTagsV2Scope) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagsV2Scope) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagsV2Scope.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagsV2Scope proto.InternalMessageInfo

func (m *SearchTagsV2Scope) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SearchTagsV2Scope) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type SearchTagValuesRequest struct {
	TagName string `protobuf:"bytes,1,opt,name=tagName,proto3" json:"tagName,omitempty"`
	Query   string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
}

func (m *SearchTagValuesRequest) Reset()         { *m = SearchTagValuesRequest{} }
func (m *SearchTagValuesRequest) String() string { return proto.CompactTextString(m) }
func (*SearchTagValuesRequest) ProtoMessage()    {}
func (*SearchTagValuesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{15}
}
func (m *SearchTagValuesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagValuesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagValuesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagValuesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagValuesRequest.Merge(m, src)
}
func (m *SearchTagValuesRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagValuesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagValuesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagValuesRequest proto.InternalMessageInfo

func (m *SearchTagValuesRequest) GetTagName() string {
	if m != nil {
		return m.TagName
	}
	return ""
}

func (m *SearchTagValuesRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

type SearchTagValuesResponse struct {
	TagValues []string `protobuf:"bytes,1,rep,name=tagValues,proto3" json:"tagValues,omitempty"`
}

func (m *SearchTagValuesResponse) Reset()         { *m = SearchTagValuesResponse{} }
func (m *SearchTagValuesResponse) String() string { return proto.CompactTextString(m) }
func (*SearchTagValuesResponse) ProtoMessage()    {}
func (*SearchTagValuesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{16}
}
func (m *SearchTagValuesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagValuesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagValuesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagValuesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagValuesResponse.Merge(m, src)
}
func (m *SearchTagValuesResponse) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagValuesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagValuesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagValuesResponse proto.InternalMessageInfo

func (m *SearchTagValuesResponse) GetTagValues() []string {
	if m != nil {
		return m.TagValues
	}
	return nil
}

type TagValue struct {
	Type  string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *TagValue) Reset()         { *m = TagValue{} }
func (m *TagValue) String() string { return proto.CompactTextString(m) }
func (*TagValue) ProtoMessage()    {}
func (*TagValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{17}
}
func (m *TagValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagValue.Merge(m, src)
}
func (m *TagValue) XXX_Size() int {
	return m.Size()
}
func (m *TagValue) XXX_DiscardUnknown() {
	xxx_messageInfo_TagValue.DiscardUnknown(m)
}

var xxx_messageInfo_TagValue proto.InternalMessageInfo

func (m *TagValue) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *TagValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type SearchTagValuesV2Response struct {
	TagValues []*TagValue `protobuf:"bytes,1,rep,name=tagValues,proto3" json:"tagValues,omitempty"`
}

func (m *SearchTagValuesV2Response) Reset()         { *m = SearchTagValuesV2Response{} }
func (m *SearchTagValuesV2Response) String() string { return proto.CompactTextString(m) }
func (*SearchTagValuesV2Response) ProtoMessage()    {}
func (*SearchTagValuesV2Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{18}
}
func (m *SearchTagValuesV2Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagValuesV2Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagValuesV2Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagValuesV2Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagValuesV2Response.Merge(m, src)
}
func (m *SearchTagValuesV2Response) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagValuesV2Response) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagValuesV2Response.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagValuesV2Response proto.InternalMessageInfo

func (m *SearchTagValuesV2Response) GetTagValues() []*TagValue {
	if m != nil {
		return m.TagValues
	}
	return nil
}

type Trace struct {
	Batches []*v11.ResourceSpans `protobuf:"bytes,1,rep,name=batches,proto3" json:"batches,omitempty"`
}

func (m *Trace) Reset()         { *m = Trace{} }
func (m *Trace) String() string { return proto.CompactTextString(m) }
func (*Trace) ProtoMessage()    {}
func (*Trace) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{19}
}
func (m *Trace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Trace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Trace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trace.Merge(m, src)
}
func (m *Trace) XXX_Size() int {
	return m.Size()
}
func (m *Trace) XXX_DiscardUnknown() {
	xxx_messageInfo_Trace.DiscardUnknown(m)
}

var xxx_messageInfo_Trace proto.InternalMessageInfo

func (m *Trace) GetBatches() []*v11.ResourceSpans {
	if m != nil {
		return m.Batches
	}
	return nil
}

// Write
type PushResponse struct {
	ErrorsByTrace []PushErrorReason `protobuf:"varint,1,rep,packed,name=errorsByTrace,proto3,enum=tempopb.PushErrorReason" json:"errorsByTrace,omitempty"`
}

func (m *PushResponse) Reset()         { *m = PushResponse{} }
func (m *PushResponse) String() string { return proto.CompactTextString(m) }
func (*PushResponse) ProtoMessage()    {}
func (*PushResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{20}
}
func (m *PushResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PushResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PushResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushResponse.Merge(m, src)
}
func (m *PushResponse) XXX_Size() int {
	return m.Size()
}
func (m *PushResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PushResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PushResponse proto.InternalMessageInfo

func (m *PushResponse) GetErrorsByTrace() []PushErrorReason {
	if m != nil {
		return m.ErrorsByTrace
	}
	return nil
}

// PushBytesRequest pushes slices of traces, ids and searchdata. Traces are encoded using the
//  current BatchDecoder in ./pkg/model
type PushBytesRequest struct {
	// pre-marshalled Traces. length must match ids
	Traces []PreallocBytes `protobuf:"bytes,2,rep,name=traces,proto3,customtype=PreallocBytes" json:"traces"`
	// trace ids. length must match traces
	Ids []PreallocBytes `protobuf:"bytes,3,rep,name=ids,proto3,customtype=PreallocBytes" json:"ids"`
	// search data, length must match traces
	SearchData []PreallocBytes `protobuf:"bytes,4,rep,name=searchData,proto3,customtype=PreallocBytes" json:"searchData"`
}

func (m *PushBytesRequest) Reset()         { *m = PushBytesRequest{} }
func (m *PushBytesRequest) String() string { return proto.CompactTextString(m) }
func (*PushBytesRequest) ProtoMessage()    {}
func (*PushBytesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{21}
}
func (m *PushBytesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushBytesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PushBytesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PushBytesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushBytesRequest.Merge(m, src)
}
func (m *PushBytesRequest) XXX_Size() int {
	return m.Size()
}
func (m *PushBytesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PushBytesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PushBytesRequest proto.InternalMessageInfo

type PushSpansRequest struct {
	// just send entire OTel spans for now
	Batches []*v11.ResourceSpans `protobuf:"bytes,1,rep,name=batches,proto3" json:"batches,omitempty"`
}

func (m *PushSpansRequest) Reset()         { *m = PushSpansRequest{} }
func (m *PushSpansRequest) String() string { return proto.CompactTextString(m) }
func (*PushSpansRequest) ProtoMessage()    {}
func (*PushSpansRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{22}
}
func (m *PushSpansRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushSpansRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PushSpansRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PushSpansRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushSpansRequest.Merge(m, src)
}
func (m *PushSpansRequest) XXX_Size() int {
	return m.Size()
}
func (m *PushSpansRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PushSpansRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PushSpansRequest proto.InternalMessageInfo

func (m *PushSpansRequest) GetBatches() []*v11.ResourceSpans {
	if m != nil {
		return m.Batches
	}
	return nil
}

type TraceBytes struct {
	// pre-marshalled Traces
	Traces [][]byte `protobuf:"bytes,1,rep,name=traces,proto3" json:"traces,omitempty"`
}

func (m *TraceBytes) Reset()         { *m = TraceBytes{} }
func (m *TraceBytes) String() string { return proto.CompactTextString(m) }
func (*TraceBytes) ProtoMessage()    {}
func (*TraceBytes) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{23}
}
func (m *TraceBytes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceBytes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceBytes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceBytes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceBytes.Merge(m, src)
}
func (m *TraceBytes) XXX_Size() int {
	return m.Size()
}
func (m *TraceBytes) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceBytes.DiscardUnknown(m)
}

var xxx_messageInfo_TraceBytes proto.InternalMessageInfo

func (m *TraceBytes) GetTraces() [][]byte {
	if m != nil {
		return m.Traces
	}
	return nil
}

// this message exists for marshalling/unmarshalling convenience to/from parquet. in parquet we proto encode
// links to a column. unfortunately you can't encode a slice directly so we use this wrapper to generate
// the required marshalling/unmarshalling functions.
type LinkSlice struct {
	Links []*v11.Span_Link `protobuf:"bytes,1,rep,name=links,proto3" json:"links,omitempty"`
}

func (m *LinkSlice) Reset()         { *m = LinkSlice{} }
func (m *LinkSlice) String() string { return proto.CompactTextString(m) }
func (*LinkSlice) ProtoMessage()    {}
func (*LinkSlice) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{24}
}
func (m *LinkSlice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkSlice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinkSlice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LinkSlice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkSlice.Merge(m, src)
}
func (m *LinkSlice) XXX_Size() int {
	return m.Size()
}
func (m *LinkSlice) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkSlice.DiscardUnknown(m)
}

var xxx_messageInfo_LinkSlice proto.InternalMessageInfo

func (m *LinkSlice) GetLinks() []*v11.Span_Link {
	if m != nil {
		return m.Links
	}
	return nil
}

type SpanMetricsRequest struct {
	Query   string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	GroupBy string `protobuf:"bytes,2,opt,name=groupBy,proto3" json:"groupBy,omitempty"`
	Limit   uint64 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	Start   uint32 `protobuf:"varint,4,opt,name=start,proto3" json:"start,omitempty"`
	End     uint32 `protobuf:"varint,5,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *SpanMetricsRequest) Reset()         { *m = SpanMetricsRequest{} }
func (m *SpanMetricsRequest) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsRequest) ProtoMessage()    {}
func (*SpanMetricsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{25}
}
func (m *SpanMetricsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsRequest.Merge(m, src)
}
func (m *SpanMetricsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsRequest proto.InternalMessageInfo

func (m *SpanMetricsRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SpanMetricsRequest) GetGroupBy() string {
	if m != nil {
		return m.GroupBy
	}
	return ""
}

func (m *SpanMetricsRequest) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SpanMetricsRequest) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SpanMetricsRequest) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

type SpanMetricsSummaryRequest struct {
	Query   string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	GroupBy string `protobuf:"bytes,2,opt,name=groupBy,proto3" json:"groupBy,omitempty"`
	Limit   uint64 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	Start   uint32 `protobuf:"varint,4,opt,name=start,proto3" json:"start,omitempty"`
	End     uint32 `protobuf:"varint,5,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *SpanMetricsSummaryRequest) Reset()         { *m = SpanMetricsSummaryRequest{} }
func (m *SpanMetricsSummaryRequest) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsSummaryRequest) ProtoMessage()    {}
func (*SpanMetricsSummaryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{26}
}
func (m *SpanMetricsSummaryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsSummaryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsSummaryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsSummaryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsSummaryRequest.Merge(m, src)
}
func (m *SpanMetricsSummaryRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsSummaryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsSummaryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsSummaryRequest proto.InternalMessageInfo

func (m *SpanMetricsSummaryRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SpanMetricsSummaryRequest) GetGroupBy() string {
	if m != nil {
		return m.GroupBy
	}
	return ""
}

func (m *SpanMetricsSummaryRequest) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SpanMetricsSummaryRequest) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SpanMetricsSummaryRequest) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

type SpanMetricsResponse struct {
	Estimated      bool           `protobuf:"varint,1,opt,name=estimated,proto3" json:"estimated,omitempty"`
	SpanCount      uint64         `protobuf:"varint,2,opt,name=spanCount,proto3" json:"spanCount,omitempty"`
	ErrorSpanCount uint64         `protobuf:"varint,3,opt,name=errorSpanCount,proto3" json:"errorSpanCount,omitempty"`
	Metrics        []*SpanMetrics `protobuf:"bytes,4,rep,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *SpanMetricsResponse) Reset()         { *m = SpanMetricsResponse{} }
func (m *SpanMetricsResponse) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsResponse) ProtoMessage()    {}
func (*SpanMetricsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{27}
}
func (m *SpanMetricsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsResponse.Merge(m, src)
}
func (m *SpanMetricsResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsResponse proto.InternalMessageInfo

func (m *SpanMetricsResponse) GetEstimated() bool {
	if m != nil {
		return m.Estimated
	}
	return false
}

func (m *SpanMetricsResponse) GetSpanCount() uint64 {
	if m != nil {
		return m.SpanCount
	}
	return 0
}

func (m *SpanMetricsResponse) GetErrorSpanCount() uint64 {
	if m != nil {
		return m.ErrorSpanCount
	}
	return 0
}

func (m *SpanMetricsResponse) GetMetrics() []*SpanMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type RawHistogram struct {
	Bucket uint64 `protobuf:"varint,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
	Count  uint64 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *RawHistogram) Reset()         { *m = RawHistogram{} }
func (m *RawHistogram) String() string { return proto.CompactTextString(m) }
func (*RawHistogram) ProtoMessage()    {}
func (*RawHistogram) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{28}
}
func (m *RawHistogram) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawHistogram) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawHistogram.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawHistogram) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawHistogram.Merge(m, src)
}
func (m *RawHistogram) XXX_Size() int {
	return m.Size()
}
func (m *RawHistogram) XXX_DiscardUnknown() {
	xxx_messageInfo_RawHistogram.DiscardUnknown(m)
}

var xxx_messageInfo_RawHistogram proto.InternalMessageInfo

func (m *RawHistogram) GetBucket() uint64 {
	if m != nil {
		return m.Bucket
	}
	return 0
}

func (m *RawHistogram) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type KeyValue struct {
	Key   string         `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value *TraceQLStatic `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *KeyValue) Reset()         { *m = KeyValue{} }
func (m *KeyValue) String() string { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()    {}
func (*KeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{29}
}
func (m *KeyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyValue.Merge(m, src)
}
func (m *KeyValue) XXX_Size() int {
	return m.Size()
}
func (m *KeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_KeyValue proto.InternalMessageInfo

func (m *KeyValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyValue) GetValue() *TraceQLStatic {
	if m != nil {
		return m.Value
	}
	return nil
}

type SpanMetrics struct {
	LatencyHistogram []*RawHistogram `protobuf:"bytes,1,rep,name=latency_histogram,json=latencyHistogram,proto3" json:"latency_histogram,omitempty"`
	Series           []*KeyValue     `protobuf:"bytes,2,rep,name=series,proto3" json:"series,omitempty"`
	Errors           uint64          `protobuf:"varint,3,opt,name=errors,proto3" json:"errors,omitempty"`
}

func (m *SpanMetrics) Reset()         { *m = SpanMetrics{} }
func (m *SpanMetrics) String() string { return proto.CompactTextString(m) }
func (*SpanMetrics) ProtoMessage()    {}
func (*SpanMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{30}
}
func (m *SpanMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetrics.Merge(m, src)
}
func (m *SpanMetrics) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetrics proto.InternalMessageInfo

func (m *SpanMetrics) GetLatencyHistogram() []*RawHistogram {
	if m != nil {
		return m.LatencyHistogram
	}
	return nil
}

func (m *SpanMetrics) GetSeries() []*KeyValue {
	if m != nil {
		return m.Series
	}
	return nil
}

func (m *SpanMetrics) GetErrors() uint64 {
	if m != nil {
		return m.Errors
	}
	return 0
}

type SpanMetricsSummary struct {
	SpanCount      uint64      `protobuf:"varint,1,opt,name=spanCount,proto3" json:"spanCount,omitempty"`
	ErrorSpanCount uint64      `protobuf:"varint,2,opt,name=errorSpanCount,proto3" json:"errorSpanCount,omitempty"`
	Series         []*KeyValue `protobuf:"bytes,3,rep,name=series,proto3" json:"series,omitempty"`
	P99            uint64      `protobuf:"varint,4,opt,name=p99,proto3" json:"p99,omitempty"`
	P95            uint64      `protobuf:"varint,5,opt,name=p95,proto3" json:"p95,omitempty"`
	P90            uint64      `protobuf:"varint,6,opt,name=p90,proto3" json:"p90,omitempty"`
	P50            uint64      `protobuf:"varint,7,opt,name=p50,proto3" json:"p50,omitempty"`
}

func (m *SpanMetricsSummary) Reset()         { *m = SpanMetricsSummary{} }
func (m *SpanMetricsSummary) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsSummary) ProtoMessage()    {}
func (*SpanMetricsSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{31}
}
func (m *SpanMetricsSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsSummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsSummary.Merge(m, src)
}
func (m *SpanMetricsSummary) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsSummary.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsSummary proto.InternalMessageInfo

func (m *SpanMetricsSummary) GetSpanCount() uint64 {
	if m != nil {
		return m.SpanCount
	}
	return 0
}

func (m *SpanMetricsSummary) GetErrorSpanCount() uint64 {
	if m != nil {
		return m.ErrorSpanCount
	}
	return 0
}

func (m *SpanMetricsSummary) GetSeries() []*KeyValue {
	if m != nil {
		return m.Series
	}
	return nil
}

func (m *SpanMetricsSummary) GetP99() uint64 {
	if m != nil {
		return m.P99
	}
	return 0
}

func (m *SpanMetricsSummary) GetP95() uint64 {
	if m != nil {
		return m.P95
	}
	return 0
}

func (m *SpanMetricsSummary) GetP90() uint64 {
	if m != nil {
		return m.P90
	}
	return 0
}

func (m *SpanMetricsSummary) GetP50() uint64 {
	if m != nil {
		return m.P50
	}
	return 0
}

type SpanMetricsSummaryResponse struct {
	Summaries []*SpanMetricsSummary `protobuf:"bytes,1,rep,name=summaries,proto3" json:"summaries,omitempty"`
}

func (m *SpanMetricsSummaryResponse) Reset()         { *m = SpanMetricsSummaryResponse{} }
func (m *SpanMetricsSummaryResponse) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsSummaryResponse) ProtoMessage()    {}
func (*SpanMetricsSummaryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{32}
}
func (m *SpanMetricsSummaryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsSummaryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsSummaryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsSummaryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsSummaryResponse.Merge(m, src)
}
func (m *SpanMetricsSummaryResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsSummaryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsSummaryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsSummaryResponse proto.InternalMessageInfo

func (m *SpanMetricsSummaryResponse) GetSummaries() []*SpanMetricsSummary {
	if m != nil {
		return m.Summaries
	}
	return nil
}

type TraceQLStatic struct {
	Type   int32   `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	N      int64   `protobuf:"varint,2,opt,name=n,proto3" json:"n,omitempty"`
	F      float64 `protobuf:"fixed64,3,opt,name=f,proto3" json:"f,omitempty"`
	S      string  `protobuf:"bytes,4,opt,name=s,proto3" json:"s,omitempty"`
	B      bool    `protobuf:"varint,5,opt,name=b,proto3" json:"b,omitempty"`
	D      uint64  `protobuf:"varint,6,opt,name=d,proto3" json:"d,omitempty"`
	Status int32   `protobuf:"varint,7,opt,name=status,proto3" json:"status,omitempty"`
	Kind   int32   `protobuf:"varint,8,opt,name=kind,proto3" json:"kind,omitempty"`
}

func (m *TraceQLStatic) Reset()         { *m = TraceQLStatic{} }
func (m *TraceQLStatic) String() string { return proto.CompactTextString(m) }
func (*TraceQLStatic) ProtoMessage()    {}
func (*TraceQLStatic) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{33}
}
func (m *TraceQLStatic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceQLStatic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceQLStatic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceQLStatic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceQLStatic.Merge(m, src)
}
func (m *TraceQLStatic) XXX_Size() int {
	return m.Size()
}
func (m *TraceQLStatic) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceQLStatic.DiscardUnknown(m)
}

var xxx_messageInfo_TraceQLStatic proto.InternalMessageInfo

func (m *TraceQLStatic) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TraceQLStatic) GetN() int64 {
	if m != nil {
		return m.N
	}
	return 0
}

func (m *TraceQLStatic) GetF() float64 {
	if m != nil {
		return m.F
	}
	return 0
}

func (m *TraceQLStatic) GetS() string {
	if m != nil {
		return m.S
	}
	return ""
}

func (m *TraceQLStatic) GetB() bool {
	if m != nil {
		return m.B
	}
	return false
}

func (m *TraceQLStatic) GetD() uint64 {
	if m != nil {
		return m.D
	}
	return 0
}

func (m *TraceQLStatic) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *TraceQLStatic) GetKind() int32 {
	if m != nil {
		return m.Kind
	}
	return 0
}

func init() {
	proto.RegisterEnum("tempopb.PushErrorReason", PushErrorReason_name, PushErrorReason_value)
	proto.RegisterEnum("tempopb.DedicatedColumn_Scope", DedicatedColumn_Scope_name, DedicatedColumn_Scope_value)
	proto.RegisterEnum("tempopb.DedicatedColumn_Type", DedicatedColumn_Type_name, DedicatedColumn_Type_value)
	proto.RegisterType((*TraceByIDRequest)(nil), "tempopb.TraceByIDRequest")
	proto.RegisterType((*TraceByIDResponse)(nil), "tempopb.TraceByIDResponse")
	proto.RegisterType((*TraceByIDMetrics)(nil), "tempopb.TraceByIDMetrics")
	proto.RegisterType((*SearchRequest)(nil), "tempopb.SearchRequest")
	proto.RegisterMapType((map[string]string)(nil), "tempopb.SearchRequest.TagsEntry")
	proto.RegisterType((*SearchBlockRequest)(nil), "tempopb.SearchBlockRequest")
	proto.RegisterType((*DedicatedColumn)(nil), "tempopb.DedicatedColumn")
	proto.RegisterType((*SearchResponse)(nil), "tempopb.SearchResponse")
	proto.RegisterType((*TraceSearchMetadata)(nil), "tempopb.TraceSearchMetadata")
	proto.RegisterType((*SpanSet)(nil), "tempopb.SpanSet")
	proto.RegisterType((*Span)(nil), "tempopb.Span")
	proto.RegisterType((*SearchMetrics)(nil), "tempopb.SearchMetrics")
	proto.RegisterType((*SearchTagsRequest)(nil), "tempopb.SearchTagsRequest")
	proto.RegisterType((*SearchTagsResponse)(nil), "tempopb.SearchTagsResponse")
	proto.RegisterType((*SearchTagsV2Response)(nil), "tempopb.SearchTagsV2Response")
	proto.RegisterType((*SearchTagsV2Scope)(nil), "tempopb.SearchTagsV2Scope")
	proto.RegisterType((*SearchTagValuesRequest)(nil), "tempopb.SearchTagValuesRequest")
	proto.RegisterType((*SearchTagValuesResponse)(nil), "tempopb.SearchTagValuesResponse")
	proto.RegisterType((*TagValue)(nil), "tempopb.TagValue")
	proto.RegisterType((*SearchTagValuesV2Response)(nil), "tempopb.SearchTagValuesV2Response")
	proto.RegisterType((*Trace)(nil), "tempopb.Trace")
	proto.RegisterType((*PushResponse)(nil), "tempopb.PushResponse")
	proto.RegisterType((*PushBytesRequest)(nil), "tempopb.PushBytesRequest")
	proto.RegisterType((*PushSpansRequest)(nil), "tempopb.PushSpansRequest")
	proto.RegisterType((*TraceBytes)(nil), "tempopb.TraceBytes")
	proto.RegisterType((*LinkSlice)(nil), "tempopb.LinkSlice")
	proto.RegisterType((*SpanMetricsRequest)(nil), "tempopb.SpanMetricsRequest")
	proto.RegisterType((*SpanMetricsSummaryRequest)(nil), "tempopb.SpanMetricsSummaryRequest")
	proto.RegisterType((*SpanMetricsResponse)(nil), "tempopb.SpanMetricsResponse")
	proto.RegisterType((*RawHistogram)(nil), "tempopb.RawHistogram")
	proto.RegisterType((*KeyValue)(nil), "tempopb.KeyValue")
	proto.RegisterType((*SpanMetrics)(nil), "tempopb.SpanMetrics")
	proto.RegisterType((*SpanMetricsSummary)(nil), "tempopb.SpanMetricsSummary")
	proto.RegisterType((*SpanMetricsSummaryResponse)(nil), "tempopb.SpanMetricsSummaryResponse")
	proto.RegisterType((*TraceQLStatic)(nil), "tempopb.TraceQLStatic")
}

func init() { proto.RegisterFile("pkg/tempopb/tempo.proto", fileDescriptor_f22805646f4f62b6) }

var fileDescriptor_f22805646f4f62b6 = []byte{
	// 2089 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0x4b, 0x6f, 0x1b, 0xc9,
	0x11, 0xd6, 0x88, 0x0f, 0x89, 0xa5, 0x17, 0xd5, 0x7e, 0xd1, 0xb4, 0x57, 0x16, 0x66, 0x8d, 0x44,
	0xbb, 0xf0, 0x52, 0x32, 0xd7, 0xc6, 0xc6, 0xeb, 0x60, 0x03, 0xd3, 0x62, 0x6c, 0xd9, 0x7a, 0xd8,
	0x4d, 0xda, 0x1b, 0x04, 0x01, 0x84, 0xe1, 0xb0, 0x4d, 0x4f, 0x44, 0xce, 0x70, 0x67, 0x9a, 0x8a,
	0x99, 0x63, 0x80, 0x04, 0x08, 0x90, 0x43, 0x0e, 0xc9, 0x35, 0x40, 0x4e, 0x8b, 0xfc, 0x8e, 0x00,
	0xc1, 0x5e, 0x12, 0xec, 0x31, 0xc8, 0x61, 0x11, 0xd8, 0xbf, 0x20, 0xff, 0x20, 0xa8, 0xea, 0xee,
	0x79, 0x90, 0x94, 0x8d, 0x4d, 0x0e, 0x7b, 0x62, 0xd7, 0xd7, 0x5f, 0x57, 0x57, 0x57, 0x57, 0x57,
	0x15, 0x07, 0x2e, 0x0d, 0x4f, 0x7a, 0xdb, 0x52, 0x0c, 0x86, 0xc1, 0xb0, 0xa3, 0x7e, 0x6b, 0xc3,
	0x30, 0x90, 0x01, 0x5b, 0xd0, 0x60, 0xf5, 0xbc, 0x0c, 0x1d, 0x57, 0x6c, 0x9f, 0xde, 0xdc, 0xa6,
	0x81, 0x9a, 0xae, 0x5e, 0x74, 0x83, 0xc1, 0x20, 0xf0, 0x11, 0x56, 0x23, 0x8d, 0x7f, 0xd4, 0xf3,
	0xe4, 0xcb, 0x51, 0xa7, 0xe6, 0x06, 0x83, 0xed, 0x5e, 0xd0, 0x0b, 0xb6, 0x09, 0xee, 0x8c, 0x5e,
	0x90, 0x44, 0x02, 0x8d, 0x14, 0xdd, 0xfe, 0x8d, 0x05, 0xe5, 0x36, 0xaa, 0x6d, 0x8c, 0xf7, 0x76,
	0xb9, 0xf8, 0x62, 0x24, 0x22, 0xc9, 0x2a, 0xb0, 0x40, 0x5b, 0xed, 0xed, 0x56, 0xac, 0x4d, 0x6b,
	0x6b, 0x99, 0x1b, 0x91, 0x6d, 0x00, 0x74, 0xfa, 0x81, 0x7b, 0xd2, 0x92, 0x4e, 0x28, 0x2b, 0xf3,
	0x9b, 0xd6, 0x56, 0x89, 0xa7, 0x10, 0x56, 0x85, 0x45, 0x92, 0x9a, 0x7e, 0xb7, 0x92, 0xa3, 0xd9,
	0x58, 0x66, 0x57, 0xa1, 0xf4, 0xc5, 0x48, 0x84, 0xe3, 0x83, 0xa0, 0x2b, 0x2a, 0x05, 0x9a, 0x4c,
	0x00, 0xdb, 0x87, 0xf5, 0x94, 0x1d, 0xd1, 0x30, 0xf0, 0x23, 0xc1, 0xae, 0x43, 0x81, 0x76, 0x26,
	0x33, 0x96, 0xea, 0xab, 0x35, 0xed, 0x93, 0x1a, 0x51, 0xb9, 0x9a, 0x64, 0x1f, 0xc3, 0xc2, 0x40,
	0xc8, 0xd0, 0x73, 0x23, 0xb2, 0x68, 0xa9, 0x7e, 0x39, 0xcb, 0x43, 0x95, 0x07, 0x8a, 0xc0, 0x0d,
	0xd3, 0x66, 0xa9, 0x73, 0xeb, 0x49, 0xfb, 0x1f, 0xf3, 0xb0, 0xd2, 0x12, 0x4e, 0xe8, 0xbe, 0x34,
	0x9e, 0xf8, 0x14, 0xf2, 0x6d, 0xa7, 0x17, 0x55, 0xac, 0xcd, 0xdc, 0xd6, 0x52, 0x7d, 0x33, 0xd6,
	0x9b, 0x61, 0xd5, 0x90, 0xd2, 0xf4, 0x65, 0x38, 0x6e, 0xe4, 0xbf, 0xfa, 0xe6, 0xda, 0x1c, 0xa7,
	0x35, 0xec, 0x3a, 0xac, 0x1c, 0x78, 0xfe, 0xee, 0x28, 0x74, 0xa4, 0x17, 0xf8, 0x07, 0xca, 0xb8,
	0x15, 0x9e, 0x05, 0x89, 0xe5, 0xbc, 0x4a, 0xb1, 0x72, 0x9a, 0x95, 0x06, 0xd9, 0x79, 0x28, 0xec,
	0x7b, 0x03, 0x4f, 0x56, 0xf2, 0x34, 0xab, 0x04, 0x44, 0x23, 0xba, 0x88, 0x82, 0x42, 0x49, 0x60,
	0x65, 0xc8, 0x09, 0xbf, 0x5b, 0x29, 0x12, 0x86, 0x43, 0xe4, 0x3d, 0x45, 0x47, 0x57, 0x16, 0xc9,
	0xeb, 0x4a, 0x60, 0x5b, 0xb0, 0xd6, 0x1a, 0x3a, 0x7e, 0xf4, 0x44, 0x84, 0xf8, 0xdb, 0x12, 0xb2,
	0x52, 0xa2, 0x35, 0x93, 0x70, 0xf5, 0x13, 0x28, 0xc5, 0x47, 0x44, 0xf5, 0x27, 0x62, 0x4c, 0x37,
	0x52, 0xe2, 0x38, 0x44, 0xf5, 0xa7, 0x4e, 0x7f, 0x24, 0x74, 0x3c, 0x28, 0xe1, 0xd3, 0xf9, 0x1f,
	0x58, 0xf6, 0xdf, 0x72, 0xc0, 0x94, 0xab, 0x1a, 0x18, 0x05, 0xc6, 0xab, 0xb7, 0xa0, 0x14, 0x19,
	0x07, 0xea, 0xab, 0xbd, 0x38, 0xdb, 0xb5, 0x3c, 0x21, 0x62, 0x54, 0x52, 0x2c, 0xed, 0xed, 0xea,
	0x8d, 0x8c, 0x88, 0x91, 0x45, 0x47, 0x7f, 0xe2, 0xf4, 0x84, 0xf6, 0x5f, 0x02, 0xa0, 0x87, 0x87,
	0x4e, 0x4f, 0x44, 0xed, 0x40, 0xa9, 0xd6, 0x3e, 0xcc, 0x82, 0x18, 0xb9, 0xc2, 0x77, 0x83, 0xae,
	0xe7, 0xf7, 0x74, 0x70, 0xc6, 0x32, 0x6a, 0xf0, 0xfc, 0xae, 0x78, 0x85, 0xea, 0x5a, 0xde, 0x2f,
	0x85, 0xf6, 0x6d, 0x16, 0x64, 0x36, 0x2c, 0xcb, 0x40, 0x3a, 0x7d, 0x2e, 0xdc, 0x20, 0xec, 0x46,
	0x95, 0x05, 0x22, 0x65, 0x30, 0xe4, 0x74, 0x1d, 0xe9, 0x34, 0xcd, 0x4e, 0xea, 0x42, 0x32, 0x18,
	0x9e, 0xf3, 0x54, 0x84, 0x91, 0x17, 0xf8, 0x74, 0x1f, 0x25, 0x6e, 0x44, 0xc6, 0x20, 0x1f, 0xe1,
	0xf6, 0xb0, 0x69, 0x6d, 0xe5, 0x39, 0x8d, 0xf1, 0x45, 0xbe, 0x08, 0x02, 0x29, 0x42, 0x32, 0x6c,
	0x89, 0xf6, 0x4c, 0x21, 0x6c, 0x17, 0xca, 0x5d, 0xd1, 0xf5, 0x5c, 0x47, 0x8a, 0xee, 0xfd, 0xa0,
	0x3f, 0x1a, 0xf8, 0x51, 0x65, 0x99, 0xa2, 0xb9, 0x12, 0xbb, 0x7c, 0x37, 0x4b, 0xe0, 0x53, 0x2b,
	0xec, 0xbf, 0x5a, 0xb0, 0x36, 0xc1, 0x62, 0xb7, 0xa0, 0x10, 0xb9, 0xc1, 0x50, 0x79, 0x7c, 0xb5,
	0xbe, 0x71, 0x96, 0xba, 0x5a, 0x0b, 0x59, 0x5c, 0x91, 0xf1, 0x0c, 0xbe, 0x33, 0x30, 0xb1, 0x42,
	0x63, 0x76, 0x13, 0xf2, 0x72, 0x3c, 0x54, 0xaf, 0x7c, 0xb5, 0xfe, 0xde, 0x99, 0x8a, 0xda, 0xe3,
	0xa1, 0xe0, 0x44, 0xb5, 0xaf, 0x41, 0x81, 0xd4, 0xb2, 0x45, 0xc8, 0xb7, 0x9e, 0xdc, 0x3b, 0x2c,
	0xcf, 0xb1, 0x65, 0x58, 0xe4, 0xcd, 0xd6, 0xd1, 0x33, 0x7e, 0xbf, 0x59, 0xb6, 0x6c, 0x06, 0x79,
	0xa4, 0x33, 0x80, 0x62, 0xab, 0xcd, 0xf7, 0x0e, 0x1f, 0x94, 0xe7, 0xec, 0x57, 0xb0, 0x6a, 0xa2,
	0x4b, 0x27, 0x98, 0x5b, 0x50, 0xa4, 0x1c, 0x62, 0x5e, 0xf8, 0xd5, 0x6c, 0xe6, 0x50, 0xec, 0x03,
	0x21, 0x1d, 0xbc, 0x21, 0xae, 0xb9, 0x6c, 0x67, 0x32, 0xe1, 0x4c, 0x46, 0xef, 0x54, 0xb6, 0xf9,
	0x72, 0x1e, 0xce, 0xcd, 0xd0, 0x38, 0x99, 0x69, 0x4b, 0x49, 0xa6, 0xdd, 0x82, 0xb5, 0x30, 0x08,
	0x64, 0x4b, 0x84, 0xa7, 0x9e, 0x2b, 0x0e, 0x13, 0x97, 0x4d, 0xc2, 0x18, 0x9d, 0x08, 0x91, 0x7a,
	0xe2, 0xa9, 0xc4, 0x9b, 0x05, 0xd9, 0x0d, 0x58, 0xa7, 0x27, 0xd1, 0xf6, 0x06, 0xe2, 0x99, 0xef,
	0xbd, 0x3a, 0x74, 0xfc, 0x80, 0x5e, 0x42, 0x9e, 0x4f, 0x4f, 0x60, 0x54, 0x75, 0x93, 0x94, 0xa4,
	0xd2, 0x4b, 0x0a, 0x61, 0x1f, 0xc2, 0x42, 0xa4, 0x73, 0x46, 0x91, 0x3c, 0x50, 0x4e, 0x3c, 0xa0,
	0x70, 0x6e, 0x08, 0xec, 0x06, 0x2c, 0xea, 0x21, 0xbe, 0x89, 0xdc, 0x4c, 0x72, 0xcc, 0xb0, 0x7f,
	0x6d, 0xc1, 0x82, 0x46, 0xd9, 0xfb, 0x50, 0x40, 0xdc, 0x5c, 0xce, 0x4a, 0x66, 0x19, 0x57, 0x73,
	0xe8, 0xc2, 0x81, 0x23, 0xdd, 0x97, 0xa2, 0xab, 0x13, 0xac, 0x11, 0xd9, 0x5d, 0x00, 0x47, 0xca,
	0xd0, 0xeb, 0x8c, 0xa4, 0xc0, 0xbc, 0x8a, 0x3a, 0xae, 0xc4, 0x3a, 0x74, 0xd5, 0x3c, 0xbd, 0x59,
	0x7b, 0x2c, 0xc6, 0xcf, 0x31, 0x65, 0xf1, 0x14, 0x1d, 0x23, 0x3e, 0x8f, 0xdb, 0xb0, 0x8b, 0x50,
	0xc4, 0x8d, 0xe2, 0x1b, 0xd2, 0xd2, 0xcc, 0x40, 0x9e, 0xe9, 0xe4, 0xdc, 0x59, 0x4e, 0xbe, 0x0e,
	0x2b, 0xc6, 0xa5, 0x28, 0x47, 0xfa, 0x3a, 0xb2, 0xe0, 0xc4, 0x29, 0x0a, 0xdf, 0xee, 0x14, 0xff,
	0xb1, 0x4c, 0x45, 0xd3, 0x21, 0x89, 0x71, 0xe5, 0xf9, 0xd1, 0x50, 0xb8, 0x52, 0x74, 0xdb, 0x26,
	0xf4, 0x29, 0xeb, 0x4f, 0xc0, 0xec, 0x7b, 0xb0, 0x1a, 0x43, 0x8d, 0x31, 0x6e, 0x3e, 0x4f, 0xf6,
	0x4d, 0xa0, 0x6c, 0x13, 0x96, 0x28, 0xc7, 0x51, 0x8a, 0x37, 0xf5, 0x2b, 0x0d, 0xe1, 0x41, 0xdd,
	0x60, 0x30, 0xec, 0x0b, 0x29, 0xba, 0x8f, 0x82, 0x4e, 0x64, 0x32, 0x70, 0x06, 0xc4, 0x2c, 0x4e,
	0x8b, 0x88, 0xa1, 0x42, 0x2e, 0x01, 0xd0, 0xee, 0x44, 0xa5, 0x32, 0xa7, 0x48, 0xe6, 0x4c, 0xc2,
	0xf6, 0x07, 0xb0, 0xae, 0x8e, 0x8c, 0x35, 0xcb, 0x94, 0x9c, 0xf3, 0x26, 0x59, 0xa9, 0x4b, 0x54,
	0x82, 0xbd, 0x63, 0xca, 0x93, 0xa2, 0xea, 0xa4, 0x50, 0x85, 0x45, 0xe9, 0xf4, 0xf0, 0xd5, 0xa8,
	0xc8, 0x2b, 0xf1, 0x58, 0xb6, 0x1f, 0xc1, 0xf9, 0x64, 0xc5, 0xf3, 0x7a, 0xbc, 0xa6, 0x0e, 0x45,
	0x52, 0x69, 0x62, 0xb5, 0x3a, 0x91, 0x11, 0x14, 0x5d, 0x65, 0x42, 0xcd, 0xb4, 0xef, 0xa6, 0x0d,
	0xd5, 0x93, 0x71, 0x58, 0x59, 0xa9, 0xb0, 0x62, 0x90, 0x97, 0xd8, 0x85, 0xcc, 0x93, 0x31, 0x34,
	0xb6, 0x1f, 0xc2, 0xc5, 0x78, 0x31, 0xdd, 0x7b, 0x94, 0xee, 0xde, 0x94, 0xb9, 0x71, 0x4e, 0x51,
	0x22, 0x3a, 0x81, 0x1a, 0x2e, 0x53, 0xa8, 0x49, 0xb0, 0x3f, 0x81, 0x4b, 0x53, 0x9a, 0xf4, 0xa9,
	0xf0, 0x4a, 0x0c, 0xa8, 0x5d, 0x91, 0x00, 0xf6, 0x2d, 0x58, 0x34, 0x4b, 0xc8, 0xc4, 0x71, 0xec,
	0x5e, 0x1a, 0xcf, 0xee, 0x0b, 0xec, 0x7d, 0xb8, 0x3c, 0xb1, 0x5d, 0xca, 0x8d, 0xdb, 0x93, 0x1b,
	0x2e, 0xd5, 0xd7, 0x93, 0x94, 0xac, 0x67, 0xd2, 0x36, 0x34, 0xa0, 0x40, 0xe1, 0xca, 0xee, 0xc0,
	0x42, 0x87, 0xde, 0xbd, 0x59, 0x77, 0x2d, 0x5e, 0xa7, 0xda, 0xe6, 0xd3, 0x9b, 0x35, 0x2e, 0xa2,
	0x60, 0x14, 0xba, 0x82, 0xfa, 0x1b, 0x6e, 0xf8, 0xf6, 0x21, 0x2c, 0x3f, 0x19, 0x45, 0x49, 0x51,
	0xf8, 0x0c, 0x56, 0x44, 0x18, 0x06, 0x61, 0xd4, 0x18, 0xb7, 0x75, 0xf7, 0x99, 0xdb, 0x5a, 0x4d,
	0xd5, 0x4b, 0x64, 0x37, 0x91, 0xc1, 0x85, 0x13, 0x05, 0x3e, 0xcf, 0xd2, 0xed, 0x3f, 0x5b, 0x50,
	0x46, 0x0a, 0x85, 0xa3, 0xb9, 0x95, 0x8f, 0xe2, 0x4a, 0x83, 0xb7, 0xb8, 0xdc, 0xb8, 0x80, 0x9d,
	0xe2, 0xbf, 0xbe, 0xb9, 0xb6, 0xf2, 0x24, 0x14, 0x4e, 0xbf, 0x1f, 0xb8, 0x8a, 0x6d, 0x4a, 0xcc,
	0xf7, 0x21, 0xe7, 0x75, 0x55, 0xd2, 0x3a, 0x93, 0x8b, 0x0c, 0x76, 0x1b, 0x40, 0xb5, 0x48, 0xbb,
	0x8e, 0x74, 0x2a, 0xf9, 0xb7, 0xf1, 0x53, 0x44, 0xfb, 0x40, 0x99, 0xa8, 0x3c, 0xa1, 0x4d, 0xfc,
	0x3f, 0x5c, 0x78, 0x1d, 0x40, 0x77, 0xd3, 0x98, 0x11, 0x2e, 0x66, 0xaa, 0xea, 0xb2, 0x39, 0x94,
	0xfd, 0x19, 0x94, 0xf6, 0x3d, 0xff, 0xa4, 0xd5, 0xf7, 0x5c, 0x2c, 0xfa, 0x85, 0xbe, 0xe7, 0x9f,
	0x98, 0xbd, 0xae, 0x4c, 0xef, 0x85, 0x7b, 0xd4, 0x70, 0x01, 0x57, 0x4c, 0xfb, 0x57, 0x16, 0x30,
	0x04, 0x4d, 0x79, 0x4d, 0xde, 0xb6, 0x0a, 0x6b, 0x2b, 0x15, 0xd6, 0xf8, 0x0c, 0x7a, 0x61, 0x30,
	0x1a, 0x36, 0x4c, 0xb8, 0x1b, 0x11, 0xf9, 0x7d, 0x6a, 0xa6, 0x55, 0x66, 0x56, 0x42, 0xd2, 0x4c,
	0xe7, 0x67, 0x34, 0xd3, 0x85, 0xb8, 0x99, 0xb6, 0x7f, 0x6b, 0xc1, 0xe5, 0x94, 0x11, 0xad, 0xd1,
	0x60, 0xe0, 0x84, 0xe3, 0xef, 0xc6, 0x96, 0xbf, 0x58, 0x70, 0x2e, 0xe3, 0x90, 0xe4, 0xdd, 0x8a,
	0x48, 0x7a, 0x03, 0xec, 0x9d, 0xc8, 0x92, 0x45, 0x9e, 0x00, 0xd4, 0x2e, 0x0f, 0x1d, 0xff, 0x7e,
	0x30, 0xf2, 0xa5, 0xce, 0xe9, 0x09, 0x80, 0x69, 0x9f, 0xc2, 0xb9, 0x15, 0x53, 0x94, 0x69, 0x13,
	0x28, 0xab, 0x25, 0x4d, 0x50, 0x9e, 0x6e, 0xf0, 0x7c, 0xa6, 0x3c, 0x4f, 0xb5, 0x40, 0x3f, 0x84,
	0x65, 0xee, 0xfc, 0xe2, 0xa1, 0x17, 0xc9, 0xa0, 0x17, 0x3a, 0x03, 0x0c, 0x92, 0xce, 0xc8, 0x3d,
	0x11, 0x92, 0x0c, 0xcc, 0x73, 0x2d, 0xe1, 0xd9, 0xdd, 0x94, 0x65, 0x4a, 0xb0, 0x1f, 0xc1, 0xa2,
	0x29, 0x70, 0x33, 0xfe, 0x81, 0xdc, 0x48, 0x67, 0x9a, 0x74, 0x3b, 0x46, 0x41, 0xf9, 0x74, 0xbf,
	0x25, 0x1d, 0xe9, 0xb9, 0x26, 0x03, 0xfd, 0xc1, 0x82, 0xa5, 0x94, 0x89, 0xac, 0x01, 0xeb, 0x7d,
	0x47, 0x0a, 0xdf, 0x1d, 0x1f, 0xbf, 0x34, 0xe6, 0xe9, 0xa8, 0xbc, 0x10, 0x6b, 0x4a, 0xdb, 0xce,
	0xcb, 0x9a, 0x9f, 0x9c, 0xe6, 0x03, 0x28, 0x46, 0x22, 0xf4, 0xf4, 0xf3, 0x4e, 0x67, 0xad, 0xb8,
	0x2e, 0x6b, 0x02, 0x1e, 0x5c, 0xe5, 0x0b, 0xed, 0x58, 0x2d, 0xd9, 0x7f, 0xcf, 0x46, 0xb7, 0x0e,
	0xac, 0xec, 0x6d, 0x59, 0xef, 0xbe, 0xad, 0xf9, 0x99, 0xb7, 0x95, 0xd8, 0x97, 0x7b, 0x97, 0x7d,
	0x65, 0xc8, 0x0d, 0xef, 0xdc, 0xd1, 0xcd, 0x08, 0x0e, 0x15, 0x72, 0x9b, 0x02, 0x8f, 0x90, 0xdb,
	0x0a, 0xd9, 0xd1, 0x15, 0x18, 0x87, 0x84, 0xdc, 0xde, 0xa1, 0x3f, 0x3d, 0x88, 0xdc, 0xde, 0xb1,
	0x3f, 0x87, 0xea, 0xac, 0x77, 0xa2, 0x43, 0xf4, 0x0e, 0x94, 0x22, 0x82, 0x3c, 0x31, 0x9d, 0x02,
	0x66, 0xac, 0x4b, 0xd8, 0xf6, 0x1f, 0x2d, 0x58, 0xc9, 0x5c, 0x6c, 0xa6, 0xfa, 0x14, 0x74, 0xf5,
	0x59, 0x06, 0xcb, 0x27, 0x67, 0xe4, 0xb8, 0xe5, 0xa3, 0xf4, 0x82, 0xfc, 0x6d, 0x71, 0xeb, 0x05,
	0x4a, 0xaa, 0x09, 0x29, 0x71, 0x2b, 0x42, 0xa9, 0x43, 0x87, 0x5b, 0xe4, 0x56, 0x07, 0xa5, 0xae,
	0x3e, 0x98, 0xd5, 0xa5, 0xee, 0x4f, 0x3a, 0x72, 0xa4, 0xfe, 0xce, 0x15, 0xb8, 0x96, 0x70, 0xc7,
	0x13, 0xcf, 0xef, 0xd2, 0x1f, 0xb8, 0x02, 0xa7, 0xf1, 0x87, 0x3f, 0x83, 0xb5, 0x89, 0xca, 0x80,
	0xff, 0x49, 0x0e, 0x8f, 0x8e, 0x9b, 0x9c, 0x1f, 0xf1, 0xf2, 0x1c, 0x3b, 0x07, 0x6b, 0x07, 0xf7,
	0x7e, 0x72, 0xbc, 0xbf, 0xf7, 0xbc, 0x79, 0xdc, 0xe6, 0xf7, 0xee, 0x37, 0x5b, 0x65, 0x0b, 0x41,
	0x1a, 0x1f, 0xb7, 0x8f, 0x8e, 0x8e, 0xf7, 0xef, 0xf1, 0x07, 0xcd, 0xf2, 0x3c, 0x5b, 0x87, 0x95,
	0x67, 0x87, 0x8f, 0x0f, 0x8f, 0x3e, 0x3f, 0xd4, 0x8b, 0x73, 0xf5, 0xdf, 0x59, 0x50, 0x44, 0xf5,
	0x22, 0x64, 0x3f, 0x82, 0x52, 0x5c, 0x5f, 0xd8, 0xe5, 0x4c, 0x59, 0x4a, 0xd7, 0x9c, 0xea, 0x85,
	0xcc, 0x94, 0x71, 0xbd, 0x3d, 0xc7, 0xee, 0xc1, 0x52, 0x4c, 0x7e, 0x5e, 0xff, 0x5f, 0x54, 0xd4,
	0xff, 0x64, 0x41, 0x59, 0x5f, 0xd1, 0x03, 0xe1, 0x8b, 0xd0, 0x91, 0x41, 0x6c, 0x18, 0x15, 0x87,
	0x09, 0xad, 0xe9, 0x4a, 0x73, 0xb6, 0x61, 0x7b, 0x00, 0x0f, 0x84, 0x34, 0x0f, 0x73, 0x66, 0x40,
	0x18, 0x1d, 0x57, 0x67, 0x4f, 0xc6, 0x06, 0x7e, 0x99, 0x87, 0x85, 0xa7, 0x23, 0x0c, 0xe9, 0x90,
	0x3d, 0x84, 0x95, 0x1f, 0x7b, 0x7e, 0x37, 0xfe, 0xe0, 0xc3, 0x66, 0x7c, 0x21, 0x32, 0x7a, 0xab,
	0xb3, 0xa6, 0x52, 0x9e, 0x5b, 0x36, 0x7f, 0x21, 0x5d, 0xe1, 0x4b, 0x76, 0xc6, 0x77, 0x8b, 0xea,
	0xa5, 0x29, 0x3c, 0x56, 0xd1, 0x84, 0xa5, 0xd4, 0x37, 0x91, 0xf4, 0x21, 0xa7, 0xbe, 0x94, 0xbc,
	0x4d, 0xcd, 0x03, 0x80, 0xa4, 0x7b, 0x64, 0xb3, 0xfa, 0x4d, 0xa3, 0xe4, 0xca, 0xcc, 0xb9, 0x58,
	0xd1, 0x63, 0x73, 0x24, 0xd5, 0x86, 0xbe, 0x55, 0xd5, 0x7b, 0x33, 0xdb, 0xda, 0x94, 0xb2, 0xe7,
	0xb0, 0x36, 0xd1, 0xdd, 0xb1, 0x6b, 0xd3, 0x6b, 0x32, 0x0d, 0x6b, 0x75, 0xf3, 0x6c, 0x42, 0xac,
	0xf7, 0xa7, 0xa9, 0x5e, 0xd9, 0x74, 0x8d, 0xef, 0xd6, 0x6c, 0x9f, 0x45, 0x48, 0xdb, 0x5c, 0x3f,
	0x82, 0x72, 0x4b, 0x86, 0xc2, 0x19, 0x78, 0x7e, 0xcf, 0x44, 0xcc, 0x5d, 0x28, 0xea, 0x0f, 0x43,
	0xdf, 0xf6, 0x86, 0x77, 0xac, 0xfa, 0xcf, 0x61, 0xc1, 0x84, 0xf0, 0xf1, 0xcc, 0x9c, 0x6e, 0xbf,
	0x2d, 0xd3, 0x69, 0xfd, 0xef, 0xbf, 0x95, 0x63, 0x8c, 0x6f, 0x54, 0xbe, 0x7a, 0xbd, 0x61, 0x7d,
	0xfd, 0x7a, 0xc3, 0xfa, 0xf7, 0xeb, 0x0d, 0xeb, 0xf7, 0x6f, 0x36, 0xe6, 0xbe, 0x7e, 0xb3, 0x31,
	0xf7, 0xcf, 0x37, 0x1b, 0x73, 0x9d, 0x22, 0x7d, 0xe1, 0xfd, 0xf8, 0xbf, 0x01, 0x00, 0x00, 0xff,
	0xff, 0x17, 0x51, 0x57, 0x33, 0x62, 0x16, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PusherClient is the client API for Pusher service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PusherClient interface {
	// different versions of PushBytes expect the trace data to be pushed in different formats
	PushBytes(ctx context.Context, in *PushBytesRequest, opts ...grpc.CallOption) (*PushResponse, error)
	PushBytesV2(ctx context.Context, in *PushBytesRequest, opts ...grpc.CallOption) (*PushResponse, error)
}

type pusherClient struct {
	cc *grpc.ClientConn
}

func NewPusherClient(cc *grpc.ClientConn) PusherClient {
	return &pusherClient{cc}
}

func (c *pusherClient) PushBytes(ctx context.Context, in *PushBytesRequest, opts ...grpc.CallOption) (*PushResponse, error) {
	out := new(PushResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Pusher/PushBytes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pusherClient) PushBytesV2(ctx context.Context, in *PushBytesRequest, opts ...grpc.CallOption) (*PushResponse, error) {
	out := new(PushResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Pusher/PushBytesV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PusherServer is the server API for Pusher service.
type PusherServer interface {
	// different versions of PushBytes expect the trace data to be pushed in different formats
	PushBytes(context.Context, *PushBytesRequest) (*PushResponse, error)
	PushBytesV2(context.Context, *PushBytesRequest) (*PushResponse, error)
}

// UnimplementedPusherServer can be embedded to have forward compatible implementations.
type UnimplementedPusherServer struct {
}

func (*UnimplementedPusherServer) PushBytes(ctx context.Context, req *PushBytesRequest) (*PushResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushBytes not implemented")
}
func (*UnimplementedPusherServer) PushBytesV2(ctx context.Context, req *PushBytesRequest) (*PushResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushBytesV2 not implemented")
}

func RegisterPusherServer(s *grpc.Server, srv PusherServer) {
	s.RegisterService(&_Pusher_serviceDesc, srv)
}

func _Pusher_PushBytes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushBytesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PusherServer).PushBytes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Pusher/PushBytes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PusherServer).PushBytes(ctx, req.(*PushBytesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pusher_PushBytesV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushBytesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PusherServer).PushBytesV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Pusher/PushBytesV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PusherServer).PushBytesV2(ctx, req.(*PushBytesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Pusher_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tempopb.Pusher",
	HandlerType: (*PusherServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PushBytes",
			Handler:    _Pusher_PushBytes_Handler,
		},
		{
			MethodName: "PushBytesV2",
			Handler:    _Pusher_PushBytesV2_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/tempopb/tempo.proto",
}

// MetricsGeneratorClient is the client API for MetricsGenerator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MetricsGeneratorClient interface {
	PushSpans(ctx context.Context, in *PushSpansRequest, opts ...grpc.CallOption) (*PushResponse, error)
	GetMetrics(ctx context.Context, in *SpanMetricsRequest, opts ...grpc.CallOption) (*SpanMetricsResponse, error)
}

type metricsGeneratorClient struct {
	cc *grpc.ClientConn
}

func NewMetricsGeneratorClient(cc *grpc.ClientConn) MetricsGeneratorClient {
	return &metricsGeneratorClient{cc}
}

func (c *metricsGeneratorClient) PushSpans(ctx context.Context, in *PushSpansRequest, opts ...grpc.CallOption) (*PushResponse, error) {
	out := new(PushResponse)
	err := c.cc.Invoke(ctx, "/tempopb.MetricsGenerator/PushSpans", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metricsGeneratorClient) GetMetrics(ctx context.Context, in *SpanMetricsRequest, opts ...grpc.CallOption) (*SpanMetricsResponse, error) {
	out := new(SpanMetricsResponse)
	err := c.cc.Invoke(ctx, "/tempopb.MetricsGenerator/GetMetrics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MetricsGeneratorServer is the server API for MetricsGenerator service.
type MetricsGeneratorServer interface {
	PushSpans(context.Context, *PushSpansRequest) (*PushResponse, error)
	GetMetrics(context.Context, *SpanMetricsRequest) (*SpanMetricsResponse, error)
}

// UnimplementedMetricsGeneratorServer can be embedded to have forward compatible implementations.
type UnimplementedMetricsGeneratorServer struct {
}

func (*UnimplementedMetricsGeneratorServer) PushSpans(ctx context.Context, req *PushSpansRequest) (*PushResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushSpans not implemented")
}
func (*UnimplementedMetricsGeneratorServer) GetMetrics(ctx context.Context, req *SpanMetricsRequest) (*SpanMetricsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMetrics not implemented")
}

func RegisterMetricsGeneratorServer(s *grpc.Server, srv MetricsGeneratorServer) {
	s.RegisterService(&_MetricsGenerator_serviceDesc, srv)
}

func _MetricsGenerator_PushSpans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushSpansRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricsGeneratorServer).PushSpans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.MetricsGenerator/PushSpans",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricsGeneratorServer).PushSpans(ctx, req.(*PushSpansRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetricsGenerator_GetMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpanMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricsGeneratorServer).GetMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.MetricsGenerator/GetMetrics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricsGeneratorServer).GetMetrics(ctx, req.(*SpanMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MetricsGenerator_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tempopb.MetricsGenerator",
	HandlerType: (*MetricsGeneratorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PushSpans",
			Handler:    _MetricsGenerator_PushSpans_Handler,
		},
		{
			MethodName: "GetMetrics",
			Handler:    _MetricsGenerator_GetMetrics_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/tempopb/tempo.proto",
}

// QuerierClient is the client API for Querier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QuerierClient interface {
	FindTraceByID(ctx context.Context, in *TraceByIDRequest, opts ...grpc.CallOption) (*TraceByIDResponse, error)
	SearchRecent(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	SearchBlock(ctx context.Context, in *SearchBlockRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	SearchTags(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (*SearchTagsResponse, error)
	SearchTagsV2(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (*SearchTagsV2Response, error)
	SearchTagValues(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (*SearchTagValuesResponse, error)
	SearchTagValuesV2(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (*SearchTagValuesV2Response, error)
}

type querierClient struct {
	cc *grpc.ClientConn
}

func NewQuerierClient(cc *grpc.ClientConn) QuerierClient {
	return &querierClient{cc}
}

func (c *querierClient) FindTraceByID(ctx context.Context, in *TraceByIDRequest, opts ...grpc.CallOption) (*TraceByIDResponse, error) {
	out := new(TraceByIDResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/FindTraceByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchRecent(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	out := new(SearchResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchRecent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchBlock(ctx context.Context, in *SearchBlockRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	out := new(SearchResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchTags(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (*SearchTagsResponse, error) {
	out := new(SearchTagsResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchTagsV2(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (*SearchTagsV2Response, error) {
	out := new(SearchTagsV2Response)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchTagsV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchTagValues(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (*SearchTagValuesResponse, error) {
	out := new(SearchTagValuesResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchTagValues", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchTagValuesV2(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (*SearchTagValuesV2Response, error) {
	out := new(SearchTagValuesV2Response)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchTagValuesV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QuerierServer is the server API for Querier service.
type QuerierServer interface {
	FindTraceByID(context.Context, *TraceByIDRequest) (*TraceByIDResponse, error)
	SearchRecent(context.Context, *SearchRequest) (*SearchResponse, error)
	SearchBlock(context.Context, *SearchBlockRequest) (*SearchResponse, error)
	SearchTags(context.Context, *SearchTagsRequest) (*SearchTagsResponse, error)
	SearchTagsV2(context.Context, *SearchTagsRequest) (*SearchTagsV2Response, error)
	SearchTagValues(context.Context, *SearchTagValuesRequest) (*SearchTagValuesResponse, error)
	SearchTagValuesV2(context.Context, *SearchTagValuesRequest) (*SearchTagValuesV2Response, error)
}

// UnimplementedQuerierServer can be embedded to have forward compatible implementations.
type UnimplementedQuerierServer struct {
}

func (*UnimplementedQuerierServer) FindTraceByID(ctx context.Context, req *TraceByIDRequest) (*TraceByIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindTraceByID not implemented")
}
func (*UnimplementedQuerierServer) SearchRecent(ctx context.Context, req *SearchRequest) (*SearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchRecent not implemented")
}
func (*UnimplementedQuerierServer) SearchBlock(ctx context.Context, req *SearchBlockRequest) (*SearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchBlock not implemented")
}
func (*UnimplementedQuerierServer) SearchTags(ctx context.Context, req *SearchTagsRequest) (*SearchTagsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchTags not implemented")
}
func (*UnimplementedQuerierServer) SearchTagsV2(ctx context.Context, req *SearchTagsRequest) (*SearchTagsV2Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchTagsV2 not implemented")
}
func (*UnimplementedQuerierServer) SearchTagValues(ctx context.Context, req *SearchTagValuesRequest) (*SearchTagValuesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchTagValues not implemented")
}
func (*UnimplementedQuerierServer) SearchTagValuesV2(ctx context.Context, req *SearchTagValuesRequest) (*SearchTagValuesV2Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchTagValuesV2 not implemented")
}

func RegisterQuerierServer(s *grpc.Server, srv QuerierServer) {
	s.RegisterService(&_Querier_serviceDesc, srv)
}

func _Querier_FindTraceByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TraceByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).FindTraceByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/FindTraceByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).FindTraceByID(ctx, req.(*TraceByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchRecent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchRecent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchRecent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchRecent(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchBlock(ctx, req.(*SearchBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchTags(ctx, req.(*SearchTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchTagsV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchTagsV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchTagsV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchTagsV2(ctx, req.(*SearchTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchTagValues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchTagValuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchTagValues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchTagValues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchTagValues(ctx, req.(*SearchTagValuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchTagValuesV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchTagValuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchTagValuesV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchTagValuesV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchTagValuesV2(ctx, req.(*SearchTagValuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Querier_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tempopb.Querier",
	HandlerType: (*QuerierServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FindTraceByID",
			Handler:    _Querier_FindTraceByID_Handler,
		},
		{
			MethodName: "SearchRecent",
			Handler:    _Querier_SearchRecent_Handler,
		},
		{
			MethodName: "SearchBlock",
			Handler:    _Querier_SearchBlock_Handler,
		},
		{
			MethodName: "SearchTags",
			Handler:    _Querier_SearchTags_Handler,
		},
		{
			MethodName: "SearchTagsV2",
			Handler:    _Querier_SearchTagsV2_Handler,
		},
		{
			MethodName: "SearchTagValues",
			Handler:    _Querier_SearchTagValues_Handler,
		},
		{
			MethodName: "SearchTagValuesV2",
			Handler:    _Querier_SearchTagValuesV2_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/tempopb/tempo.proto",
}

// StreamingQuerierClient is the client API for StreamingQuerier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StreamingQuerierClient interface {
	Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchClient, error)
}

type streamingQuerierClient struct {
	cc *grpc.ClientConn
}

func NewStreamingQuerierClient(cc *grpc.ClientConn) StreamingQuerierClient {
	return &streamingQuerierClient{cc}
}

func (c *streamingQuerierClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamingQuerier_serviceDesc.Streams[0], "/tempopb.StreamingQuerier/Search", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingQuerierSearchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingQuerier_SearchClient interface {
	Recv() (*SearchResponse, error)
	grpc.ClientStream
}

type streamingQuerierSearchClient struct {
	grpc.ClientStream
}

func (x *streamingQuerierSearchClient) Recv() (*SearchResponse, error) {
	m := new(SearchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StreamingQuerierServer is the server API for StreamingQuerier service.
type StreamingQuerierServer interface {
	Search(*SearchRequest, StreamingQuerier_SearchServer) error
}

// UnimplementedStreamingQuerierServer can be embedded to have forward compatible implementations.
type UnimplementedStreamingQuerierServer struct {
}

func (*UnimplementedStreamingQuerierServer) Search(req *SearchRequest, srv StreamingQuerier_SearchServer) error {
	return status.Errorf(codes.Unimplemented, "method Search not implemented")
}

func RegisterStreamingQuerierServer(s *grpc.Server, srv StreamingQuerierServer) {
	s.RegisterService(&_StreamingQuerier_serviceDesc, srv)
}

func _StreamingQuerier_Search_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingQuerierServer).Search(m, &streamingQuerierSearchServer{stream})
}

type StreamingQuerier_SearchServer interface {
	Send(*SearchResponse) error
	grpc.ServerStream
}

type streamingQuerierSearchServer struct {
	grpc.ServerStream
}

func (x *streamingQuerierSearchServer) Send(m *SearchResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _StreamingQuerier_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tempopb.StreamingQuerier",
	HandlerType: (*StreamingQuerierServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Search",
			Handler:       _StreamingQuerier_Search_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/tempopb/tempo.proto",
}

// MetricsClient is the client API for Metrics service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MetricsClient interface {
	SpanMetricsSummary(ctx context.Context, in *SpanMetricsSummaryRequest, opts ...grpc.CallOption) (*SpanMetricsSummaryResponse, error)
}

type metricsClient struct {
	cc *grpc.ClientConn
}

func NewMetricsClient(cc *grpc.ClientConn) MetricsClient {
	return &metricsClient{cc}
}

func (c *metricsClient) SpanMetricsSummary(ctx context.Context, in *SpanMetricsSummaryRequest, opts ...grpc.CallOption) (*SpanMetricsSummaryResponse, error) {
	out := new(SpanMetricsSummaryResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Metrics/SpanMetricsSummary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MetricsServer is the server API for Metrics service.
type MetricsServer interface {
	SpanMetricsSummary(context.Context, *SpanMetricsSummaryRequest) (*SpanMetricsSummaryResponse, error)
}

// UnimplementedMetricsServer can be embedded to have forward compatible implementations.
type UnimplementedMetricsServer struct {
}

func (*UnimplementedMetricsServer) SpanMetricsSummary(ctx context.Context, req *SpanMetricsSummaryRequest) (*SpanMetricsSummaryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SpanMetricsSummary not implemented")
}

func RegisterMetricsServer(s *grpc.Server, srv MetricsServer) {
	s.RegisterService(&_Metrics_serviceDesc, srv)
}

func _Metrics_SpanMetricsSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpanMetricsSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricsServer).SpanMetricsSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Metrics/SpanMetricsSummary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricsServer).SpanMetricsSummary(ctx, req.(*SpanMetricsSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Metrics_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tempopb.Metrics",
	HandlerType: (*MetricsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SpanMetricsSummary",
			Handler:    _Metrics_SpanMetricsSummary_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/tempopb/tempo.proto",
}

func (m *TraceByIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceByIDRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceByIDRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.QueryMode) > 0 {
		i -= len(m.QueryMode)
		copy(dAtA[i:], m.QueryMode)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.QueryMode)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BlockEnd) > 0 {
		i -= len(m.BlockEnd)
		copy(dAtA[i:], m.BlockEnd)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.BlockEnd)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BlockStart) > 0 {
		i -= len(m.BlockStart)
		copy(dAtA[i:], m.BlockStart)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.BlockStart)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TraceID) > 0 {
		i -= len(m.TraceID)
		copy(dAtA[i:], m.TraceID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.TraceID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TraceByIDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceByIDResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceByIDResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Trace != nil {
		{
			size, err := m.Trace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TraceByIDMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceByIDMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceByIDMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SearchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SpansPerSpanSet != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.SpansPerSpanSet))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x42
	}
	if m.End != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x30
	}
	if m.Start != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x28
	}
	if m.Limit != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxDurationMs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.MaxDurationMs))
		i--
		dAtA[i] = 0x18
	}
	if m.MinDurationMs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.MinDurationMs))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTempo(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTempo(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTempo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SearchBlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchBlockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchBlockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DedicatedColumns) > 0 {
		for iNdEx := len(m.DedicatedColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DedicatedColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.FooterSize != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.FooterSize))
		i--
		dAtA[i] = 0x58
	}
	if m.Size_ != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.DataEncoding) > 0 {
		i -= len(m.DataEncoding)
		copy(dAtA[i:], m.DataEncoding)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.DataEncoding)))
		i--
		dAtA[i] = 0x42
	}
	if m.TotalRecords != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalRecords))
		i--
		dAtA[i] = 0x38
	}
	if m.IndexPageSize != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.IndexPageSize))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Encoding) > 0 {
		i -= len(m.Encoding)
		copy(dAtA[i:], m.Encoding)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Encoding)))
		i--
		dAtA[i] = 0x2a
	}
	if m.PagesToSearch != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.PagesToSearch))
		i--
		dAtA[i] = 0x20
	}
	if m.StartPage != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StartPage))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BlockID) > 0 {
		i -= len(m.BlockID)
		copy(dAtA[i:], m.BlockID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.BlockID)))
		i--
		dAtA[i] = 0x12
	}
	if m.SearchReq != nil {
		{
			size, err := m.SearchReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DedicatedColumn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DedicatedColumn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DedicatedColumn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Scope != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Scope))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SearchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Traces) > 0 {
		for iNdEx := len(m.Traces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Traces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TraceSearchMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceSearchMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceSearchMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SpanSets) > 0 {
		for iNdEx := len(m.SpanSets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpanSets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.SpanSet != nil {
		{
			size, err := m.SpanSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.DurationMs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.DurationMs))
		i--
		dAtA[i] = 0x28
	}
	if m.StartTimeUnixNano != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StartTimeUnixNano))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RootTraceName) > 0 {
		i -= len(m.RootTraceName)
		copy(dAtA[i:], m.RootTraceName)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.RootTraceName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RootServiceName) > 0 {
		i -= len(m.RootServiceName)
		copy(dAtA[i:], m.RootServiceName)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.RootServiceName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TraceID) > 0 {
		i -= len(m.TraceID)
		copy(dAtA[i:], m.TraceID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.TraceID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpanSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Matched != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Matched))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Span) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Span) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Span) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.DurationNanos != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.DurationNanos))
		i--
		dAtA[i] = 0x20
	}
	if m.StartTimeUnixNano != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StartTimeUnixNano))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpanID) > 0 {
		i -= len(m.SpanID)
		copy(dAtA[i:], m.SpanID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.SpanID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalBlockBytes != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalBlockBytes))
		i--
		dAtA[i] = 0x30
	}
	if m.TotalJobs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalJobs))
		i--
		dAtA[i] = 0x28
	}
	if m.CompletedJobs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.CompletedJobs))
		i--
		dAtA[i] = 0x20
	}
	if m.TotalBlocks != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalBlocks))
		i--
		dAtA[i] = 0x18
	}
	if m.InspectedBytes != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.InspectedBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.InspectedTraces != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.InspectedTraces))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Scope) > 0 {
		i -= len(m.Scope)
		copy(dAtA[i:], m.Scope)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Scope)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TagNames) > 0 {
		for iNdEx := len(m.TagNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TagNames[iNdEx])
			copy(dAtA[i:], m.TagNames[iNdEx])
			i = encodeVarintTempo(dAtA, i, uint64(len(m.TagNames[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagsV2Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagsV2Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagsV2Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Scopes) > 0 {
		for iNdEx := len(m.Scopes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Scopes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagsV2Scope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagsV2Scope) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagsV2Scope) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintTempo(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagValuesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagValuesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagValuesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TagName) > 0 {
		i -= len(m.TagName)
		copy(dAtA[i:], m.TagName)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.TagName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagValuesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagValuesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagValuesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TagValues) > 0 {
		for iNdEx := len(m.TagValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TagValues[iNdEx])
			copy(dAtA[i:], m.TagValues[iNdEx])
			i = encodeVarintTempo(dAtA, i, uint64(len(m.TagValues[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TagValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagValuesV2Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagValuesV2Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagValuesV2Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TagValues) > 0 {
		for iNdEx := len(m.TagValues) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TagValues[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Trace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Trace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Batches) > 0 {
		for iNdEx := len(m.Batches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Batches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PushResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorsByTrace) > 0 {
		dAtA7 := make([]byte, len(m.ErrorsByTrace)*10)
		var j6 int
		for _, num := range m.ErrorsByTrace {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintTempo(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PushBytesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushBytesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushBytesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SearchData) > 0 {
		for iNdEx := len(m.SearchData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.SearchData[iNdEx].Size()
				i -= size
				if _, err := m.SearchData[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Ids) > 0 {
		for iNdEx := len(m.Ids) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.Ids[iNdEx].Size()
				i -= size
				if _, err := m.Ids[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Traces) > 0 {
		for iNdEx := len(m.Traces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.Traces[iNdEx].Size()
				i -= size
				if _, err := m.Traces[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *PushSpansRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushSpansRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushSpansRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Batches) > 0 {
		for iNdEx := len(m.Batches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Batches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TraceBytes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceBytes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceBytes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Traces) > 0 {
		for iNdEx := len(m.Traces) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Traces[iNdEx])
			copy(dAtA[i:], m.Traces[iNdEx])
			i = encodeVarintTempo(dAtA, i, uint64(len(m.Traces[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LinkSlice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkSlice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LinkSlice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Links) > 0 {
		for iNdEx := len(m.Links) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Links[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x28
	}
	if m.Start != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x20
	}
	if m.Limit != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if len(m.GroupBy) > 0 {
		i -= len(m.GroupBy)
		copy(dAtA[i:], m.GroupBy)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.GroupBy)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsSummaryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsSummaryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsSummaryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x28
	}
	if m.Start != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x20
	}
	if m.Limit != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if len(m.GroupBy) > 0 {
		i -= len(m.GroupBy)
		copy(dAtA[i:], m.GroupBy)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.GroupBy)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metrics) > 0 {
		for iNdEx := len(m.Metrics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metrics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ErrorSpanCount != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.ErrorSpanCount))
		i--
		dAtA[i] = 0x18
	}
	if m.SpanCount != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.SpanCount))
		i--
		dAtA[i] = 0x10
	}
	if m.Estimated {
		i--
		if m.Estimated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RawHistogram) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawHistogram) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawHistogram) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.Bucket != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Bucket))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *KeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Errors != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Errors))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Series) > 0 {
		for iNdEx := len(m.Series) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Series[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.LatencyHistogram) > 0 {
		for iNdEx := len(m.LatencyHistogram) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LatencyHistogram[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.P50 != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.P50))
		i--
		dAtA[i] = 0x38
	}
	if m.P90 != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.P90))
		i--
		dAtA[i] = 0x30
	}
	if m.P95 != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.P95))
		i--
		dAtA[i] = 0x28
	}
	if m.P99 != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.P99))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Series) > 0 {
		for iNdEx := len(m.Series) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Series[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ErrorSpanCount != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.ErrorSpanCount))
		i--
		dAtA[i] = 0x10
	}
	if m.SpanCount != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.SpanCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsSummaryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsSummaryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsSummaryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Summaries) > 0 {
		for iNdEx := len(m.Summaries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Summaries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TraceQLStatic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceQLStatic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceQLStatic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x40
	}
	if m.Status != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if m.D != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.D))
		i--
		dAtA[i] = 0x30
	}
	if m.B {
		i--
		if m.B {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.S) > 0 {
		i -= len(m.S)
		copy(dAtA[i:], m.S)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.S)))
		i--
		dAtA[i] = 0x22
	}
	if m.F != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.F))))
		i--
		dAtA[i] = 0x19
	}
	if m.N != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.N))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTempo(dAtA []byte, offset int, v uint64) int {
	offset -= sovTempo(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TraceByIDRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TraceID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.BlockStart)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.BlockEnd)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.QueryMode)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *TraceByIDResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Trace != nil {
		l = m.Trace.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *TraceByIDMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SearchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTempo(uint64(len(k))) + 1 + len(v) + sovTempo(uint64(len(v)))
			n += mapEntrySize + 1 + sovTempo(uint64(mapEntrySize))
		}
	}
	if m.MinDurationMs != 0 {
		n += 1 + sovTempo(uint64(m.MinDurationMs))
	}
	if m.MaxDurationMs != 0 {
		n += 1 + sovTempo(uint64(m.MaxDurationMs))
	}
	if m.Limit != 0 {
		n += 1 + sovTempo(uint64(m.Limit))
	}
	if m.Start != 0 {
		n += 1 + sovTempo(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTempo(uint64(m.End))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.SpansPerSpanSet != 0 {
		n += 1 + sovTempo(uint64(m.SpansPerSpanSet))
	}
	return n
}

func (m *SearchBlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SearchReq != nil {
		l = m.SearchReq.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.BlockID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.StartPage != 0 {
		n += 1 + sovTempo(uint64(m.StartPage))
	}
	if m.PagesToSearch != 0 {
		n += 1 + sovTempo(uint64(m.PagesToSearch))
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.IndexPageSize != 0 {
		n += 1 + sovTempo(uint64(m.IndexPageSize))
	}
	if m.TotalRecords != 0 {
		n += 1 + sovTempo(uint64(m.TotalRecords))
	}
	l = len(m.DataEncoding)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovTempo(uint64(m.Size_))
	}
	if m.FooterSize != 0 {
		n += 1 + sovTempo(uint64(m.FooterSize))
	}
	if len(m.DedicatedColumns) > 0 {
		for _, e := range m.DedicatedColumns {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *DedicatedColumn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTempo(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Scope != 0 {
		n += 1 + sovTempo(uint64(m.Scope))
	}
	return n
}

func (m *SearchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Traces) > 0 {
		for _, e := range m.Traces {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *TraceSearchMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TraceID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.RootServiceName)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.RootTraceName)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.StartTimeUnixNano != 0 {
		n += 1 + sovTempo(uint64(m.StartTimeUnixNano))
	}
	if m.DurationMs != 0 {
		n += 1 + sovTempo(uint64(m.DurationMs))
	}
	if m.SpanSet != nil {
		l = m.SpanSet.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	if len(m.SpanSets) > 0 {
		for _, e := range m.SpanSets {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SpanSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Matched != 0 {
		n += 1 + sovTempo(uint64(m.Matched))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *Span) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpanID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.StartTimeUnixNano != 0 {
		n += 1 + sovTempo(uint64(m.StartTimeUnixNano))
	}
	if m.DurationNanos != 0 {
		n += 1 + sovTempo(uint64(m.DurationNanos))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SearchMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InspectedTraces != 0 {
		n += 1 + sovTempo(uint64(m.InspectedTraces))
	}
	if m.InspectedBytes != 0 {
		n += 1 + sovTempo(uint64(m.InspectedBytes))
	}
	if m.TotalBlocks != 0 {
		n += 1 + sovTempo(uint64(m.TotalBlocks))
	}
	if m.CompletedJobs != 0 {
		n += 1 + sovTempo(uint64(m.CompletedJobs))
	}
	if m.TotalJobs != 0 {
		n += 1 + sovTempo(uint64(m.TotalJobs))
	}
	if m.TotalBlockBytes != 0 {
		n += 1 + sovTempo(uint64(m.TotalBlockBytes))
	}
	return n
}

func (m *SearchTagsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Scope)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *SearchTagsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TagNames) > 0 {
		for _, s := range m.TagNames {
			l = len(s)
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SearchTagsV2Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Scopes) > 0 {
		for _, e := range m.Scopes {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SearchTagsV2Scope) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SearchTagValuesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TagName)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *SearchTagValuesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TagValues) > 0 {
		for _, s := range m.TagValues {
			l = len(s)
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *TagValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *SearchTagValuesV2Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TagValues) > 0 {
		for _, e := range m.TagValues {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *Trace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Batches) > 0 {
		for _, e := range m.Batches {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *PushResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ErrorsByTrace) > 0 {
		l = 0
		for _, e := range m.ErrorsByTrace {
			l += sovTempo(uint64(e))
		}
		n += 1 + sovTempo(uint64(l)) + l
	}
	return n
}

func (m *PushBytesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Traces) > 0 {
		for _, e := range m.Traces {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if len(m.Ids) > 0 {
		for _, e := range m.Ids {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if len(m.SearchData) > 0 {
		for _, e := range m.SearchData {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *PushSpansRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Batches) > 0 {
		for _, e := range m.Batches {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *TraceBytes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Traces) > 0 {
		for _, b := range m.Traces {
			l = len(b)
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *LinkSlice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Links) > 0 {
		for _, e := range m.Links {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SpanMetricsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.GroupBy)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovTempo(uint64(m.Limit))
	}
	if m.Start != 0 {
		n += 1 + sovTempo(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTempo(uint64(m.End))
	}
	return n
}

func (m *SpanMetricsSummaryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.GroupBy)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovTempo(uint64(m.Limit))
	}
	if m.Start != 0 {
		n += 1 + sovTempo(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTempo(uint64(m.End))
	}
	return n
}

func (m *SpanMetricsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Estimated {
		n += 2
	}
	if m.SpanCount != 0 {
		n += 1 + sovTempo(uint64(m.SpanCount))
	}
	if m.ErrorSpanCount != 0 {
		n += 1 + sovTempo(uint64(m.ErrorSpanCount))
	}
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *RawHistogram) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bucket != 0 {
		n += 1 + sovTempo(uint64(m.Bucket))
	}
	if m.Count != 0 {
		n += 1 + sovTempo(uint64(m.Count))
	}
	return n
}

func (m *KeyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *SpanMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LatencyHistogram) > 0 {
		for _, e := range m.LatencyHistogram {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if len(m.Series) > 0 {
		for _, e := range m.Series {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Errors != 0 {
		n += 1 + sovTempo(uint64(m.Errors))
	}
	return n
}

func (m *SpanMetricsSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpanCount != 0 {
		n += 1 + sovTempo(uint64(m.SpanCount))
	}
	if m.ErrorSpanCount != 0 {
		n += 1 + sovTempo(uint64(m.ErrorSpanCount))
	}
	if len(m.Series) > 0 {
		for _, e := range m.Series {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.P99 != 0 {
		n += 1 + sovTempo(uint64(m.P99))
	}
	if m.P95 != 0 {
		n += 1 + sovTempo(uint64(m.P95))
	}
	if m.P90 != 0 {
		n += 1 + sovTempo(uint64(m.P90))
	}
	if m.P50 != 0 {
		n += 1 + sovTempo(uint64(m.P50))
	}
	return n
}

func (m *SpanMetricsSummaryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Summaries) > 0 {
		for _, e := range m.Summaries {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *TraceQLStatic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTempo(uint64(m.Type))
	}
	if m.N != 0 {
		n += 1 + sovTempo(uint64(m.N))
	}
	if m.F != 0 {
		n += 9
	}
	l = len(m.S)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.B {
		n += 2
	}
	if m.D != 0 {
		n += 1 + sovTempo(uint64(m.D))
	}
	if m.Status != 0 {
		n += 1 + sovTempo(uint64(m.Status))
	}
	if m.Kind != 0 {
		n += 1 + sovTempo(uint64(m.Kind))
	}
	return n
}

func sovTempo(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTempo(x uint64) (n int) {
	return sovTempo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TraceByIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceByIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceByIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraceID = append(m.TraceID[:0], dAtA[iNdEx:postIndex]...)
			if m.TraceID == nil {
				m.TraceID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockStart", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockStart = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockEnd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockEnd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceByIDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceByIDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceByIDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Trace == nil {
				m.Trace = &Trace{}
			}
			if err := m.Trace.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &TraceByIDMetrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceByIDMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceByIDMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceByIDMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTempo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTempo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTempo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTempo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTempo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTempo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTempo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTempo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTempo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDurationMs", wireType)
			}
			m.MinDurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinDurationMs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDurationMs", wireType)
			}
			m.MaxDurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDurationMs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpansPerSpanSet", wireType)
			}
			m.SpansPerSpanSet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpansPerSpanSet |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchBlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchBlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchBlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SearchReq == nil {
				m.SearchReq = &SearchRequest{}
			}
			if err := m.SearchReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPage", wireType)
			}
			m.StartPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PagesToSearch", wireType)
			}
			m.PagesToSearch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PagesToSearch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPageSize", wireType)
			}
			m.IndexPageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexPageSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRecords", wireType)
			}
			m.TotalRecords = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRecords |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataEncoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataEncoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FooterSize", wireType)
			}
			m.FooterSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FooterSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DedicatedColumns = append(m.DedicatedColumns, &DedicatedColumn{})
			if err := m.DedicatedColumns[len(m.DedicatedColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DedicatedColumn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DedicatedColumn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DedicatedColumn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= DedicatedColumn_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			m.Scope = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scope |= DedicatedColumn_Scope(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Traces = append(m.Traces, &TraceSearchMetadata{})
			if err := m.Traces[len(m.Traces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &SearchMetrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceSearchMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceSearchMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceSearchMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootTraceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootTraceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimeUnixNano", wireType)
			}
			m.StartTimeUnixNano = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimeUnixNano |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationMs", wireType)
			}
			m.DurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurationMs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpanSet == nil {
				m.SpanSet = &SpanSet{}
			}
			if err := m.SpanSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpanSets = append(m.SpanSets, &SpanSet{})
			if err := m.SpanSets[len(m.SpanSets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, &Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Matched", wireType)
			}
			m.Matched = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Matched |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &v1.KeyValue{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Span) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Span: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Span: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpanID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimeUnixNano", wireType)
			}
			m.StartTimeUnixNano = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimeUnixNano |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationNanos", wireType)
			}
			m.DurationNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurationNanos |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &v1.KeyValue{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InspectedTraces", wireType)
			}
			m.InspectedTraces = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InspectedTraces |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InspectedBytes", wireType)
			}
			m.InspectedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InspectedBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBlocks", wireType)
			}
			m.TotalBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBlocks |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedJobs", wireType)
			}
			m.CompletedJobs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletedJobs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalJobs", wireType)
			}
			m.TotalJobs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalJobs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBlockBytes", wireType)
			}
			m.TotalBlockBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBlockBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scope = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagNames = append(m.TagNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagsV2Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagsV2Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagsV2Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scopes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scopes = append(m.Scopes, &SearchTagsV2Scope{})
			if err := m.Scopes[len(m.Scopes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagsV2Scope) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagsV2Scope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagsV2Scope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagValuesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagValuesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagValuesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagValuesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagValuesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagValuesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagValues = append(m.TagValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagValuesV2Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagValuesV2Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagValuesV2Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagValues = append(m.TagValues, &TagValue{})
			if err := m.TagValues[len(m.TagValues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Batches = append(m.Batches, &v11.ResourceSpans{})
			if err := m.Batches[len(m.Batches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v PushErrorReason
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTempo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= PushErrorReason(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ErrorsByTrace = append(m.ErrorsByTrace, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTempo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTempo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTempo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ErrorsByTrace) == 0 {
					m.ErrorsByTrace = make([]PushErrorReason, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v PushErrorReason
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTempo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= PushErrorReason(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ErrorsByTrace = append(m.ErrorsByTrace, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorsByTrace", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushBytesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushBytesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushBytesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traces", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v PreallocBytes
			m.Traces = append(m.Traces, v)
			if err := m.Traces[len(m.Traces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v PreallocBytes
			m.Ids = append(m.Ids, v)
			if err := m.Ids[len(m.Ids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v PreallocBytes
			m.SearchData = append(m.SearchData, v)
			if err := m.SearchData[len(m.SearchData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushSpansRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushSpansRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushSpansRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Batches = append(m.Batches, &v11.ResourceSpans{})
			if err := m.Batches[len(m.Batches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceBytes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceBytes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceBytes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traces", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Traces = append(m.Traces, make([]byte, postIndex-iNdEx))
			copy(m.Traces[len(m.Traces)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkSlice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkSlice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkSlice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Links = append(m.Links, &v11.Span_Link{})
			if err := m.Links[len(m.Links)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsSummaryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsSummaryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsSummaryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Estimated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Estimated = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanCount", wireType)
			}
			m.SpanCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpanCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorSpanCount", wireType)
			}
			m.ErrorSpanCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorSpanCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, &SpanMetrics{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawHistogram) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawHistogram: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawHistogram: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			m.Bucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &TraceQLStatic{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyHistogram", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatencyHistogram = append(m.LatencyHistogram, &RawHistogram{})
			if err := m.LatencyHistogram[len(m.LatencyHistogram)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Series = append(m.Series, &KeyValue{})
			if err := m.Series[len(m.Series)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			m.Errors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanCount", wireType)
			}
			m.SpanCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpanCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorSpanCount", wireType)
			}
			m.ErrorSpanCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorSpanCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Series = append(m.Series, &KeyValue{})
			if err := m.Series[len(m.Series)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field P99", wireType)
			}
			m.P99 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.P99 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field P95", wireType)
			}
			m.P95 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.P95 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field P90", wireType)
			}
			m.P90 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.P90 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field P50", wireType)
			}
			m.P50 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.P50 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsSummaryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsSummaryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsSummaryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summaries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summaries = append(m.Summaries, &SpanMetricsSummary{})
			if err := m.Summaries[len(m.Summaries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceQLStatic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceQLStatic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceQLStatic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			m.N = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.N |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.F = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.B = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field D", wireType)
			}
			m.D = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.D |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTempo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTempo
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTempo
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTempo
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTempo        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTempo          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTempo = fmt.Errorf("proto: unexpected end of group")
)

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/tempopb/tempo.proto

package tempopb

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	v1 "github.com/grafana/tempo/pkg/tempopb/common/v1"
	v11 "github.com/grafana/tempo/pkg/tempopb/trace/v1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type JobType int32

const (
	JobType_JOB_TYPE_UNSPECIFIED JobType = 0
	JobType_JOB_TYPE_COMPACTION  JobType = 1
)

var JobType_name = map[int32]string{
	0: "JOB_TYPE_UNSPECIFIED",
	1: "JOB_TYPE_COMPACTION",
}

var JobType_value = map[string]int32{
	"JOB_TYPE_UNSPECIFIED": 0,
	"JOB_TYPE_COMPACTION":  1,
}

func (x JobType) String() string {
	return proto.EnumName(JobType_name, int32(x))
}

func (JobType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{0}
}

type JobStatus int32

const (
	JobStatus_JOB_STATUS_UNSPECIFIED JobStatus = 0
	JobStatus_JOB_STATUS_SUCCEEDED   JobStatus = 1
	JobStatus_JOB_STATUS_FAILED      JobStatus = 2
)

var JobStatus_name = map[int32]string{
	0: "JOB_STATUS_UNSPECIFIED",
	1: "JOB_STATUS_SUCCEEDED",
	2: "JOB_STATUS_FAILED",
}

var JobStatus_value = map[string]int32{
	"JOB_STATUS_UNSPECIFIED": 0,
	"JOB_STATUS_SUCCEEDED":   1,
	"JOB_STATUS_FAILED":      2,
}

func (x JobStatus) String() string {
	return proto.EnumName(JobStatus_name, int32(x))
}

func (JobStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{1}
}

type PushErrorReason int32

const (
	PushErrorReason_NO_ERROR        PushErrorReason = 0
	PushErrorReason_MAX_LIVE_TRACES PushErrorReason = 1
	PushErrorReason_TRACE_TOO_LARGE PushErrorReason = 2
	PushErrorReason_UNKNOWN_ERROR   PushErrorReason = 3
)

var PushErrorReason_name = map[int32]string{
	0: "NO_ERROR",
	1: "MAX_LIVE_TRACES",
	2: "TRACE_TOO_LARGE",
	3: "UNKNOWN_ERROR",
}

var PushErrorReason_value = map[string]int32{
	"NO_ERROR":        0,
	"MAX_LIVE_TRACES": 1,
	"TRACE_TOO_LARGE": 2,
	"UNKNOWN_ERROR":   3,
}

func (x PushErrorReason) String() string {
	return proto.EnumName(PushErrorReason_name, int32(x))
}

func (PushErrorReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{2}
}

type TraceByIDResponse_Status int32

const (
	TraceByIDResponse_COMPLETE TraceByIDResponse_Status = 0
	TraceByIDResponse_PARTIAL  TraceByIDResponse_Status = 1
)

var TraceByIDResponse_Status_name = map[int32]string{
	0: "COMPLETE",
	1: "PARTIAL",
}

var TraceByIDResponse_Status_value = map[string]int32{
	"COMPLETE": 0,
	"PARTIAL":  1,
}

func (x TraceByIDResponse_Status) String() string {
	return proto.EnumName(TraceByIDResponse_Status_name, int32(x))
}

func (TraceByIDResponse_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{7, 0}
}

type DedicatedColumn_Scope int32

const (
	DedicatedColumn_SPAN     DedicatedColumn_Scope = 0
	DedicatedColumn_RESOURCE DedicatedColumn_Scope = 1
)

var DedicatedColumn_Scope_name = map[int32]string{
	0: "SPAN",
	1: "RESOURCE",
}

var DedicatedColumn_Scope_value = map[string]int32{
	"SPAN":     0,
	"RESOURCE": 1,
}

func (x DedicatedColumn_Scope) String() string {
	return proto.EnumName(DedicatedColumn_Scope_name, int32(x))
}

func (DedicatedColumn_Scope) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{11, 0}
}

type DedicatedColumn_Type int32

const (
	DedicatedColumn_STRING DedicatedColumn_Type = 0
)

var DedicatedColumn_Type_name = map[int32]string{
	0: "STRING",
}

var DedicatedColumn_Type_value = map[string]int32{
	"STRING": 0,
}

func (x DedicatedColumn_Type) String() string {
	return proto.EnumName(DedicatedColumn_Type_name, int32(x))
}

func (DedicatedColumn_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{11, 1}
}

// CompactionDetail contains fields specific to compaction jobs
type CompactionDetail struct {
	Input []string `protobuf:"bytes,1,rep,name=input,proto3" json:"input,omitempty"`
}

func (m *CompactionDetail) Reset()         { *m = CompactionDetail{} }
func (m *CompactionDetail) String() string { return proto.CompactTextString(m) }
func (*CompactionDetail) ProtoMessage()    {}
func (*CompactionDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{0}
}
func (m *CompactionDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactionDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactionDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactionDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactionDetail.Merge(m, src)
}
func (m *CompactionDetail) XXX_Size() int {
	return m.Size()
}
func (m *CompactionDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactionDetail.DiscardUnknown(m)
}

var xxx_messageInfo_CompactionDetail proto.InternalMessageInfo

func (m *CompactionDetail) GetInput() []string {
	if m != nil {
		return m.Input
	}
	return nil
}

// JobDetail contains the specific details for each job type
type JobDetail struct {
	Tenant string `protobuf:"bytes,1,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// oneof detail {
	Compaction *CompactionDetail `protobuf:"bytes,2,opt,name=compaction,proto3" json:"compaction,omitempty"`
}

func (m *JobDetail) Reset()         { *m = JobDetail{} }
func (m *JobDetail) String() string { return proto.CompactTextString(m) }
func (*JobDetail) ProtoMessage()    {}
func (*JobDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{1}
}
func (m *JobDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobDetail.Merge(m, src)
}
func (m *JobDetail) XXX_Size() int {
	return m.Size()
}
func (m *JobDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_JobDetail.DiscardUnknown(m)
}

var xxx_messageInfo_JobDetail proto.InternalMessageInfo

func (m *JobDetail) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *JobDetail) GetCompaction() *CompactionDetail {
	if m != nil {
		return m.Compaction
	}
	return nil
}

type NextJobRequest struct {
	WorkerId string  `protobuf:"bytes,1,opt,name=worker_id,json=workerId,proto3" json:"worker_id,omitempty"`
	Type     JobType `protobuf:"varint,2,opt,name=type,proto3,enum=tempopb.JobType" json:"type,omitempty"`
}

func (m *NextJobRequest) Reset()         { *m = NextJobRequest{} }
func (m *NextJobRequest) String() string { return proto.CompactTextString(m) }
func (*NextJobRequest) ProtoMessage()    {}
func (*NextJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{2}
}
func (m *NextJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NextJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NextJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NextJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NextJobRequest.Merge(m, src)
}
func (m *NextJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *NextJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NextJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NextJobRequest proto.InternalMessageInfo

func (m *NextJobRequest) GetWorkerId() string {
	if m != nil {
		return m.WorkerId
	}
	return ""
}

func (m *NextJobRequest) GetType() JobType {
	if m != nil {
		return m.Type
	}
	return JobType_JOB_TYPE_UNSPECIFIED
}

type NextJobResponse struct {
	JobId  string    `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	Type   JobType   `protobuf:"varint,2,opt,name=type,proto3,enum=tempopb.JobType" json:"type,omitempty"`
	Detail JobDetail `protobuf:"bytes,3,opt,name=detail,proto3" json:"detail"`
}

func (m *NextJobResponse) Reset()         { *m = NextJobResponse{} }
func (m *NextJobResponse) String() string { return proto.CompactTextString(m) }
func (*NextJobResponse) ProtoMessage()    {}
func (*NextJobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{3}
}
func (m *NextJobResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NextJobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NextJobResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NextJobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NextJobResponse.Merge(m, src)
}
func (m *NextJobResponse) XXX_Size() int {
	return m.Size()
}
func (m *NextJobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NextJobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NextJobResponse proto.InternalMessageInfo

func (m *NextJobResponse) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *NextJobResponse) GetType() JobType {
	if m != nil {
		return m.Type
	}
	return JobType_JOB_TYPE_UNSPECIFIED
}

func (m *NextJobResponse) GetDetail() JobDetail {
	if m != nil {
		return m.Detail
	}
	return JobDetail{}
}

type UpdateJobStatusRequest struct {
	JobId  string    `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	Status JobStatus `protobuf:"varint,2,opt,name=status,proto3,enum=tempopb.JobStatus" json:"status,omitempty"`
	Error  string    `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *UpdateJobStatusRequest) Reset()         { *m = UpdateJobStatusRequest{} }
func (m *UpdateJobStatusRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateJobStatusRequest) ProtoMessage()    {}
func (*UpdateJobStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{4}
}
func (m *UpdateJobStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateJobStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateJobStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateJobStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateJobStatusRequest.Merge(m, src)
}
func (m *UpdateJobStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateJobStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateJobStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateJobStatusRequest proto.InternalMessageInfo

func (m *UpdateJobStatusRequest) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *UpdateJobStatusRequest) GetStatus() JobStatus {
	if m != nil {
		return m.Status
	}
	return JobStatus_JOB_STATUS_UNSPECIFIED
}

func (m *UpdateJobStatusRequest) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type UpdateJobStatusResponse struct {
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *UpdateJobStatusResponse) Reset()         { *m = UpdateJobStatusResponse{} }
func (m *UpdateJobStatusResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateJobStatusResponse) ProtoMessage()    {}
func (*UpdateJobStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{5}
}
func (m *UpdateJobStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateJobStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateJobStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateJobStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateJobStatusResponse.Merge(m, src)
}
func (m *UpdateJobStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateJobStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateJobStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateJobStatusResponse proto.InternalMessageInfo

func (m *UpdateJobStatusResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

// Read
type TraceByIDRequest struct {
	TraceID           []byte `protobuf:"bytes,1,opt,name=traceID,proto3" json:"traceID,omitempty"`
	BlockStart        string `protobuf:"bytes,2,opt,name=blockStart,proto3" json:"blockStart,omitempty"`
	BlockEnd          string `protobuf:"bytes,3,opt,name=blockEnd,proto3" json:"blockEnd,omitempty"`
	QueryMode         string `protobuf:"bytes,5,opt,name=queryMode,proto3" json:"queryMode,omitempty"`
	AllowPartialTrace bool   `protobuf:"varint,6,opt,name=allowPartialTrace,proto3" json:"allowPartialTrace,omitempty"`
}

func (m *TraceByIDRequest) Reset()         { *m = TraceByIDRequest{} }
func (m *TraceByIDRequest) String() string { return proto.CompactTextString(m) }
func (*TraceByIDRequest) ProtoMessage()    {}
func (*TraceByIDRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{6}
}
func (m *TraceByIDRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceByIDRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceByIDRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceByIDRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceByIDRequest.Merge(m, src)
}
func (m *TraceByIDRequest) XXX_Size() int {
	return m.Size()
}
func (m *TraceByIDRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceByIDRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TraceByIDRequest proto.InternalMessageInfo

func (m *TraceByIDRequest) GetTraceID() []byte {
	if m != nil {
		return m.TraceID
	}
	return nil
}

func (m *TraceByIDRequest) GetBlockStart() string {
	if m != nil {
		return m.BlockStart
	}
	return ""
}

func (m *TraceByIDRequest) GetBlockEnd() string {
	if m != nil {
		return m.BlockEnd
	}
	return ""
}

func (m *TraceByIDRequest) GetQueryMode() string {
	if m != nil {
		return m.QueryMode
	}
	return ""
}

func (m *TraceByIDRequest) GetAllowPartialTrace() bool {
	if m != nil {
		return m.AllowPartialTrace
	}
	return false
}

type TraceByIDResponse struct {
	Trace   *Trace                   `protobuf:"bytes,1,opt,name=trace,proto3" json:"trace,omitempty"`
	Metrics *TraceByIDMetrics        `protobuf:"bytes,2,opt,name=metrics,proto3" json:"metrics,omitempty"`
	Status  TraceByIDResponse_Status `protobuf:"varint,3,opt,name=status,proto3,enum=tempopb.TraceByIDResponse_Status" json:"status,omitempty"`
	Message string                   `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *TraceByIDResponse) Reset()         { *m = TraceByIDResponse{} }
func (m *TraceByIDResponse) String() string { return proto.CompactTextString(m) }
func (*TraceByIDResponse) ProtoMessage()    {}
func (*TraceByIDResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{7}
}
func (m *TraceByIDResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceByIDResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceByIDResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceByIDResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceByIDResponse.Merge(m, src)
}
func (m *TraceByIDResponse) XXX_Size() int {
	return m.Size()
}
func (m *TraceByIDResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceByIDResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TraceByIDResponse proto.InternalMessageInfo

func (m *TraceByIDResponse) GetTrace() *Trace {
	if m != nil {
		return m.Trace
	}
	return nil
}

func (m *TraceByIDResponse) GetMetrics() *TraceByIDMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *TraceByIDResponse) GetStatus() TraceByIDResponse_Status {
	if m != nil {
		return m.Status
	}
	return TraceByIDResponse_COMPLETE
}

func (m *TraceByIDResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type TraceByIDMetrics struct {
	InspectedBytes uint64 `protobuf:"varint,1,opt,name=inspectedBytes,proto3" json:"inspectedBytes,omitempty"`
}

func (m *TraceByIDMetrics) Reset()         { *m = TraceByIDMetrics{} }
func (m *TraceByIDMetrics) String() string { return proto.CompactTextString(m) }
func (*TraceByIDMetrics) ProtoMessage()    {}
func (*TraceByIDMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{8}
}
func (m *TraceByIDMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceByIDMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceByIDMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceByIDMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceByIDMetrics.Merge(m, src)
}
func (m *TraceByIDMetrics) XXX_Size() int {
	return m.Size()
}
func (m *TraceByIDMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceByIDMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_TraceByIDMetrics proto.InternalMessageInfo

func (m *TraceByIDMetrics) GetInspectedBytes() uint64 {
	if m != nil {
		return m.InspectedBytes
	}
	return 0
}

// SearchRequest takes no block parameters and implies a "recent traces" search
type SearchRequest struct {
	// case insensitive partial match
	Tags          map[string]string `protobuf:"bytes,1,rep,name=Tags,proto3" json:"Tags" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MinDurationMs uint32            `protobuf:"varint,2,opt,name=MinDurationMs,proto3" json:"MinDurationMs,omitempty"`
	MaxDurationMs uint32            `protobuf:"varint,3,opt,name=MaxDurationMs,proto3" json:"MaxDurationMs,omitempty"`
	Limit         uint32            `protobuf:"varint,4,opt,name=Limit,proto3" json:"Limit,omitempty"`
	Start         uint32            `protobuf:"varint,5,opt,name=start,proto3" json:"start,omitempty"`
	End           uint32            `protobuf:"varint,6,opt,name=end,proto3" json:"end,omitempty"`
	// TraceQL query
	Query           string `protobuf:"bytes,8,opt,name=Query,proto3" json:"Query,omitempty"`
	SpansPerSpanSet uint32 `protobuf:"varint,9,opt,name=SpansPerSpanSet,proto3" json:"SpansPerSpanSet,omitempty"`
}

func (m *SearchRequest) Reset()         { *m = SearchRequest{} }
func (m *SearchRequest) String() string { return proto.CompactTextString(m) }
func (*SearchRequest) ProtoMessage()    {}
func (*SearchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{9}
}
func (m *SearchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchRequest.Merge(m, src)
}
func (m *SearchRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchRequest proto.InternalMessageInfo

func (m *SearchRequest) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *SearchRequest) GetMinDurationMs() uint32 {
	if m != nil {
		return m.MinDurationMs
	}
	return 0
}

func (m *SearchRequest) GetMaxDurationMs() uint32 {
	if m != nil {
		return m.MaxDurationMs
	}
	return 0
}

func (m *SearchRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SearchRequest) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SearchRequest) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *SearchRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SearchRequest) GetSpansPerSpanSet() uint32 {
	if m != nil {
		return m.SpansPerSpanSet
	}
	return 0
}

// SearchBlockRequest takes SearchRequest parameters as well as all information
// necessary to search a block in the backend.
type SearchBlockRequest struct {
	SearchReq        *SearchRequest     `protobuf:"bytes,1,opt,name=searchReq,proto3" json:"searchReq,omitempty"`
	BlockID          string             `protobuf:"bytes,2,opt,name=blockID,proto3" json:"blockID,omitempty"`
	StartPage        uint32             `protobuf:"varint,3,opt,name=startPage,proto3" json:"startPage,omitempty"`
	PagesToSearch    uint32             `protobuf:"varint,4,opt,name=pagesToSearch,proto3" json:"pagesToSearch,omitempty"`
	Encoding         string             `protobuf:"bytes,5,opt,name=encoding,proto3" json:"encoding,omitempty"`
	IndexPageSize    uint32             `protobuf:"varint,6,opt,name=indexPageSize,proto3" json:"indexPageSize,omitempty"`
	TotalRecords     uint32             `protobuf:"varint,7,opt,name=totalRecords,proto3" json:"totalRecords,omitempty"`
	DataEncoding     string             `protobuf:"bytes,8,opt,name=dataEncoding,proto3" json:"dataEncoding,omitempty"`
	Version          string             `protobuf:"bytes,9,opt,name=version,proto3" json:"version,omitempty"`
	Size_            uint64             `protobuf:"varint,10,opt,name=size,proto3" json:"size,omitempty"`
	FooterSize       uint32             `protobuf:"varint,11,opt,name=footerSize,proto3" json:"footerSize,omitempty"`
	DedicatedColumns []*DedicatedColumn `protobuf:"bytes,12,rep,name=dedicatedColumns,proto3" json:"dedicatedColumns,omitempty"`
}

func (m *SearchBlockRequest) Reset()         { *m = SearchBlockRequest{} }
func (m *SearchBlockRequest) String() string { return proto.CompactTextString(m) }
func (*SearchBlockRequest) ProtoMessage()    {}
func (*SearchBlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{10}
}
func (m *SearchBlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchBlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchBlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchBlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchBlockRequest.Merge(m, src)
}
func (m *SearchBlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchBlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchBlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchBlockRequest proto.InternalMessageInfo

func (m *SearchBlockRequest) GetSearchReq() *SearchRequest {
	if m != nil {
		return m.SearchReq
	}
	return nil
}

func (m *SearchBlockRequest) GetBlockID() string {
	if m != nil {
		return m.BlockID
	}
	return ""
}

func (m *SearchBlockRequest) GetStartPage() uint32 {
	if m != nil {
		return m.StartPage
	}
	return 0
}

func (m *SearchBlockRequest) GetPagesToSearch() uint32 {
	if m != nil {
		return m.PagesToSearch
	}
	return 0
}

func (m *SearchBlockRequest) GetEncoding() string {
	if m != nil {
		return m.Encoding
	}
	return ""
}

func (m *SearchBlockRequest) GetIndexPageSize() uint32 {
	if m != nil {
		return m.IndexPageSize
	}
	return 0
}

func (m *SearchBlockRequest) GetTotalRecords() uint32 {
	if m != nil {
		return m.TotalRecords
	}
	return 0
}

func (m *SearchBlockRequest) GetDataEncoding() string {
	if m != nil {
		return m.DataEncoding
	}
	return ""
}

func (m *SearchBlockRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *SearchBlockRequest) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *SearchBlockRequest) GetFooterSize() uint32 {
	if m != nil {
		return m.FooterSize
	}
	return 0
}

func (m *SearchBlockRequest) GetDedicatedColumns() []*DedicatedColumn {
	if m != nil {
		return m.DedicatedColumns
	}
	return nil
}

// Configuration for a single dedicated attribute column.
type DedicatedColumn struct {
	Scope DedicatedColumn_Scope `protobuf:"varint,3,opt,name=scope,proto3,enum=tempopb.DedicatedColumn_Scope" json:"scope,omitempty"`
	Name  string                `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Type  DedicatedColumn_Type  `protobuf:"varint,1,opt,name=type,proto3,enum=tempopb.DedicatedColumn_Type" json:"type,omitempty"`
}

func (m *DedicatedColumn) Reset()         { *m = DedicatedColumn{} }
func (m *DedicatedColumn) String() string { return proto.CompactTextString(m) }
func (*DedicatedColumn) ProtoMessage()    {}
func (*DedicatedColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{11}
}
func (m *DedicatedColumn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DedicatedColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DedicatedColumn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DedicatedColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DedicatedColumn.Merge(m, src)
}
func (m *DedicatedColumn) XXX_Size() int {
	return m.Size()
}
func (m *DedicatedColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_DedicatedColumn.DiscardUnknown(m)
}

var xxx_messageInfo_DedicatedColumn proto.InternalMessageInfo

func (m *DedicatedColumn) GetScope() DedicatedColumn_Scope {
	if m != nil {
		return m.Scope
	}
	return DedicatedColumn_SPAN
}

func (m *DedicatedColumn) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DedicatedColumn) GetType() DedicatedColumn_Type {
	if m != nil {
		return m.Type
	}
	return DedicatedColumn_STRING
}

type SearchResponse struct {
	Traces  []*TraceSearchMetadata `protobuf:"bytes,1,rep,name=traces,proto3" json:"traces,omitempty"`
	Metrics *SearchMetrics         `protobuf:"bytes,2,opt,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *SearchResponse) Reset()         { *m = SearchResponse{} }
func (m *SearchResponse) String() string { return proto.CompactTextString(m) }
func (*SearchResponse) ProtoMessage()    {}
func (*SearchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{12}
}
func (m *SearchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchResponse.Merge(m, src)
}
func (m *SearchResponse) XXX_Size() int {
	return m.Size()
}
func (m *SearchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SearchResponse proto.InternalMessageInfo

func (m *SearchResponse) GetTraces() []*TraceSearchMetadata {
	if m != nil {
		return m.Traces
	}
	return nil
}

func (m *SearchResponse) GetMetrics() *SearchMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type TraceSearchMetadata struct {
	TraceID           string                   `protobuf:"bytes,1,opt,name=traceID,proto3" json:"traceID,omitempty"`
	RootServiceName   string                   `protobuf:"bytes,2,opt,name=rootServiceName,proto3" json:"rootServiceName,omitempty"`
	RootTraceName     string                   `protobuf:"bytes,3,opt,name=rootTraceName,proto3" json:"rootTraceName,omitempty"`
	StartTimeUnixNano uint64                   `protobuf:"varint,4,opt,name=startTimeUnixNano,proto3" json:"startTimeUnixNano,omitempty"`
	DurationMs        uint32                   `protobuf:"varint,5,opt,name=durationMs,proto3" json:"durationMs,omitempty"`
	SpanSet           *SpanSet                 `protobuf:"bytes,6,opt,name=spanSet,proto3" json:"spanSet,omitempty"`
	SpanSets          []*SpanSet               `protobuf:"bytes,7,rep,name=spanSets,proto3" json:"spanSets,omitempty"`
	ServiceStats      map[string]*ServiceStats `protobuf:"bytes,8,rep,name=serviceStats,proto3" json:"serviceStats,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *TraceSearchMetadata) Reset()         { *m = TraceSearchMetadata{} }
func (m *TraceSearchMetadata) String() string { return proto.CompactTextString(m) }
func (*TraceSearchMetadata) ProtoMessage()    {}
func (*TraceSearchMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{13}
}
func (m *TraceSearchMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceSearchMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceSearchMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceSearchMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceSearchMetadata.Merge(m, src)
}
func (m *TraceSearchMetadata) XXX_Size() int {
	return m.Size()
}
func (m *TraceSearchMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceSearchMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_TraceSearchMetadata proto.InternalMessageInfo

func (m *TraceSearchMetadata) GetTraceID() string {
	if m != nil {
		return m.TraceID
	}
	return ""
}

func (m *TraceSearchMetadata) GetRootServiceName() string {
	if m != nil {
		return m.RootServiceName
	}
	return ""
}

func (m *TraceSearchMetadata) GetRootTraceName() string {
	if m != nil {
		return m.RootTraceName
	}
	return ""
}

func (m *TraceSearchMetadata) GetStartTimeUnixNano() uint64 {
	if m != nil {
		return m.StartTimeUnixNano
	}
	return 0
}

func (m *TraceSearchMetadata) GetDurationMs() uint32 {
	if m != nil {
		return m.DurationMs
	}
	return 0
}

func (m *TraceSearchMetadata) GetSpanSet() *SpanSet {
	if m != nil {
		return m.SpanSet
	}
	return nil
}

func (m *TraceSearchMetadata) GetSpanSets() []*SpanSet {
	if m != nil {
		return m.SpanSets
	}
	return nil
}

func (m *TraceSearchMetadata) GetServiceStats() map[string]*ServiceStats {
	if m != nil {
		return m.ServiceStats
	}
	return nil
}

type ServiceStats struct {
	SpanCount  uint32 `protobuf:"varint,1,opt,name=spanCount,proto3" json:"spanCount,omitempty"`
	ErrorCount uint32 `protobuf:"varint,2,opt,name=errorCount,proto3" json:"errorCount,omitempty"`
}

func (m *ServiceStats) Reset()         { *m = ServiceStats{} }
func (m *ServiceStats) String() string { return proto.CompactTextString(m) }
func (*ServiceStats) ProtoMessage()    {}
func (*ServiceStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{14}
}
func (m *ServiceStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceStats.Merge(m, src)
}
func (m *ServiceStats) XXX_Size() int {
	return m.Size()
}
func (m *ServiceStats) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceStats.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceStats proto.InternalMessageInfo

func (m *ServiceStats) GetSpanCount() uint32 {
	if m != nil {
		return m.SpanCount
	}
	return 0
}

func (m *ServiceStats) GetErrorCount() uint32 {
	if m != nil {
		return m.ErrorCount
	}
	return 0
}

type SpanSet struct {
	Spans      []*Span        `protobuf:"bytes,1,rep,name=spans,proto3" json:"spans,omitempty"`
	Matched    uint32         `protobuf:"varint,2,opt,name=matched,proto3" json:"matched,omitempty"`
	Attributes []*v1.KeyValue `protobuf:"bytes,3,rep,name=attributes,proto3" json:"attributes,omitempty"`
}

func (m *SpanSet) Reset()         { *m = SpanSet{} }
func (m *SpanSet) String() string { return proto.CompactTextString(m) }
func (*SpanSet) ProtoMessage()    {}
func (*SpanSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{15}
}
func (m *SpanSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanSet.Merge(m, src)
}
func (m *SpanSet) XXX_Size() int {
	return m.Size()
}
func (m *SpanSet) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanSet.DiscardUnknown(m)
}

var xxx_messageInfo_SpanSet proto.InternalMessageInfo

func (m *SpanSet) GetSpans() []*Span {
	if m != nil {
		return m.Spans
	}
	return nil
}

func (m *SpanSet) GetMatched() uint32 {
	if m != nil {
		return m.Matched
	}
	return 0
}

func (m *SpanSet) GetAttributes() []*v1.KeyValue {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type Span struct {
	SpanID            string         `protobuf:"bytes,1,opt,name=spanID,proto3" json:"spanID,omitempty"`
	Name              string         `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	StartTimeUnixNano uint64         `protobuf:"varint,3,opt,name=startTimeUnixNano,proto3" json:"startTimeUnixNano,omitempty"`
	DurationNanos     uint64         `protobuf:"varint,4,opt,name=durationNanos,proto3" json:"durationNanos,omitempty"`
	Attributes        []*v1.KeyValue `protobuf:"bytes,5,rep,name=attributes,proto3" json:"attributes,omitempty"`
}

func (m *Span) Reset()         { *m = Span{} }
func (m *Span) String() string { return proto.CompactTextString(m) }
func (*Span) ProtoMessage()    {}
func (*Span) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{16}
}
func (m *Span) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Span) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Span.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Span) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Span.Merge(m, src)
}
func (m *Span) XXX_Size() int {
	return m.Size()
}
func (m *Span) XXX_DiscardUnknown() {
	xxx_messageInfo_Span.DiscardUnknown(m)
}

var xxx_messageInfo_Span proto.InternalMessageInfo

func (m *Span) GetSpanID() string {
	if m != nil {
		return m.SpanID
	}
	return ""
}

func (m *Span) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Span) GetStartTimeUnixNano() uint64 {
	if m != nil {
		return m.StartTimeUnixNano
	}
	return 0
}

func (m *Span) GetDurationNanos() uint64 {
	if m != nil {
		return m.DurationNanos
	}
	return 0
}

func (m *Span) GetAttributes() []*v1.KeyValue {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type SearchMetrics struct {
	InspectedTraces uint32 `protobuf:"varint,1,opt,name=inspectedTraces,proto3" json:"inspectedTraces,omitempty"`
	InspectedBytes  uint64 `protobuf:"varint,2,opt,name=inspectedBytes,proto3" json:"inspectedBytes,omitempty"`
	TotalBlocks     uint32 `protobuf:"varint,3,opt,name=totalBlocks,proto3" json:"totalBlocks,omitempty"`
	CompletedJobs   uint32 `protobuf:"varint,4,opt,name=completedJobs,proto3" json:"completedJobs,omitempty"`
	TotalJobs       uint32 `protobuf:"varint,5,opt,name=totalJobs,proto3" json:"totalJobs,omitempty"`
	TotalBlockBytes uint64 `protobuf:"varint,6,opt,name=totalBlockBytes,proto3" json:"totalBlockBytes,omitempty"`
	InspectedSpans  uint64 `protobuf:"varint,7,opt,name=inspectedSpans,proto3" json:"inspectedSpans,omitempty"`
}

func (m *SearchMetrics) Reset()         { *m = SearchMetrics{} }
func (m *SearchMetrics) String() string { return proto.CompactTextString(m) }
func (*SearchMetrics) ProtoMessage()    {}
func (*SearchMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{17}
}
func (m *SearchMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchMetrics.Merge(m, src)
}
func (m *SearchMetrics) XXX_Size() int {
	return m.Size()
}
func (m *SearchMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_SearchMetrics proto.InternalMessageInfo

func (m *SearchMetrics) GetInspectedTraces() uint32 {
	if m != nil {
		return m.InspectedTraces
	}
	return 0
}

func (m *SearchMetrics) GetInspectedBytes() uint64 {
	if m != nil {
		return m.InspectedBytes
	}
	return 0
}

func (m *SearchMetrics) GetTotalBlocks() uint32 {
	if m != nil {
		return m.TotalBlocks
	}
	return 0
}

func (m *SearchMetrics) GetCompletedJobs() uint32 {
	if m != nil {
		return m.CompletedJobs
	}
	return 0
}

func (m *SearchMetrics) GetTotalJobs() uint32 {
	if m != nil {
		return m.TotalJobs
	}
	return 0
}

func (m *SearchMetrics) GetTotalBlockBytes() uint64 {
	if m != nil {
		return m.TotalBlockBytes
	}
	return 0
}

func (m *SearchMetrics) GetInspectedSpans() uint64 {
	if m != nil {
		return m.InspectedSpans
	}
	return 0
}

type SearchTagsRequest struct {
	Scope                string `protobuf:"bytes,1,opt,name=scope,proto3" json:"scope,omitempty"`
	Query                string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	Start                uint32 `protobuf:"varint,3,opt,name=start,proto3" json:"start,omitempty"`
	End                  uint32 `protobuf:"varint,4,opt,name=end,proto3" json:"end,omitempty"`
	MaxTagsPerScope      uint32 `protobuf:"varint,5,opt,name=maxTagsPerScope,proto3" json:"maxTagsPerScope,omitempty"`
	StaleValuesThreshold uint32 `protobuf:"varint,6,opt,name=staleValuesThreshold,proto3" json:"staleValuesThreshold,omitempty"`
}

func (m *SearchTagsRequest) Reset()         { *m = SearchTagsRequest{} }
func (m *SearchTagsRequest) String() string { return proto.CompactTextString(m) }
func (*SearchTagsRequest) ProtoMessage()    {}
func (*SearchTagsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{18}
}
func (m *SearchTagsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagsRequest.Merge(m, src)
}
func (m *SearchTagsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagsRequest proto.InternalMessageInfo

func (m *SearchTagsRequest) GetScope() string {
	if m != nil {
		return m.Scope
	}
	return ""
}

func (m *SearchTagsRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SearchTagsRequest) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SearchTagsRequest) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *SearchTagsRequest) GetMaxTagsPerScope() uint32 {
	if m != nil {
		return m.MaxTagsPerScope
	}
	return 0
}

func (m *SearchTagsRequest) GetStaleValuesThreshold() uint32 {
	if m != nil {
		return m.StaleValuesThreshold
	}
	return 0
}

// SearchTagsBlockRequest takes SearchTagsRequest parameters as well as all information necessary
// to search a block in the backend.
type SearchTagsBlockRequest struct {
	SearchReq           *SearchTagsRequest `protobuf:"bytes,1,opt,name=searchReq,proto3" json:"searchReq,omitempty"`
	BlockID             string             `protobuf:"bytes,2,opt,name=blockID,proto3" json:"blockID,omitempty"`
	StartPage           uint32             `protobuf:"varint,3,opt,name=startPage,proto3" json:"startPage,omitempty"`
	PagesToSearch       uint32             `protobuf:"varint,4,opt,name=pagesToSearch,proto3" json:"pagesToSearch,omitempty"`
	Encoding            string             `protobuf:"bytes,5,opt,name=encoding,proto3" json:"encoding,omitempty"`
	IndexPageSize       uint32             `protobuf:"varint,6,opt,name=indexPageSize,proto3" json:"indexPageSize,omitempty"`
	TotalRecords        uint32             `protobuf:"varint,7,opt,name=totalRecords,proto3" json:"totalRecords,omitempty"`
	DataEncoding        string             `protobuf:"bytes,8,opt,name=dataEncoding,proto3" json:"dataEncoding,omitempty"`
	Version             string             `protobuf:"bytes,9,opt,name=version,proto3" json:"version,omitempty"`
	Size_               uint64             `protobuf:"varint,10,opt,name=size,proto3" json:"size,omitempty"`
	FooterSize          uint32             `protobuf:"varint,11,opt,name=footerSize,proto3" json:"footerSize,omitempty"`
	DedicatedColumns    []*DedicatedColumn `protobuf:"bytes,12,rep,name=dedicatedColumns,proto3" json:"dedicatedColumns,omitempty"`
	MaxTagsPerScope     uint32             `protobuf:"varint,13,opt,name=maxTagsPerScope,proto3" json:"maxTagsPerScope,omitempty"`
	StaleValueThreshold uint32             `protobuf:"varint,14,opt,name=staleValueThreshold,proto3" json:"staleValueThreshold,omitempty"`
}

func (m *SearchTagsBlockRequest) Reset()         { *m = SearchTagsBlockRequest{} }
func (m *SearchTagsBlockRequest) String() string { return proto.CompactTextString(m) }
func (*SearchTagsBlockRequest) ProtoMessage()    {}
func (*SearchTagsBlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{19}
}
func (m *SearchTagsBlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagsBlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagsBlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagsBlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagsBlockRequest.Merge(m, src)
}
func (m *SearchTagsBlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagsBlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagsBlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagsBlockRequest proto.InternalMessageInfo

func (m *SearchTagsBlockRequest) GetSearchReq() *SearchTagsRequest {
	if m != nil {
		return m.SearchReq
	}
	return nil
}

func (m *SearchTagsBlockRequest) GetBlockID() string {
	if m != nil {
		return m.BlockID
	}
	return ""
}

func (m *SearchTagsBlockRequest) GetStartPage() uint32 {
	if m != nil {
		return m.StartPage
	}
	return 0
}

func (m *SearchTagsBlockRequest) GetPagesToSearch() uint32 {
	if m != nil {
		return m.PagesToSearch
	}
	return 0
}

func (m *SearchTagsBlockRequest) GetEncoding() string {
	if m != nil {
		return m.Encoding
	}
	return ""
}

func (m *SearchTagsBlockRequest) GetIndexPageSize() uint32 {
	if m != nil {
		return m.IndexPageSize
	}
	return 0
}

func (m *SearchTagsBlockRequest) GetTotalRecords() uint32 {
	if m != nil {
		return m.TotalRecords
	}
	return 0
}

func (m *SearchTagsBlockRequest) GetDataEncoding() string {
	if m != nil {
		return m.DataEncoding
	}
	return ""
}

func (m *SearchTagsBlockRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *SearchTagsBlockRequest) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *SearchTagsBlockRequest) GetFooterSize() uint32 {
	if m != nil {
		return m.FooterSize
	}
	return 0
}

func (m *SearchTagsBlockRequest) GetDedicatedColumns() []*DedicatedColumn {
	if m != nil {
		return m.DedicatedColumns
	}
	return nil
}

func (m *SearchTagsBlockRequest) GetMaxTagsPerScope() uint32 {
	if m != nil {
		return m.MaxTagsPerScope
	}
	return 0
}

func (m *SearchTagsBlockRequest) GetStaleValueThreshold() uint32 {
	if m != nil {
		return m.StaleValueThreshold
	}
	return 0
}

type SearchTagValuesBlockRequest struct {
	SearchReq        *SearchTagValuesRequest `protobuf:"bytes,1,opt,name=searchReq,proto3" json:"searchReq,omitempty"`
	BlockID          string                  `protobuf:"bytes,2,opt,name=blockID,proto3" json:"blockID,omitempty"`
	StartPage        uint32                  `protobuf:"varint,3,opt,name=startPage,proto3" json:"startPage,omitempty"`
	PagesToSearch    uint32                  `protobuf:"varint,4,opt,name=pagesToSearch,proto3" json:"pagesToSearch,omitempty"`
	Encoding         string                  `protobuf:"bytes,5,opt,name=encoding,proto3" json:"encoding,omitempty"`
	IndexPageSize    uint32                  `protobuf:"varint,6,opt,name=indexPageSize,proto3" json:"indexPageSize,omitempty"`
	TotalRecords     uint32                  `protobuf:"varint,7,opt,name=totalRecords,proto3" json:"totalRecords,omitempty"`
	DataEncoding     string                  `protobuf:"bytes,8,opt,name=dataEncoding,proto3" json:"dataEncoding,omitempty"`
	Version          string                  `protobuf:"bytes,9,opt,name=version,proto3" json:"version,omitempty"`
	Size_            uint64                  `protobuf:"varint,10,opt,name=size,proto3" json:"size,omitempty"`
	FooterSize       uint32                  `protobuf:"varint,11,opt,name=footerSize,proto3" json:"footerSize,omitempty"`
	DedicatedColumns []*DedicatedColumn      `protobuf:"bytes,12,rep,name=dedicatedColumns,proto3" json:"dedicatedColumns,omitempty"`
}

func (m *SearchTagValuesBlockRequest) Reset()         { *m = SearchTagValuesBlockRequest{} }
func (m *SearchTagValuesBlockRequest) String() string { return proto.CompactTextString(m) }
func (*SearchTagValuesBlockRequest) ProtoMessage()    {}
func (*SearchTagValuesBlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{20}
}
func (m *SearchTagValuesBlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagValuesBlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagValuesBlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagValuesBlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagValuesBlockRequest.Merge(m, src)
}
func (m *SearchTagValuesBlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagValuesBlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagValuesBlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagValuesBlockRequest proto.InternalMessageInfo

func (m *SearchTagValuesBlockRequest) GetSearchReq() *SearchTagValuesRequest {
	if m != nil {
		return m.SearchReq
	}
	return nil
}

func (m *SearchTagValuesBlockRequest) GetBlockID() string {
	if m != nil {
		return m.BlockID
	}
	return ""
}

func (m *SearchTagValuesBlockRequest) GetStartPage() uint32 {
	if m != nil {
		return m.StartPage
	}
	return 0
}

func (m *SearchTagValuesBlockRequest) GetPagesToSearch() uint32 {
	if m != nil {
		return m.PagesToSearch
	}
	return 0
}

func (m *SearchTagValuesBlockRequest) GetEncoding() string {
	if m != nil {
		return m.Encoding
	}
	return ""
}

func (m *SearchTagValuesBlockRequest) GetIndexPageSize() uint32 {
	if m != nil {
		return m.IndexPageSize
	}
	return 0
}

func (m *SearchTagValuesBlockRequest) GetTotalRecords() uint32 {
	if m != nil {
		return m.TotalRecords
	}
	return 0
}

func (m *SearchTagValuesBlockRequest) GetDataEncoding() string {
	if m != nil {
		return m.DataEncoding
	}
	return ""
}

func (m *SearchTagValuesBlockRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *SearchTagValuesBlockRequest) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *SearchTagValuesBlockRequest) GetFooterSize() uint32 {
	if m != nil {
		return m.FooterSize
	}
	return 0
}

func (m *SearchTagValuesBlockRequest) GetDedicatedColumns() []*DedicatedColumn {
	if m != nil {
		return m.DedicatedColumns
	}
	return nil
}

type SearchTagsResponse struct {
	TagNames []string         `protobuf:"bytes,1,rep,name=tagNames,proto3" json:"tagNames,omitempty"`
	Metrics  *MetadataMetrics `protobuf:"bytes,2,opt,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *SearchTagsResponse) Reset()         { *m = SearchTagsResponse{} }
func (m *SearchTagsResponse) String() string { return proto.CompactTextString(m) }
func (*SearchTagsResponse) ProtoMessage()    {}
func (*SearchTagsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{21}
}
func (m *SearchTagsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagsResponse.Merge(m, src)
}
func (m *SearchTagsResponse) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagsResponse proto.InternalMessageInfo

func (m *SearchTagsResponse) GetTagNames() []string {
	if m != nil {
		return m.TagNames
	}
	return nil
}

func (m *SearchTagsResponse) GetMetrics() *MetadataMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type SearchTagsV2Response struct {
	Scopes  []*SearchTagsV2Scope `protobuf:"bytes,1,rep,name=scopes,proto3" json:"scopes,omitempty"`
	Metrics *MetadataMetrics     `protobuf:"bytes,2,opt,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *SearchTagsV2Response) Reset()         { *m = SearchTagsV2Response{} }
func (m *SearchTagsV2Response) String() string { return proto.CompactTextString(m) }
func (*SearchTagsV2Response) ProtoMessage()    {}
func (*SearchTagsV2Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{22}
}
func (m *SearchTagsV2Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagsV2Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagsV2Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagsV2Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagsV2Response.Merge(m, src)
}
func (m *SearchTagsV2Response) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagsV2Response) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagsV2Response.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagsV2Response proto.InternalMessageInfo

func (m *SearchTagsV2Response) GetScopes() []*SearchTagsV2Scope {
	if m != nil {
		return m.Scopes
	}
	return nil
}

func (m *SearchTagsV2Response) GetMetrics() *MetadataMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type SearchTagsV2Scope struct {
	Name string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Tags []string `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty"`
}

func (m *SearchTagsV2Scope) Reset()         { *m = SearchTagsV2Scope{} }
func (m *SearchTagsV2Scope) String() string { return proto.CompactTextString(m) }
func (*SearchTagsV2Scope) ProtoMessage()    {}
func (*SearchTagsV2Scope) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{23}
}
func (m *SearchTagsV2Scope) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagsV2Scope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagsV2Scope.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagsV2Scope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagsV2Scope.Merge(m, src)
}
func (m *SearchTagsV2Scope) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagsV2Scope) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagsV2Scope.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagsV2Scope proto.InternalMessageInfo

func (m *SearchTagsV2Scope) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SearchTagsV2Scope) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type SearchTagValuesRequest struct {
	TagName             string `protobuf:"bytes,1,opt,name=tagName,proto3" json:"tagName,omitempty"`
	Query               string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	Start               uint32 `protobuf:"varint,4,opt,name=start,proto3" json:"start,omitempty"`
	End                 uint32 `protobuf:"varint,5,opt,name=end,proto3" json:"end,omitempty"`
	MaxTagValues        uint32 `protobuf:"varint,6,opt,name=maxTagValues,proto3" json:"maxTagValues,omitempty"`
	StaleValueThreshold uint32 `protobuf:"varint,7,opt,name=staleValueThreshold,proto3" json:"staleValueThreshold,omitempty"`
}

func (m *SearchTagValuesRequest) Reset()         { *m = SearchTagValuesRequest{} }
func (m *SearchTagValuesRequest) String() string { return proto.CompactTextString(m) }
func (*SearchTagValuesRequest) ProtoMessage()    {}
func (*SearchTagValuesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{24}
}
func (m *SearchTagValuesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagValuesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagValuesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagValuesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagValuesRequest.Merge(m, src)
}
func (m *SearchTagValuesRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagValuesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagValuesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagValuesRequest proto.InternalMessageInfo

func (m *SearchTagValuesRequest) GetTagName() string {
	if m != nil {
		return m.TagName
	}
	return ""
}

func (m *SearchTagValuesRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SearchTagValuesRequest) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SearchTagValuesRequest) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *SearchTagValuesRequest) GetMaxTagValues() uint32 {
	if m != nil {
		return m.MaxTagValues
	}
	return 0
}

func (m *SearchTagValuesRequest) GetStaleValueThreshold() uint32 {
	if m != nil {
		return m.StaleValueThreshold
	}
	return 0
}

type SearchTagValuesResponse struct {
	TagValues []string         `protobuf:"bytes,1,rep,name=tagValues,proto3" json:"tagValues,omitempty"`
	Metrics   *MetadataMetrics `protobuf:"bytes,2,opt,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *SearchTagValuesResponse) Reset()         { *m = SearchTagValuesResponse{} }
func (m *SearchTagValuesResponse) String() string { return proto.CompactTextString(m) }
func (*SearchTagValuesResponse) ProtoMessage()    {}
func (*SearchTagValuesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{25}
}
func (m *SearchTagValuesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagValuesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagValuesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagValuesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagValuesResponse.Merge(m, src)
}
func (m *SearchTagValuesResponse) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagValuesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagValuesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagValuesResponse proto.InternalMessageInfo

func (m *SearchTagValuesResponse) GetTagValues() []string {
	if m != nil {
		return m.TagValues
	}
	return nil
}

func (m *SearchTagValuesResponse) GetMetrics() *MetadataMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type TagValue struct {
	Type  string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *TagValue) Reset()         { *m = TagValue{} }
func (m *TagValue) String() string { return proto.CompactTextString(m) }
func (*TagValue) ProtoMessage()    {}
func (*TagValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{26}
}
func (m *TagValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagValue.Merge(m, src)
}
func (m *TagValue) XXX_Size() int {
	return m.Size()
}
func (m *TagValue) XXX_DiscardUnknown() {
	xxx_messageInfo_TagValue.DiscardUnknown(m)
}

var xxx_messageInfo_TagValue proto.InternalMessageInfo

func (m *TagValue) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *TagValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type SearchTagValuesV2Response struct {
	TagValues []*TagValue      `protobuf:"bytes,1,rep,name=tagValues,proto3" json:"tagValues,omitempty"`
	Metrics   *MetadataMetrics `protobuf:"bytes,2,opt,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *SearchTagValuesV2Response) Reset()         { *m = SearchTagValuesV2Response{} }
func (m *SearchTagValuesV2Response) String() string { return proto.CompactTextString(m) }
func (*SearchTagValuesV2Response) ProtoMessage()    {}
func (*SearchTagValuesV2Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{27}
}
func (m *SearchTagValuesV2Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagValuesV2Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagValuesV2Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagValuesV2Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagValuesV2Response.Merge(m, src)
}
func (m *SearchTagValuesV2Response) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagValuesV2Response) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagValuesV2Response.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagValuesV2Response proto.InternalMessageInfo

func (m *SearchTagValuesV2Response) GetTagValues() []*TagValue {
	if m != nil {
		return m.TagValues
	}
	return nil
}

func (m *SearchTagValuesV2Response) GetMetrics() *MetadataMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type MetadataMetrics struct {
	InspectedBytes  uint64 `protobuf:"varint,1,opt,name=inspectedBytes,proto3" json:"inspectedBytes,omitempty"`
	TotalJobs       uint32 `protobuf:"varint,2,opt,name=totalJobs,proto3" json:"totalJobs,omitempty"`
	CompletedJobs   uint32 `protobuf:"varint,3,opt,name=completedJobs,proto3" json:"completedJobs,omitempty"`
	TotalBlocks     uint32 `protobuf:"varint,4,opt,name=totalBlocks,proto3" json:"totalBlocks,omitempty"`
	TotalBlockBytes uint64 `protobuf:"varint,5,opt,name=totalBlockBytes,proto3" json:"totalBlockBytes,omitempty"`
}

func (m *MetadataMetrics) Reset()         { *m = MetadataMetrics{} }
func (m *MetadataMetrics) String() string { return proto.CompactTextString(m) }
func (*MetadataMetrics) ProtoMessage()    {}
func (*MetadataMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{28}
}
func (m *MetadataMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetadataMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetadataMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetadataMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetadataMetrics.Merge(m, src)
}
func (m *MetadataMetrics) XXX_Size() int {
	return m.Size()
}
func (m *MetadataMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_MetadataMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_MetadataMetrics proto.InternalMessageInfo

func (m *MetadataMetrics) GetInspectedBytes() uint64 {
	if m != nil {
		return m.InspectedBytes
	}
	return 0
}

func (m *MetadataMetrics) GetTotalJobs() uint32 {
	if m != nil {
		return m.TotalJobs
	}
	return 0
}

func (m *MetadataMetrics) GetCompletedJobs() uint32 {
	if m != nil {
		return m.CompletedJobs
	}
	return 0
}

func (m *MetadataMetrics) GetTotalBlocks() uint32 {
	if m != nil {
		return m.TotalBlocks
	}
	return 0
}

func (m *MetadataMetrics) GetTotalBlockBytes() uint64 {
	if m != nil {
		return m.TotalBlockBytes
	}
	return 0
}

type Trace struct {
	ResourceSpans []*v11.ResourceSpans `protobuf:"bytes,1,rep,name=resourceSpans,proto3" json:"resourceSpans,omitempty"`
}

func (m *Trace) Reset()         { *m = Trace{} }
func (m *Trace) String() string { return proto.CompactTextString(m) }
func (*Trace) ProtoMessage()    {}
func (*Trace) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{29}
}
func (m *Trace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Trace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Trace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trace.Merge(m, src)
}
func (m *Trace) XXX_Size() int {
	return m.Size()
}
func (m *Trace) XXX_DiscardUnknown() {
	xxx_messageInfo_Trace.DiscardUnknown(m)
}

var xxx_messageInfo_Trace proto.InternalMessageInfo

func (m *Trace) GetResourceSpans() []*v11.ResourceSpans {
	if m != nil {
		return m.ResourceSpans
	}
	return nil
}

// Write
type PushResponse struct {
	ErrorsByTrace []PushErrorReason `protobuf:"varint,1,rep,packed,name=errorsByTrace,proto3,enum=tempopb.PushErrorReason" json:"errorsByTrace,omitempty"`
}

func (m *PushResponse) Reset()         { *m = PushResponse{} }
func (m *PushResponse) String() string { return proto.CompactTextString(m) }
func (*PushResponse) ProtoMessage()    {}
func (*PushResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{30}
}
func (m *PushResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PushResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PushResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushResponse.Merge(m, src)
}
func (m *PushResponse) XXX_Size() int {
	return m.Size()
}
func (m *PushResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PushResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PushResponse proto.InternalMessageInfo

func (m *PushResponse) GetErrorsByTrace() []PushErrorReason {
	if m != nil {
		return m.ErrorsByTrace
	}
	return nil
}

// PushBytesRequest pushes slices of traces, ids and searchdata. Traces are
// encoded using the
//  current BatchDecoder in ./pkg/model
type PushBytesRequest struct {
	// pre-marshalled Traces. length must match ids
	Traces []PreallocBytes `protobuf:"bytes,2,rep,name=traces,proto3,customtype=PreallocBytes" json:"traces"`
	// trace ids. length must match traces
	Ids [][]byte `protobuf:"bytes,3,rep,name=ids,proto3" json:"ids,omitempty"`
	// indicates whether metrics generation should be skipped
	// for traces contained in this request.
	SkipMetricsGeneration bool `protobuf:"varint,5,opt,name=skipMetricsGeneration,proto3" json:"skipMetricsGeneration,omitempty"`
}

func (m *PushBytesRequest) Reset()         { *m = PushBytesRequest{} }
func (m *PushBytesRequest) String() string { return proto.CompactTextString(m) }
func (*PushBytesRequest) ProtoMessage()    {}
func (*PushBytesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{31}
}
func (m *PushBytesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushBytesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PushBytesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PushBytesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushBytesRequest.Merge(m, src)
}
func (m *PushBytesRequest) XXX_Size() int {
	return m.Size()
}
func (m *PushBytesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PushBytesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PushBytesRequest proto.InternalMessageInfo

func (m *PushBytesRequest) GetIds() [][]byte {
	if m != nil {
		return m.Ids
	}
	return nil
}

func (m *PushBytesRequest) GetSkipMetricsGeneration() bool {
	if m != nil {
		return m.SkipMetricsGeneration
	}
	return false
}

type PushSpansRequest struct {
	// just send entire OTel spans for now
	Batches []*v11.ResourceSpans `protobuf:"bytes,1,rep,name=batches,proto3" json:"batches,omitempty"`
	// indicates whether metrics generation should be skipped
	// for traces contained in this request.
	SkipMetricsGeneration bool `protobuf:"varint,2,opt,name=skipMetricsGeneration,proto3" json:"skipMetricsGeneration,omitempty"`
}

func (m *PushSpansRequest) Reset()         { *m = PushSpansRequest{} }
func (m *PushSpansRequest) String() string { return proto.CompactTextString(m) }
func (*PushSpansRequest) ProtoMessage()    {}
func (*PushSpansRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{32}
}
func (m *PushSpansRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushSpansRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PushSpansRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PushSpansRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushSpansRequest.Merge(m, src)
}
func (m *PushSpansRequest) XXX_Size() int {
	return m.Size()
}
func (m *PushSpansRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PushSpansRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PushSpansRequest proto.InternalMessageInfo

func (m *PushSpansRequest) GetBatches() []*v11.ResourceSpans {
	if m != nil {
		return m.Batches
	}
	return nil
}

func (m *PushSpansRequest) GetSkipMetricsGeneration() bool {
	if m != nil {
		return m.SkipMetricsGeneration
	}
	return false
}

type TraceBytes struct {
	// pre-marshalled Traces
	Traces [][]byte `protobuf:"bytes,1,rep,name=traces,proto3" json:"traces,omitempty"`
}

func (m *TraceBytes) Reset()         { *m = TraceBytes{} }
func (m *TraceBytes) String() string { return proto.CompactTextString(m) }
func (*TraceBytes) ProtoMessage()    {}
func (*TraceBytes) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{33}
}
func (m *TraceBytes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceBytes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceBytes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceBytes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceBytes.Merge(m, src)
}
func (m *TraceBytes) XXX_Size() int {
	return m.Size()
}
func (m *TraceBytes) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceBytes.DiscardUnknown(m)
}

var xxx_messageInfo_TraceBytes proto.InternalMessageInfo

func (m *TraceBytes) GetTraces() [][]byte {
	if m != nil {
		return m.Traces
	}
	return nil
}

// this message exists for marshalling/unmarshalling convenience to/from
// parquet. in parquet we proto encode links to a column. unfortunately you
// can't encode a slice directly so we use this wrapper to generate the required
// marshalling/unmarshalling functions.
type LinkSlice struct {
	Links []*v11.Span_Link `protobuf:"bytes,1,rep,name=links,proto3" json:"links,omitempty"`
}

func (m *LinkSlice) Reset()         { *m = LinkSlice{} }
func (m *LinkSlice) String() string { return proto.CompactTextString(m) }
func (*LinkSlice) ProtoMessage()    {}
func (*LinkSlice) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{34}
}
func (m *LinkSlice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkSlice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinkSlice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LinkSlice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkSlice.Merge(m, src)
}
func (m *LinkSlice) XXX_Size() int {
	return m.Size()
}
func (m *LinkSlice) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkSlice.DiscardUnknown(m)
}

var xxx_messageInfo_LinkSlice proto.InternalMessageInfo

func (m *LinkSlice) GetLinks() []*v11.Span_Link {
	if m != nil {
		return m.Links
	}
	return nil
}

type SpanMetricsRequest struct {
	Query   string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	GroupBy string `protobuf:"bytes,2,opt,name=groupBy,proto3" json:"groupBy,omitempty"`
	Limit   uint64 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	Start   uint32 `protobuf:"varint,4,opt,name=start,proto3" json:"start,omitempty"`
	End     uint32 `protobuf:"varint,5,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *SpanMetricsRequest) Reset()         { *m = SpanMetricsRequest{} }
func (m *SpanMetricsRequest) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsRequest) ProtoMessage()    {}
func (*SpanMetricsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{35}
}
func (m *SpanMetricsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsRequest.Merge(m, src)
}
func (m *SpanMetricsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsRequest proto.InternalMessageInfo

func (m *SpanMetricsRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SpanMetricsRequest) GetGroupBy() string {
	if m != nil {
		return m.GroupBy
	}
	return ""
}

func (m *SpanMetricsRequest) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SpanMetricsRequest) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SpanMetricsRequest) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

type SpanMetricsSummaryRequest struct {
	Query   string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	GroupBy string `protobuf:"bytes,2,opt,name=groupBy,proto3" json:"groupBy,omitempty"`
	Limit   uint64 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	Start   uint32 `protobuf:"varint,4,opt,name=start,proto3" json:"start,omitempty"`
	End     uint32 `protobuf:"varint,5,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *SpanMetricsSummaryRequest) Reset()         { *m = SpanMetricsSummaryRequest{} }
func (m *SpanMetricsSummaryRequest) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsSummaryRequest) ProtoMessage()    {}
func (*SpanMetricsSummaryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{36}
}
func (m *SpanMetricsSummaryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsSummaryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsSummaryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsSummaryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsSummaryRequest.Merge(m, src)
}
func (m *SpanMetricsSummaryRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsSummaryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsSummaryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsSummaryRequest proto.InternalMessageInfo

func (m *SpanMetricsSummaryRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SpanMetricsSummaryRequest) GetGroupBy() string {
	if m != nil {
		return m.GroupBy
	}
	return ""
}

func (m *SpanMetricsSummaryRequest) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SpanMetricsSummaryRequest) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SpanMetricsSummaryRequest) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

type SpanMetricsResponse struct {
	Estimated      bool           `protobuf:"varint,1,opt,name=estimated,proto3" json:"estimated,omitempty"`
	SpanCount      uint64         `protobuf:"varint,2,opt,name=spanCount,proto3" json:"spanCount,omitempty"`
	ErrorSpanCount uint64         `protobuf:"varint,3,opt,name=errorSpanCount,proto3" json:"errorSpanCount,omitempty"`
	Metrics        []*SpanMetrics `protobuf:"bytes,4,rep,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *SpanMetricsResponse) Reset()         { *m = SpanMetricsResponse{} }
func (m *SpanMetricsResponse) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsResponse) ProtoMessage()    {}
func (*SpanMetricsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{37}
}
func (m *SpanMetricsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsResponse.Merge(m, src)
}
func (m *SpanMetricsResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsResponse proto.InternalMessageInfo

func (m *SpanMetricsResponse) GetEstimated() bool {
	if m != nil {
		return m.Estimated
	}
	return false
}

func (m *SpanMetricsResponse) GetSpanCount() uint64 {
	if m != nil {
		return m.SpanCount
	}
	return 0
}

func (m *SpanMetricsResponse) GetErrorSpanCount() uint64 {
	if m != nil {
		return m.ErrorSpanCount
	}
	return 0
}

func (m *SpanMetricsResponse) GetMetrics() []*SpanMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type RawHistogram struct {
	Bucket uint64 `protobuf:"varint,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
	Count  uint64 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *RawHistogram) Reset()         { *m = RawHistogram{} }
func (m *RawHistogram) String() string { return proto.CompactTextString(m) }
func (*RawHistogram) ProtoMessage()    {}
func (*RawHistogram) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{38}
}
func (m *RawHistogram) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawHistogram) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawHistogram.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawHistogram) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawHistogram.Merge(m, src)
}
func (m *RawHistogram) XXX_Size() int {
	return m.Size()
}
func (m *RawHistogram) XXX_DiscardUnknown() {
	xxx_messageInfo_RawHistogram.DiscardUnknown(m)
}

var xxx_messageInfo_RawHistogram proto.InternalMessageInfo

func (m *RawHistogram) GetBucket() uint64 {
	if m != nil {
		return m.Bucket
	}
	return 0
}

func (m *RawHistogram) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type KeyValue struct {
	Key   string         `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value *TraceQLStatic `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *KeyValue) Reset()         { *m = KeyValue{} }
func (m *KeyValue) String() string { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()    {}
func (*KeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{39}
}
func (m *KeyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyValue.Merge(m, src)
}
func (m *KeyValue) XXX_Size() int {
	return m.Size()
}
func (m *KeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_KeyValue proto.InternalMessageInfo

func (m *KeyValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyValue) GetValue() *TraceQLStatic {
	if m != nil {
		return m.Value
	}
	return nil
}

type SpanMetrics struct {
	LatencyHistogram []*RawHistogram `protobuf:"bytes,1,rep,name=latency_histogram,json=latencyHistogram,proto3" json:"latency_histogram,omitempty"`
	Series           []*KeyValue     `protobuf:"bytes,2,rep,name=series,proto3" json:"series,omitempty"`
	Errors           uint64          `protobuf:"varint,3,opt,name=errors,proto3" json:"errors,omitempty"`
}

func (m *SpanMetrics) Reset()         { *m = SpanMetrics{} }
func (m *SpanMetrics) String() string { return proto.CompactTextString(m) }
func (*SpanMetrics) ProtoMessage()    {}
func (*SpanMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{40}
}
func (m *SpanMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetrics.Merge(m, src)
}
func (m *SpanMetrics) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetrics proto.InternalMessageInfo

func (m *SpanMetrics) GetLatencyHistogram() []*RawHistogram {
	if m != nil {
		return m.LatencyHistogram
	}
	return nil
}

func (m *SpanMetrics) GetSeries() []*KeyValue {
	if m != nil {
		return m.Series
	}
	return nil
}

func (m *SpanMetrics) GetErrors() uint64 {
	if m != nil {
		return m.Errors
	}
	return 0
}

type SpanMetricsSummary struct {
	SpanCount      uint64      `protobuf:"varint,1,opt,name=spanCount,proto3" json:"spanCount,omitempty"`
	ErrorSpanCount uint64      `protobuf:"varint,2,opt,name=errorSpanCount,proto3" json:"errorSpanCount,omitempty"`
	Series         []*KeyValue `protobuf:"bytes,3,rep,name=series,proto3" json:"series,omitempty"`
	P99            uint64      `protobuf:"varint,4,opt,name=p99,proto3" json:"p99,omitempty"`
	P95            uint64      `protobuf:"varint,5,opt,name=p95,proto3" json:"p95,omitempty"`
	P90            uint64      `protobuf:"varint,6,opt,name=p90,proto3" json:"p90,omitempty"`
	P50            uint64      `protobuf:"varint,7,opt,name=p50,proto3" json:"p50,omitempty"`
}

func (m *SpanMetricsSummary) Reset()         { *m = SpanMetricsSummary{} }
func (m *SpanMetricsSummary) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsSummary) ProtoMessage()    {}
func (*SpanMetricsSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{41}
}
func (m *SpanMetricsSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsSummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsSummary.Merge(m, src)
}
func (m *SpanMetricsSummary) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsSummary.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsSummary proto.InternalMessageInfo

func (m *SpanMetricsSummary) GetSpanCount() uint64 {
	if m != nil {
		return m.SpanCount
	}
	return 0
}

func (m *SpanMetricsSummary) GetErrorSpanCount() uint64 {
	if m != nil {
		return m.ErrorSpanCount
	}
	return 0
}

func (m *SpanMetricsSummary) GetSeries() []*KeyValue {
	if m != nil {
		return m.Series
	}
	return nil
}

func (m *SpanMetricsSummary) GetP99() uint64 {
	if m != nil {
		return m.P99
	}
	return 0
}

func (m *SpanMetricsSummary) GetP95() uint64 {
	if m != nil {
		return m.P95
	}
	return 0
}

func (m *SpanMetricsSummary) GetP90() uint64 {
	if m != nil {
		return m.P90
	}
	return 0
}

func (m *SpanMetricsSummary) GetP50() uint64 {
	if m != nil {
		return m.P50
	}
	return 0
}

type SpanMetricsSummaryResponse struct {
	Summaries []*SpanMetricsSummary `protobuf:"bytes,1,rep,name=summaries,proto3" json:"summaries,omitempty"`
}

func (m *SpanMetricsSummaryResponse) Reset()         { *m = SpanMetricsSummaryResponse{} }
func (m *SpanMetricsSummaryResponse) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsSummaryResponse) ProtoMessage()    {}
func (*SpanMetricsSummaryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{42}
}
func (m *SpanMetricsSummaryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsSummaryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsSummaryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsSummaryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsSummaryResponse.Merge(m, src)
}
func (m *SpanMetricsSummaryResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsSummaryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsSummaryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsSummaryResponse proto.InternalMessageInfo

func (m *SpanMetricsSummaryResponse) GetSummaries() []*SpanMetricsSummary {
	if m != nil {
		return m.Summaries
	}
	return nil
}

type TraceQLStatic struct {
	Type   int32   `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	N      int64   `protobuf:"varint,2,opt,name=n,proto3" json:"n,omitempty"`
	F      float64 `protobuf:"fixed64,3,opt,name=f,proto3" json:"f,omitempty"`
	S      string  `protobuf:"bytes,4,opt,name=s,proto3" json:"s,omitempty"`
	B      bool    `protobuf:"varint,5,opt,name=b,proto3" json:"b,omitempty"`
	D      uint64  `protobuf:"varint,6,opt,name=d,proto3" json:"d,omitempty"`
	Status int32   `protobuf:"varint,7,opt,name=status,proto3" json:"status,omitempty"`
	Kind   int32   `protobuf:"varint,8,opt,name=kind,proto3" json:"kind,omitempty"`
}

func (m *TraceQLStatic) Reset()         { *m = TraceQLStatic{} }
func (m *TraceQLStatic) String() string { return proto.CompactTextString(m) }
func (*TraceQLStatic) ProtoMessage()    {}
func (*TraceQLStatic) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{43}
}
func (m *TraceQLStatic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceQLStatic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceQLStatic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceQLStatic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceQLStatic.Merge(m, src)
}
func (m *TraceQLStatic) XXX_Size() int {
	return m.Size()
}
func (m *TraceQLStatic) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceQLStatic.DiscardUnknown(m)
}

var xxx_messageInfo_TraceQLStatic proto.InternalMessageInfo

func (m *TraceQLStatic) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TraceQLStatic) GetN() int64 {
	if m != nil {
		return m.N
	}
	return 0
}

func (m *TraceQLStatic) GetF() float64 {
	if m != nil {
		return m.F
	}
	return 0
}

func (m *TraceQLStatic) GetS() string {
	if m != nil {
		return m.S
	}
	return ""
}

func (m *TraceQLStatic) GetB() bool {
	if m != nil {
		return m.B
	}
	return false
}

func (m *TraceQLStatic) GetD() uint64 {
	if m != nil {
		return m.D
	}
	return 0
}

func (m *TraceQLStatic) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *TraceQLStatic) GetKind() int32 {
	if m != nil {
		return m.Kind
	}
	return 0
}

type SpanMetricsData struct {
	ResultType string               `protobuf:"bytes,1,opt,name=resultType,proto3" json:"resultType,omitempty"`
	Result     []*SpanMetricsResult `protobuf:"bytes,2,rep,name=result,proto3" json:"result,omitempty"`
}

func (m *SpanMetricsData) Reset()         { *m = SpanMetricsData{} }
func (m *SpanMetricsData) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsData) ProtoMessage()    {}
func (*SpanMetricsData) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{44}
}
func (m *SpanMetricsData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsData.Merge(m, src)
}
func (m *SpanMetricsData) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsData) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsData.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsData proto.InternalMessageInfo

func (m *SpanMetricsData) GetResultType() string {
	if m != nil {
		return m.ResultType
	}
	return ""
}

func (m *SpanMetricsData) GetResult() []*SpanMetricsResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type SpanMetricsResult struct {
	LabelName  string                    `protobuf:"bytes,1,opt,name=labelName,proto3" json:"labelName,omitempty"`
	LabelValue string                    `protobuf:"bytes,2,opt,name=labelValue,proto3" json:"labelValue,omitempty"`
	Ts         []*SpanMetricsResultPoint `protobuf:"bytes,3,rep,name=ts,proto3" json:"ts,omitempty"`
}

func (m *SpanMetricsResult) Reset()         { *m = SpanMetricsResult{} }
func (m *SpanMetricsResult) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsResult) ProtoMessage()    {}
func (*SpanMetricsResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{45}
}
func (m *SpanMetricsResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsResult.Merge(m, src)
}
func (m *SpanMetricsResult) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsResult.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsResult proto.InternalMessageInfo

func (m *SpanMetricsResult) GetLabelName() string {
	if m != nil {
		return m.LabelName
	}
	return ""
}

func (m *SpanMetricsResult) GetLabelValue() string {
	if m != nil {
		return m.LabelValue
	}
	return ""
}

func (m *SpanMetricsResult) GetTs() []*SpanMetricsResultPoint {
	if m != nil {
		return m.Ts
	}
	return nil
}

type SpanMetricsResultPoint struct {
	Time             uint32  `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	Val              float64 `protobuf:"fixed64,2,opt,name=val,proto3" json:"val,omitempty"`
	ExemplarTraceID  []byte  `protobuf:"bytes,3,opt,name=exemplarTraceID,proto3" json:"exemplarTraceID,omitempty"`
	ExemplarDuration uint64  `protobuf:"varint,4,opt,name=exemplarDuration,proto3" json:"exemplarDuration,omitempty"`
}

func (m *SpanMetricsResultPoint) Reset()         { *m = SpanMetricsResultPoint{} }
func (m *SpanMetricsResultPoint) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsResultPoint) ProtoMessage()    {}
func (*SpanMetricsResultPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{46}
}
func (m *SpanMetricsResultPoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsResultPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsResultPoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsResultPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsResultPoint.Merge(m, src)
}
func (m *SpanMetricsResultPoint) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsResultPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsResultPoint.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsResultPoint proto.InternalMessageInfo

func (m *SpanMetricsResultPoint) GetTime() uint32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *SpanMetricsResultPoint) GetVal() float64 {
	if m != nil {
		return m.Val
	}
	return 0
}

func (m *SpanMetricsResultPoint) GetExemplarTraceID() []byte {
	if m != nil {
		return m.ExemplarTraceID
	}
	return nil
}

func (m *SpanMetricsResultPoint) GetExemplarDuration() uint64 {
	if m != nil {
		return m.ExemplarDuration
	}
	return 0
}

type QueryInstantRequest struct {
	Query string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	Start uint64 `protobuf:"varint,2,opt,name=start,proto3" json:"start,omitempty"`
	End   uint64 `protobuf:"varint,3,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *QueryInstantRequest) Reset()         { *m = QueryInstantRequest{} }
func (m *QueryInstantRequest) String() string { return proto.CompactTextString(m) }
func (*QueryInstantRequest) ProtoMessage()    {}
func (*QueryInstantRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{47}
}
func (m *QueryInstantRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryInstantRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryInstantRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryInstantRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryInstantRequest.Merge(m, src)
}
func (m *QueryInstantRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryInstantRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryInstantRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryInstantRequest proto.InternalMessageInfo

func (m *QueryInstantRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *QueryInstantRequest) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *QueryInstantRequest) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

type QueryInstantResponse struct {
	Series  []*InstantSeries `protobuf:"bytes,1,rep,name=series,proto3" json:"series,omitempty"`
	Metrics *SearchMetrics   `protobuf:"bytes,2,opt,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *QueryInstantResponse) Reset()         { *m = QueryInstantResponse{} }
func (m *QueryInstantResponse) String() string { return proto.CompactTextString(m) }
func (*QueryInstantResponse) ProtoMessage()    {}
func (*QueryInstantResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{48}
}
func (m *QueryInstantResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryInstantResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryInstantResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryInstantResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryInstantResponse.Merge(m, src)
}
func (m *QueryInstantResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryInstantResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryInstantResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryInstantResponse proto.InternalMessageInfo

func (m *QueryInstantResponse) GetSeries() []*InstantSeries {
	if m != nil {
		return m.Series
	}
	return nil
}

func (m *QueryInstantResponse) GetMetrics() *SearchMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type InstantSeries struct {
	// Series labels containing name and value. Data-type aware.
	Labels []v1.KeyValue `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels"`
	Value  float64       `protobuf:"fixed64,2,opt,name=value,proto3" json:"value,omitempty"`
	// prom_labels are a flattened string-only version of the typed labels.
	// They are used internally and may differ from official prometheus conventions.
	PromLabels string `protobuf:"bytes,3,opt,name=prom_labels,json=promLabels,proto3" json:"prom_labels,omitempty"`
}

func (m *InstantSeries) Reset()         { *m = InstantSeries{} }
func (m *InstantSeries) String() string { return proto.CompactTextString(m) }
func (*InstantSeries) ProtoMessage()    {}
func (*InstantSeries) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{49}
}
func (m *InstantSeries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstantSeries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstantSeries.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstantSeries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstantSeries.Merge(m, src)
}
func (m *InstantSeries) XXX_Size() int {
	return m.Size()
}
func (m *InstantSeries) XXX_DiscardUnknown() {
	xxx_messageInfo_InstantSeries.DiscardUnknown(m)
}

var xxx_messageInfo_InstantSeries proto.InternalMessageInfo

func (m *InstantSeries) GetLabels() []v1.KeyValue {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *InstantSeries) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *InstantSeries) GetPromLabels() string {
	if m != nil {
		return m.PromLabels
	}
	return ""
}

type QueryRangeRequest struct {
	Query string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	Start uint64 `protobuf:"varint,2,opt,name=start,proto3" json:"start,omitempty"`
	End   uint64 `protobuf:"varint,3,opt,name=end,proto3" json:"end,omitempty"`
	Step  uint64 `protobuf:"varint,4,opt,name=step,proto3" json:"step,omitempty"`
	//uint32 shardID = 5; // removed
	//uint32 shardCount = 6; // removed
	QueryMode string `protobuf:"bytes,7,opt,name=queryMode,proto3" json:"queryMode,omitempty"`
	// New RF1 fields
	BlockID          string             `protobuf:"bytes,8,opt,name=blockID,proto3" json:"blockID,omitempty"`
	StartPage        uint32             `protobuf:"varint,9,opt,name=startPage,proto3" json:"startPage,omitempty"`
	PagesToSearch    uint32             `protobuf:"varint,10,opt,name=pagesToSearch,proto3" json:"pagesToSearch,omitempty"`
	Version          string             `protobuf:"bytes,11,opt,name=version,proto3" json:"version,omitempty"`
	Encoding         string             `protobuf:"bytes,12,opt,name=encoding,proto3" json:"encoding,omitempty"`
	Size_            uint64             `protobuf:"varint,13,opt,name=size,proto3" json:"size,omitempty"`
	FooterSize       uint32             `protobuf:"varint,14,opt,name=footerSize,proto3" json:"footerSize,omitempty"`
	DedicatedColumns []*DedicatedColumn `protobuf:"bytes,15,rep,name=dedicatedColumns,proto3" json:"dedicatedColumns,omitempty"`
	// Exemplars are optional and can be empty.
	Exemplars uint32 `protobuf:"varint,16,opt,name=exemplars,proto3" json:"exemplars,omitempty"`
}

func (m *QueryRangeRequest) Reset()         { *m = QueryRangeRequest{} }
func (m *QueryRangeRequest) String() string { return proto.CompactTextString(m) }
func (*QueryRangeRequest) ProtoMessage()    {}
func (*QueryRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{50}
}
func (m *QueryRangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRangeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRangeRequest.Merge(m, src)
}
func (m *QueryRangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRangeRequest proto.InternalMessageInfo

func (m *QueryRangeRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *QueryRangeRequest) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *QueryRangeRequest) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *QueryRangeRequest) GetStep() uint64 {
	if m != nil {
		return m.Step
	}
	return 0
}

func (m *QueryRangeRequest) GetQueryMode() string {
	if m != nil {
		return m.QueryMode
	}
	return ""
}

func (m *QueryRangeRequest) GetBlockID() string {
	if m != nil {
		return m.BlockID
	}
	return ""
}

func (m *QueryRangeRequest) GetStartPage() uint32 {
	if m != nil {
		return m.StartPage
	}
	return 0
}

func (m *QueryRangeRequest) GetPagesToSearch() uint32 {
	if m != nil {
		return m.PagesToSearch
	}
	return 0
}

func (m *QueryRangeRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *QueryRangeRequest) GetEncoding() string {
	if m != nil {
		return m.Encoding
	}
	return ""
}

func (m *QueryRangeRequest) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *QueryRangeRequest) GetFooterSize() uint32 {
	if m != nil {
		return m.FooterSize
	}
	return 0
}

func (m *QueryRangeRequest) GetDedicatedColumns() []*DedicatedColumn {
	if m != nil {
		return m.DedicatedColumns
	}
	return nil
}

func (m *QueryRangeRequest) GetExemplars() uint32 {
	if m != nil {
		return m.Exemplars
	}
	return 0
}

type QueryRangeResponse struct {
	Series  []*TimeSeries  `protobuf:"bytes,1,rep,name=series,proto3" json:"series,omitempty"`
	Metrics *SearchMetrics `protobuf:"bytes,2,opt,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *QueryRangeResponse) Reset()         { *m = QueryRangeResponse{} }
func (m *QueryRangeResponse) String() string { return proto.CompactTextString(m) }
func (*QueryRangeResponse) ProtoMessage()    {}
func (*QueryRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{51}
}
func (m *QueryRangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRangeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRangeResponse.Merge(m, src)
}
func (m *QueryRangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRangeResponse proto.InternalMessageInfo

func (m *QueryRangeResponse) GetSeries() []*TimeSeries {
	if m != nil {
		return m.Series
	}
	return nil
}

func (m *QueryRangeResponse) GetMetrics() *SearchMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type Exemplar struct {
	// Optional, can be empty.
	Labels      []v1.KeyValue `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels"`
	Value       float64       `protobuf:"fixed64,2,opt,name=value,proto3" json:"value,omitempty"`
	TimestampMs int64         `protobuf:"varint,3,opt,name=timestamp_ms,json=timestampMs,proto3" json:"timestamp_ms,omitempty"`
}

func (m *Exemplar) Reset()         { *m = Exemplar{} }
func (m *Exemplar) String() string { return proto.CompactTextString(m) }
func (*Exemplar) ProtoMessage()    {}
func (*Exemplar) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{52}
}
func (m *Exemplar) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Exemplar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Exemplar.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Exemplar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Exemplar.Merge(m, src)
}
func (m *Exemplar) XXX_Size() int {
	return m.Size()
}
func (m *Exemplar) XXX_DiscardUnknown() {
	xxx_messageInfo_Exemplar.DiscardUnknown(m)
}

var xxx_messageInfo_Exemplar proto.InternalMessageInfo

func (m *Exemplar) GetLabels() []v1.KeyValue {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Exemplar) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *Exemplar) GetTimestampMs() int64 {
	if m != nil {
		return m.TimestampMs
	}
	return 0
}

type Sample struct {
	// Fields order MUST match promql.FPoint so that we can cast types between them.
	TimestampMs int64   `protobuf:"varint,2,opt,name=timestamp_ms,json=timestampMs,proto3" json:"timestamp_ms,omitempty"`
	Value       float64 `protobuf:"fixed64,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Sample) Reset()         { *m = Sample{} }
func (m *Sample) String() string { return proto.CompactTextString(m) }
func (*Sample) ProtoMessage()    {}
func (*Sample) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{53}
}
func (m *Sample) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sample) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sample.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sample) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sample.Merge(m, src)
}
func (m *Sample) XXX_Size() int {
	return m.Size()
}
func (m *Sample) XXX_DiscardUnknown() {
	xxx_messageInfo_Sample.DiscardUnknown(m)
}

var xxx_messageInfo_Sample proto.InternalMessageInfo

func (m *Sample) GetTimestampMs() int64 {
	if m != nil {
		return m.TimestampMs
	}
	return 0
}

func (m *Sample) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type TimeSeries struct {
	// Series labels containing name and value. Data-type aware.
	Labels []v1.KeyValue `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels"`
	// Sorted by time, oldest sample first.
	Samples []Sample `protobuf:"bytes,2,rep,name=samples,proto3" json:"samples"`
	// prom_labels are a flattened string-only version of the typed labels.
	// They are used internally and may differ from official prometheus conventions.
	PromLabels string `protobuf:"bytes,3,opt,name=prom_labels,json=promLabels,proto3" json:"prom_labels,omitempty"`
	// Exemplars are optional and can be empty.
	// Sorted by time, oldest exemplar first.
	Exemplars []Exemplar `protobuf:"bytes,4,rep,name=exemplars,proto3" json:"exemplars"`
}

func (m *TimeSeries) Reset()         { *m = TimeSeries{} }
func (m *TimeSeries) String() string { return proto.CompactTextString(m) }
func (*TimeSeries) ProtoMessage()    {}
func (*TimeSeries) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{54}
}
func (m *TimeSeries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimeSeries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimeSeries.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimeSeries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeSeries.Merge(m, src)
}
func (m *TimeSeries) XXX_Size() int {
	return m.Size()
}
func (m *TimeSeries) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeSeries.DiscardUnknown(m)
}

var xxx_messageInfo_TimeSeries proto.InternalMessageInfo

func (m *TimeSeries) GetLabels() []v1.KeyValue {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *TimeSeries) GetSamples() []Sample {
	if m != nil {
		return m.Samples
	}
	return nil
}

func (m *TimeSeries) GetPromLabels() string {
	if m != nil {
		return m.PromLabels
	}
	return ""
}

func (m *TimeSeries) GetExemplars() []Exemplar {
	if m != nil {
		return m.Exemplars
	}
	return nil
}

func init() {
	proto.RegisterEnum("tempopb.JobType", JobType_name, JobType_value)
	proto.RegisterEnum("tempopb.JobStatus", JobStatus_name, JobStatus_value)
	proto.RegisterEnum("tempopb.PushErrorReason", PushErrorReason_name, PushErrorReason_value)
	proto.RegisterEnum("tempopb.TraceByIDResponse_Status", TraceByIDResponse_Status_name, TraceByIDResponse_Status_value)
	proto.RegisterEnum("tempopb.DedicatedColumn_Scope", DedicatedColumn_Scope_name, DedicatedColumn_Scope_value)
	proto.RegisterEnum("tempopb.DedicatedColumn_Type", DedicatedColumn_Type_name, DedicatedColumn_Type_value)
	proto.RegisterType((*CompactionDetail)(nil), "tempopb.CompactionDetail")
	proto.RegisterType((*JobDetail)(nil), "tempopb.JobDetail")
	proto.RegisterType((*NextJobRequest)(nil), "tempopb.NextJobRequest")
	proto.RegisterType((*NextJobResponse)(nil), "tempopb.NextJobResponse")
	proto.RegisterType((*UpdateJobStatusRequest)(nil), "tempopb.UpdateJobStatusRequest")
	proto.RegisterType((*UpdateJobStatusResponse)(nil), "tempopb.UpdateJobStatusResponse")
	proto.RegisterType((*TraceByIDRequest)(nil), "tempopb.TraceByIDRequest")
	proto.RegisterType((*TraceByIDResponse)(nil), "tempopb.TraceByIDResponse")
	proto.RegisterType((*TraceByIDMetrics)(nil), "tempopb.TraceByIDMetrics")
	proto.RegisterType((*SearchRequest)(nil), "tempopb.SearchRequest")
	proto.RegisterMapType((map[string]string)(nil), "tempopb.SearchRequest.TagsEntry")
	proto.RegisterType((*SearchBlockRequest)(nil), "tempopb.SearchBlockRequest")
	proto.RegisterType((*DedicatedColumn)(nil), "tempopb.DedicatedColumn")
	proto.RegisterType((*SearchResponse)(nil), "tempopb.SearchResponse")
	proto.RegisterType((*TraceSearchMetadata)(nil), "tempopb.TraceSearchMetadata")
	proto.RegisterMapType((map[string]*ServiceStats)(nil), "tempopb.TraceSearchMetadata.ServiceStatsEntry")
	proto.RegisterType((*ServiceStats)(nil), "tempopb.ServiceStats")
	proto.RegisterType((*SpanSet)(nil), "tempopb.SpanSet")
	proto.RegisterType((*Span)(nil), "tempopb.Span")
	proto.RegisterType((*SearchMetrics)(nil), "tempopb.SearchMetrics")
	proto.RegisterType((*SearchTagsRequest)(nil), "tempopb.SearchTagsRequest")
	proto.RegisterType((*SearchTagsBlockRequest)(nil), "tempopb.SearchTagsBlockRequest")
	proto.RegisterType((*SearchTagValuesBlockRequest)(nil), "tempopb.SearchTagValuesBlockRequest")
	proto.RegisterType((*SearchTagsResponse)(nil), "tempopb.SearchTagsResponse")
	proto.RegisterType((*SearchTagsV2Response)(nil), "tempopb.SearchTagsV2Response")
	proto.RegisterType((*SearchTagsV2Scope)(nil), "tempopb.SearchTagsV2Scope")
	proto.RegisterType((*SearchTagValuesRequest)(nil), "tempopb.SearchTagValuesRequest")
	proto.RegisterType((*SearchTagValuesResponse)(nil), "tempopb.SearchTagValuesResponse")
	proto.RegisterType((*TagValue)(nil), "tempopb.TagValue")
	proto.RegisterType((*SearchTagValuesV2Response)(nil), "tempopb.SearchTagValuesV2Response")
	proto.RegisterType((*MetadataMetrics)(nil), "tempopb.MetadataMetrics")
	proto.RegisterType((*Trace)(nil), "tempopb.Trace")
	proto.RegisterType((*PushResponse)(nil), "tempopb.PushResponse")
	proto.RegisterType((*PushBytesRequest)(nil), "tempopb.PushBytesRequest")
	proto.RegisterType((*PushSpansRequest)(nil), "tempopb.PushSpansRequest")
	proto.RegisterType((*TraceBytes)(nil), "tempopb.TraceBytes")
	proto.RegisterType((*LinkSlice)(nil), "tempopb.LinkSlice")
	proto.RegisterType((*SpanMetricsRequest)(nil), "tempopb.SpanMetricsRequest")
	proto.RegisterType((*SpanMetricsSummaryRequest)(nil), "tempopb.SpanMetricsSummaryRequest")
	proto.RegisterType((*SpanMetricsResponse)(nil), "tempopb.SpanMetricsResponse")
	proto.RegisterType((*RawHistogram)(nil), "tempopb.RawHistogram")
	proto.RegisterType((*KeyValue)(nil), "tempopb.KeyValue")
	proto.RegisterType((*SpanMetrics)(nil), "tempopb.SpanMetrics")
	proto.RegisterType((*SpanMetricsSummary)(nil), "tempopb.SpanMetricsSummary")
	proto.RegisterType((*SpanMetricsSummaryResponse)(nil), "tempopb.SpanMetricsSummaryResponse")
	proto.RegisterType((*TraceQLStatic)(nil), "tempopb.TraceQLStatic")
	proto.RegisterType((*SpanMetricsData)(nil), "tempopb.SpanMetricsData")
	proto.RegisterType((*SpanMetricsResult)(nil), "tempopb.SpanMetricsResult")
	proto.RegisterType((*SpanMetricsResultPoint)(nil), "tempopb.SpanMetricsResultPoint")
	proto.RegisterType((*QueryInstantRequest)(nil), "tempopb.QueryInstantRequest")
	proto.RegisterType((*QueryInstantResponse)(nil), "tempopb.QueryInstantResponse")
	proto.RegisterType((*InstantSeries)(nil), "tempopb.InstantSeries")
	proto.RegisterType((*QueryRangeRequest)(nil), "tempopb.QueryRangeRequest")
	proto.RegisterType((*QueryRangeResponse)(nil), "tempopb.QueryRangeResponse")
	proto.RegisterType((*Exemplar)(nil), "tempopb.Exemplar")
	proto.RegisterType((*Sample)(nil), "tempopb.Sample")
	proto.RegisterType((*TimeSeries)(nil), "tempopb.TimeSeries")
}

func init() { proto.RegisterFile("pkg/tempopb/tempo.proto", fileDescriptor_f22805646f4f62b6) }

var fileDescriptor_f22805646f4f62b6 = []byte{
	// 3317 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x3a, 0xcd, 0x6f, 0x1b, 0xc7,
	0xf5, 0x5a, 0xf1, 0xfb, 0x89, 0x94, 0xa8, 0x91, 0x2c, 0xd3, 0xb4, 0x23, 0x39, 0x1b, 0x23, 0xd0,
	0xcf, 0x49, 0x24, 0x99, 0x71, 0xf0, 0x8b, 0x9d, 0xfc, 0xf2, 0x83, 0x3e, 0x18, 0x47, 0x8e, 0x3e,
	0x98, 0x25, 0xad, 0xa4, 0x45, 0x00, 0x61, 0x49, 0x8e, 0xe5, 0x8d, 0xc8, 0x5d, 0x66, 0x77, 0xe9,
	0x48, 0x3d, 0x04, 0x69, 0x8b, 0x1e, 0x0a, 0xf4, 0xd0, 0x43, 0x7b, 0xe8, 0xad, 0x39, 0x15, 0xed,
	0xa5, 0x87, 0xf6, 0x3f, 0x28, 0x1a, 0xa4, 0x28, 0x5a, 0x04, 0xe8, 0x25, 0xe8, 0x21, 0x28, 0x92,
	0x43, 0xf3, 0x67, 0x14, 0xf3, 0x66, 0x66, 0x77, 0x76, 0xb9, 0x94, 0xed, 0xc4, 0x41, 0x73, 0xc8,
	0x89, 0x33, 0x6f, 0xde, 0xbc, 0x79, 0xef, 0xcd, 0xfb, 0x1c, 0x2e, 0x9c, 0x1f, 0x1c, 0x1f, 0xad,
	0xfa, 0xb4, 0x3f, 0x70, 0x06, 0x6d, 0xfe, 0xbb, 0x32, 0x70, 0x1d, 0xdf, 0x21, 0x39, 0x01, 0xac,
	0x2e, 0x74, 0x9c, 0x7e, 0xdf, 0xb1, 0x57, 0xef, 0x5f, 0x5b, 0xe5, 0x23, 0x8e, 0x50, 0x7d, 0xee,
	0xc8, 0xf2, 0xef, 0x0d, 0xdb, 0x2b, 0x1d, 0xa7, 0xbf, 0x7a, 0xe4, 0x1c, 0x39, 0xab, 0x08, 0x6e,
	0x0f, 0xef, 0xe2, 0x0c, 0x27, 0x38, 0x12, 0xe8, 0xf3, 0xbe, 0x6b, 0x76, 0x28, 0xa3, 0x82, 0x03,
	0x0e, 0xd5, 0x5f, 0x84, 0xf2, 0xa6, 0xd3, 0x1f, 0x98, 0x1d, 0xdf, 0x72, 0xec, 0x2d, 0xea, 0x9b,
	0x56, 0x8f, 0x54, 0x21, 0x63, 0xd9, 0x83, 0xa1, 0x5f, 0xd1, 0x2e, 0xa7, 0x96, 0x0b, 0x1b, 0xe9,
	0x8f, 0x3f, 0x5b, 0x9a, 0x30, 0x38, 0xe8, 0x66, 0xfe, 0xcb, 0x5f, 0x2f, 0x69, 0x5f, 0x7e, 0xb8,
	0xa4, 0xe9, 0x5d, 0x28, 0xdc, 0x76, 0xda, 0x62, 0xcb, 0x02, 0x64, 0x7d, 0x6a, 0x9b, 0x36, 0xdb,
	0xa3, 0x2d, 0x17, 0x0c, 0x31, 0x23, 0x37, 0x00, 0x3a, 0x01, 0xf9, 0xca, 0xe4, 0x65, 0x6d, 0x79,
	0xaa, 0x76, 0x61, 0x45, 0x48, 0xb6, 0x12, 0x3f, 0xd9, 0x50, 0x90, 0x6f, 0xa6, 0xd9, 0x49, 0x7a,
	0x13, 0xa6, 0xf7, 0xe8, 0x89, 0x7f, 0xdb, 0x69, 0x1b, 0xf4, 0xdd, 0x21, 0xf5, 0x7c, 0x72, 0x11,
	0x0a, 0xef, 0x39, 0xee, 0x31, 0x75, 0x0f, 0xad, 0xae, 0x38, 0x2d, 0xcf, 0x01, 0xdb, 0x5d, 0x72,
	0x05, 0xd2, 0xfe, 0xe9, 0x80, 0xe2, 0x49, 0xd3, 0xb5, 0x72, 0x70, 0xd2, 0x6d, 0xa7, 0xdd, 0x3a,
	0x1d, 0x50, 0x03, 0x57, 0xf5, 0x0f, 0x34, 0x98, 0x09, 0xa8, 0x7a, 0x03, 0xc7, 0xf6, 0x28, 0x39,
	0x07, 0xd9, 0x77, 0x9c, 0x76, 0x48, 0x33, 0xf3, 0x8e, 0xd3, 0x7e, 0x58, 0x82, 0x64, 0x0d, 0xb2,
	0x5d, 0x94, 0xa0, 0x92, 0x42, 0x11, 0x89, 0x8a, 0xc7, 0x65, 0x13, 0x6a, 0x14, 0x78, 0xfa, 0xbb,
	0xb0, 0x70, 0x67, 0xd0, 0x35, 0x7d, 0x7a, 0xdb, 0x69, 0x37, 0x7d, 0xd3, 0x1f, 0x7a, 0x52, 0xbe,
	0x31, 0x8c, 0x5c, 0x85, 0xac, 0x87, 0x78, 0x82, 0x95, 0xc8, 0x11, 0x82, 0x82, 0xc0, 0x20, 0xf3,
	0x90, 0xa1, 0xae, 0xeb, 0xb8, 0xc8, 0x4d, 0xc1, 0xe0, 0x13, 0xfd, 0x79, 0x38, 0x3f, 0x72, 0xa4,
	0x10, 0xbe, 0x02, 0x39, 0x6f, 0xd8, 0xe9, 0x50, 0xcf, 0xc3, 0x43, 0xf3, 0x86, 0x9c, 0xea, 0x7f,
	0xd4, 0xa0, 0xdc, 0x62, 0xf6, 0xb2, 0x71, 0xba, 0xbd, 0x25, 0x59, 0xac, 0x40, 0x0e, 0x6d, 0x68,
	0x7b, 0x0b, 0xd1, 0x8b, 0x86, 0x9c, 0x92, 0x45, 0x80, 0x76, 0xcf, 0xe9, 0x1c, 0x37, 0x7d, 0xd3,
	0xf5, 0x91, 0xd3, 0x82, 0xa1, 0x40, 0x48, 0x15, 0xf2, 0x38, 0xab, 0xdb, 0x5d, 0xc1, 0x5c, 0x30,
	0x27, 0x97, 0xa0, 0xf0, 0xee, 0x90, 0xba, 0xa7, 0xbb, 0x4e, 0x97, 0x56, 0x32, 0xb8, 0x18, 0x02,
	0xc8, 0xb3, 0x30, 0x6b, 0xf6, 0x7a, 0xce, 0x7b, 0x0d, 0xd3, 0xf5, 0x2d, 0xb3, 0x87, 0x3c, 0x55,
	0xb2, 0xc8, 0xec, 0xe8, 0x82, 0xfe, 0xa5, 0x06, 0xb3, 0x0a, 0xdb, 0x42, 0xcc, 0x2b, 0x90, 0x41,
	0x46, 0x91, 0xeb, 0xa9, 0xda, 0x74, 0xa0, 0x42, 0x44, 0x35, 0xf8, 0x22, 0x79, 0x1e, 0x72, 0x7d,
	0xea, 0xbb, 0x56, 0xc7, 0x1b, 0x31, 0xd8, 0x80, 0xe4, 0x2e, 0x47, 0x30, 0x24, 0x26, 0xb9, 0x11,
	0x5c, 0x4f, 0x0a, 0xaf, 0xe7, 0xc9, 0xd1, 0x3d, 0x92, 0x8d, 0x95, 0xd8, 0x6d, 0x55, 0xd8, 0x79,
	0x9e, 0x67, 0x1e, 0xd1, 0x4a, 0x1a, 0xa5, 0x96, 0x53, 0xfd, 0x29, 0xc8, 0x72, 0x5c, 0x52, 0x84,
	0xfc, 0xe6, 0xfe, 0x6e, 0x63, 0xa7, 0xde, 0xaa, 0x97, 0x27, 0xc8, 0x14, 0xe4, 0x1a, 0xeb, 0x46,
	0x6b, 0x7b, 0x7d, 0xa7, 0xac, 0xe9, 0x37, 0x95, 0x0b, 0x12, 0x6c, 0x91, 0xa7, 0x61, 0xda, 0xb2,
	0xbd, 0x01, 0xed, 0xf8, 0xb4, 0xbb, 0x71, 0xea, 0x53, 0x7e, 0xad, 0x69, 0x23, 0x06, 0xd5, 0xff,
	0x3e, 0x09, 0xa5, 0x26, 0x35, 0xdd, 0xce, 0x3d, 0x79, 0xb5, 0x37, 0x21, 0xdd, 0x32, 0x8f, 0x3c,
	0x74, 0xfd, 0xa9, 0xda, 0xe5, 0x40, 0x8a, 0x08, 0xd6, 0x0a, 0x43, 0xa9, 0xdb, 0xbe, 0x7b, 0x2a,
	0xac, 0x1a, 0xf7, 0x90, 0x2b, 0x50, 0xda, 0xb5, 0xec, 0xad, 0xa1, 0x6b, 0x32, 0x07, 0xde, 0xe5,
	0xea, 0x2b, 0x19, 0x51, 0x20, 0x62, 0x99, 0x27, 0x0a, 0x56, 0x4a, 0x60, 0xa9, 0x40, 0x66, 0xc2,
	0x3b, 0x56, 0xdf, 0xf2, 0x51, 0x25, 0x25, 0x83, 0x4f, 0x18, 0xd4, 0x43, 0xcb, 0xca, 0x70, 0x28,
	0x4e, 0x48, 0x19, 0x52, 0xd4, 0xee, 0xa2, 0x31, 0x94, 0x0c, 0x36, 0x64, 0x78, 0x6f, 0x30, 0xcb,
	0xa9, 0xe4, 0xb9, 0x03, 0xe0, 0x84, 0x2c, 0xc3, 0x4c, 0x73, 0x60, 0xda, 0x5e, 0x83, 0xba, 0xec,
	0xb7, 0x49, 0xfd, 0x4a, 0x01, 0xf7, 0xc4, 0xc1, 0xd5, 0xff, 0x85, 0x42, 0x20, 0x22, 0x23, 0x7f,
	0x4c, 0x4f, 0x85, 0x37, 0xb2, 0x21, 0x23, 0x7f, 0xdf, 0xec, 0x0d, 0xa9, 0x30, 0x70, 0x3e, 0xb9,
	0x39, 0xf9, 0xa2, 0xa6, 0x7f, 0x94, 0x02, 0xc2, 0x55, 0xb5, 0xc1, 0xcc, 0x5a, 0x6a, 0xf5, 0x3a,
	0x14, 0x3c, 0xa9, 0x40, 0x61, 0x7c, 0x0b, 0xc9, 0xaa, 0x35, 0x42, 0x44, 0x66, 0x18, 0xe8, 0x1c,
	0xdb, 0x5b, 0xe2, 0x20, 0x39, 0x65, 0xae, 0x82, 0xa2, 0x37, 0x98, 0xd1, 0x70, 0xfd, 0x85, 0x00,
	0xa6, 0xe1, 0x81, 0x79, 0x44, 0xbd, 0x96, 0xc3, 0x49, 0x0b, 0x1d, 0x46, 0x81, 0xcc, 0x15, 0xa9,
	0xdd, 0x71, 0xba, 0x96, 0x7d, 0x24, 0xbc, 0x2d, 0x98, 0x33, 0x0a, 0x96, 0xdd, 0xa5, 0x27, 0x8c,
	0x5c, 0xd3, 0xfa, 0x01, 0x15, 0xba, 0x8d, 0x02, 0x89, 0x0e, 0x45, 0xdf, 0xf1, 0xcd, 0x9e, 0x41,
	0x3b, 0x8e, 0xdb, 0xf5, 0x2a, 0x39, 0x44, 0x8a, 0xc0, 0x18, 0x4e, 0xd7, 0xf4, 0xcd, 0xba, 0x3c,
	0x89, 0x5f, 0x48, 0x04, 0xc6, 0xe4, 0xbc, 0x4f, 0x5d, 0x8f, 0x65, 0x88, 0x02, 0x97, 0x53, 0x4c,
	0x09, 0x81, 0xb4, 0xc7, 0x8e, 0x07, 0xb4, 0x5e, 0x1c, 0xb3, 0x10, 0x73, 0xd7, 0x71, 0x7c, 0xea,
	0x22, 0x63, 0x53, 0x78, 0xa6, 0x02, 0x21, 0x5b, 0x50, 0xee, 0xd2, 0xae, 0xd5, 0x31, 0x7d, 0xda,
	0xdd, 0x74, 0x7a, 0xc3, 0xbe, 0xed, 0x55, 0x8a, 0x68, 0xcd, 0x95, 0x40, 0xe5, 0x5b, 0x51, 0x04,
	0x63, 0x64, 0x87, 0xfe, 0x27, 0x0d, 0x66, 0x62, 0x58, 0xe4, 0x3a, 0x64, 0xbc, 0x8e, 0x33, 0xa0,
	0xc2, 0xc5, 0x17, 0xc7, 0x91, 0x5b, 0x69, 0x32, 0x2c, 0x83, 0x23, 0x33, 0x19, 0x6c, 0xb3, 0x2f,
	0x6d, 0x05, 0xc7, 0xe4, 0x9a, 0xc8, 0x2a, 0x1a, 0x12, 0x7a, 0x62, 0x2c, 0x21, 0x25, 0x67, 0x2d,
	0x41, 0x06, 0xc9, 0x92, 0x3c, 0xa4, 0x9b, 0x8d, 0xf5, 0xbd, 0xf2, 0x04, 0x0b, 0x0a, 0x46, 0xbd,
	0xb9, 0x7f, 0xc7, 0xd8, 0xac, 0x97, 0x35, 0x9d, 0x40, 0x9a, 0xa1, 0x13, 0x80, 0x6c, 0xb3, 0x65,
	0x6c, 0xef, 0xdd, 0x2a, 0x4f, 0xe8, 0x27, 0x30, 0x2d, 0xad, 0x4b, 0x84, 0xc0, 0xeb, 0x90, 0xc5,
	0x28, 0x27, 0x3d, 0xfc, 0x52, 0x34, 0x4e, 0x71, 0xec, 0x5d, 0xea, 0x9b, 0xec, 0x86, 0x0c, 0x81,
	0x4b, 0xd6, 0xe2, 0x21, 0x31, 0x6e, 0xbd, 0xf1, 0x78, 0xa8, 0xff, 0x23, 0x05, 0x73, 0x09, 0x14,
	0xe3, 0xa9, 0xa3, 0x10, 0xa6, 0x8e, 0x65, 0x98, 0x71, 0x1d, 0xc7, 0x6f, 0x52, 0xf7, 0xbe, 0xd5,
	0xa1, 0x7b, 0xa1, 0xca, 0xe2, 0x60, 0x66, 0x9d, 0x0c, 0x84, 0xe4, 0x11, 0x8f, 0x67, 0x92, 0x28,
	0x90, 0x25, 0x0c, 0x74, 0x89, 0x96, 0xd5, 0xa7, 0x77, 0x6c, 0xeb, 0x64, 0xcf, 0xb4, 0x1d, 0xf4,
	0x84, 0xb4, 0x31, 0xba, 0xc0, 0xac, 0xaa, 0x1b, 0x86, 0x24, 0x1e, 0x5e, 0x14, 0x08, 0xb9, 0x0a,
	0x39, 0x4f, 0xc4, 0x8c, 0x2c, 0x6a, 0x20, 0x2c, 0x05, 0x44, 0xd0, 0x30, 0x24, 0x02, 0x79, 0x16,
	0xf2, 0x62, 0xc8, 0x7c, 0x22, 0x95, 0x88, 0x1c, 0x60, 0x10, 0x03, 0x8a, 0x1e, 0x17, 0x8e, 0xc5,
	0x7a, 0xaf, 0x92, 0xc7, 0x1d, 0x2b, 0x67, 0xdd, 0xcb, 0x4a, 0x53, 0xd9, 0x80, 0x41, 0xca, 0x88,
	0xd0, 0xa8, 0x1e, 0xc0, 0xec, 0x08, 0x4a, 0x42, 0x1c, 0x7b, 0x46, 0x8d, 0x63, 0x53, 0xb5, 0x73,
	0xca, 0xa5, 0x86, 0x9b, 0xd5, 0xf0, 0xb6, 0x03, 0x45, 0x75, 0x09, 0xe3, 0xd0, 0xc0, 0xb4, 0x37,
	0x9d, 0xa1, 0xa8, 0xfc, 0x58, 0x1c, 0x92, 0x00, 0xa6, 0x53, 0xac, 0x3c, 0xf8, 0x32, 0x4f, 0x06,
	0x0a, 0x44, 0xff, 0x89, 0x06, 0x39, 0xa1, 0x0f, 0xf2, 0x14, 0x64, 0xd8, 0x46, 0x69, 0x96, 0xa5,
	0x88, 0xc2, 0x0c, 0xbe, 0x86, 0x99, 0xd2, 0xf4, 0x3b, 0xf7, 0x68, 0x57, 0x50, 0x93, 0x53, 0xf2,
	0x12, 0x80, 0xe9, 0xfb, 0xae, 0xd5, 0x1e, 0xb2, 0x64, 0x97, 0x42, 0x1a, 0x17, 0x03, 0x1a, 0xa2,
	0x6c, 0xbe, 0x7f, 0x6d, 0xe5, 0x75, 0x7a, 0x7a, 0xc0, 0xa4, 0x31, 0x14, 0x74, 0xe6, 0xeb, 0x69,
	0x76, 0x0c, 0xab, 0x62, 0xd9, 0x41, 0x81, 0x6d, 0x8a, 0x59, 0xa2, 0x0b, 0x27, 0x9a, 0x57, 0x6a,
	0x9c, 0x79, 0x5d, 0x81, 0x92, 0x34, 0x26, 0x36, 0xf7, 0x84, 0x21, 0x46, 0x81, 0x31, 0x29, 0x32,
	0x8f, 0x26, 0xc5, 0xaf, 0x82, 0x5c, 0x2e, 0xab, 0x80, 0x65, 0x98, 0x09, 0xf2, 0x7d, 0x4b, 0x3a,
	0x3d, 0xe6, 0xbb, 0x18, 0x38, 0xa1, 0x5e, 0x98, 0x4c, 0xaa, 0x17, 0xc8, 0x65, 0x98, 0xc2, 0xe8,
	0x8e, 0xc9, 0x4d, 0x66, 0x6e, 0x15, 0xc4, 0x04, 0x65, 0x35, 0x7c, 0x8f, 0xfa, 0xb4, 0x7b, 0xdb,
	0x69, 0x7b, 0x32, 0xf7, 0x44, 0x80, 0xcc, 0x6e, 0x70, 0x13, 0x62, 0x70, 0x67, 0x0b, 0x01, 0x8c,
	0xef, 0x90, 0x24, 0x67, 0x27, 0x8b, 0xec, 0xc4, 0xc1, 0x11, 0xbe, 0x31, 0x87, 0x63, 0x0e, 0x52,
	0xf9, 0x46, 0xa8, 0xfe, 0x67, 0x8d, 0x39, 0x04, 0xd3, 0x0d, 0x4b, 0xeb, 0x32, 0x2b, 0xcf, 0xcb,
	0x78, 0x2e, 0x0a, 0x6d, 0x1e, 0xaf, 0xe7, 0x21, 0x83, 0x55, 0xa7, 0x4c, 0xee, 0x38, 0x09, 0x2b,
	0x8f, 0x54, 0x42, 0xe5, 0x91, 0x0e, 0x2b, 0x8f, 0x65, 0x98, 0xe9, 0x9b, 0x27, 0xec, 0x14, 0x56,
	0x4e, 0x20, 0x75, 0x2e, 0x5f, 0x1c, 0x4c, 0x6a, 0x30, 0xef, 0xf9, 0x66, 0x8f, 0xe2, 0x4d, 0x7a,
	0xad, 0x7b, 0x2e, 0xf5, 0xee, 0x39, 0x3d, 0x59, 0xc6, 0x24, 0xae, 0xe9, 0xbf, 0x4b, 0xc3, 0x42,
	0x28, 0x47, 0xa4, 0xc4, 0x78, 0x71, 0xb4, 0xc4, 0xa8, 0xc6, 0x82, 0xb4, 0x22, 0xfb, 0x77, 0x65,
	0xc6, 0xb7, 0xa2, 0xcc, 0x48, 0x32, 0x97, 0x52, 0xb2, 0xb9, 0xac, 0xc1, 0x5c, 0x68, 0x12, 0xa1,
	0xb5, 0x4c, 0x23, 0x76, 0xd2, 0x92, 0xfe, 0x69, 0x0a, 0x2e, 0x06, 0x17, 0xcf, 0x2d, 0x29, 0x62,
	0x31, 0xff, 0x37, 0x6a, 0x31, 0x4b, 0xa3, 0x16, 0xc3, 0x37, 0x7e, 0x67, 0x36, 0xdf, 0xaa, 0xea,
	0xb4, 0x2b, 0xbb, 0x0c, 0xee, 0xd2, 0xa2, 0xb6, 0xab, 0x42, 0xde, 0x37, 0x8f, 0x58, 0xf1, 0xc3,
	0xd3, 0x68, 0xc1, 0x08, 0xe6, 0xa4, 0x16, 0xaf, 0xe0, 0xc2, 0xe3, 0x64, 0x55, 0x31, 0x52, 0xc3,
	0xbd, 0x0f, 0xf3, 0xe1, 0x29, 0x07, 0xb5, 0xe0, 0x9c, 0x1a, 0x64, 0x31, 0x54, 0xca, 0x64, 0x9d,
	0x14, 0x67, 0x0e, 0x6a, 0xbc, 0x08, 0x16, 0x98, 0x5f, 0xe9, 0xfc, 0x97, 0xd4, 0xa0, 0x2d, 0x08,
	0x06, 0xb9, 0x58, 0x53, 0x72, 0x31, 0x81, 0xb4, 0xcf, 0x9a, 0xd6, 0x49, 0x14, 0x1a, 0xc7, 0xfa,
	0x47, 0x9a, 0x12, 0x2a, 0x23, 0x46, 0x8c, 0x35, 0x28, 0xd7, 0x4b, 0x50, 0x83, 0xf2, 0xe9, 0x83,
	0x62, 0x7f, 0x3a, 0x21, 0xf6, 0x67, 0xc2, 0xd8, 0xaf, 0x43, 0x91, 0x7b, 0x2d, 0x3f, 0x4e, 0x98,
	0x65, 0x04, 0x36, 0xce, 0x8d, 0x73, 0xe3, 0xdd, 0xf8, 0x18, 0xce, 0x8f, 0xc8, 0x21, 0x2e, 0x82,
	0xa5, 0xd1, 0xe0, 0x34, 0x7e, 0xe3, 0x21, 0xe0, 0x2b, 0xa9, 0xfc, 0x3a, 0xe4, 0xe5, 0x31, 0xa8,
	0xd5, 0xd3, 0x20, 0x3b, 0xf2, 0x87, 0xae, 0xc4, 0xce, 0x57, 0xff, 0x40, 0x83, 0x0b, 0x31, 0x1e,
	0x15, 0x73, 0x59, 0x8d, 0x73, 0x39, 0x55, 0x9b, 0x0d, 0xab, 0x5b, 0xb1, 0xf2, 0x75, 0x19, 0xff,
	0x8b, 0x06, 0x33, 0xb1, 0xc5, 0x87, 0x7d, 0x05, 0x89, 0x56, 0x23, 0x93, 0xf1, 0x6a, 0x64, 0xa4,
	0xa2, 0x49, 0x25, 0x55, 0x34, 0xb1, 0xca, 0x28, 0x3d, 0x5a, 0x19, 0x25, 0x54, 0x35, 0x99, 0xc4,
	0xaa, 0x46, 0xdf, 0x83, 0x0c, 0xd6, 0x65, 0xa4, 0x0e, 0x25, 0x97, 0x7a, 0xce, 0xd0, 0xed, 0xd0,
	0xa6, 0x52, 0x1c, 0x87, 0x51, 0x9a, 0xbf, 0xe4, 0xde, 0xbf, 0xb6, 0x62, 0xa8, 0x68, 0x46, 0x74,
	0x97, 0xbe, 0x07, 0xc5, 0xc6, 0xd0, 0x0b, 0x7b, 0xc0, 0x57, 0xa0, 0x84, 0x55, 0xb8, 0xb7, 0x71,
	0xda, 0x12, 0xcf, 0x61, 0xa9, 0xe5, 0x69, 0x45, 0xcb, 0x0c, 0xbb, 0xce, 0x30, 0x0c, 0x6a, 0x7a,
	0x8e, 0x6d, 0x44, 0xd1, 0xf5, 0x9f, 0x6a, 0x50, 0x66, 0x28, 0xc8, 0xad, 0x74, 0xaa, 0xe7, 0x82,
	0xc6, 0x92, 0x79, 0x61, 0x71, 0xe3, 0xdc, 0xc7, 0x9f, 0x2d, 0x4d, 0xfc, 0xf3, 0xb3, 0xa5, 0x52,
	0xc3, 0xa5, 0x66, 0xaf, 0xe7, 0x74, 0x38, 0xb6, 0xec, 0x28, 0xcb, 0x90, 0xb2, 0xba, 0xbc, 0x52,
	0x2f, 0x1a, 0x6c, 0x48, 0xae, 0xc3, 0x39, 0xef, 0xd8, 0x1a, 0x88, 0xcb, 0xbb, 0x45, 0x6d, 0xca,
	0x4b, 0x63, 0xd4, 0x52, 0xde, 0x48, 0x5e, 0xd4, 0x7f, 0x2c, 0x78, 0xe1, 0x82, 0x0b, 0x5e, 0x6e,
	0x40, 0xae, 0x8d, 0x8d, 0xc1, 0x43, 0x6b, 0x4c, 0xe2, 0x8f, 0xe7, 0x62, 0xf2, 0x2c, 0x2e, 0xae,
	0x00, 0x88, 0x37, 0x38, 0x66, 0x4f, 0x0b, 0x91, 0x1e, 0xbb, 0x28, 0x65, 0xd6, 0x5f, 0x81, 0xc2,
	0x8e, 0x65, 0x1f, 0x37, 0x7b, 0x56, 0x87, 0x92, 0x6b, 0x90, 0xe9, 0x59, 0xf6, 0xb1, 0xe4, 0xf0,
	0xe2, 0x28, 0x87, 0x8c, 0xb3, 0x15, 0xb6, 0xc1, 0xe0, 0x98, 0xfa, 0x8f, 0x34, 0x20, 0x0c, 0x28,
	0x8d, 0x3f, 0x2c, 0x63, 0x79, 0xd0, 0xd2, 0xd4, 0xa0, 0x55, 0x81, 0xdc, 0x91, 0xeb, 0x0c, 0x07,
	0x1b, 0x32, 0x98, 0xc9, 0x29, 0xc3, 0xef, 0xe1, 0xd3, 0x1a, 0xef, 0x56, 0xf8, 0xe4, 0x61, 0x83,
	0x1c, 0xbb, 0xfc, 0x0b, 0x0a, 0x13, 0xcd, 0x61, 0xbf, 0x6f, 0xba, 0xa7, 0xff, 0x1d, 0x5e, 0x7e,
	0xab, 0xc1, 0x5c, 0x44, 0x21, 0x61, 0x5c, 0xa4, 0x9e, 0x6f, 0xf5, 0x59, 0xca, 0x14, 0x0f, 0xda,
	0x21, 0x20, 0xda, 0xb4, 0xf2, 0x3e, 0x47, 0x69, 0x5a, 0x9f, 0x86, 0x69, 0xb4, 0xf6, 0x66, 0x80,
	0xc2, 0x59, 0x8b, 0x41, 0xc9, 0x4a, 0x18, 0xa4, 0xd2, 0x78, 0x83, 0xf3, 0x91, 0x96, 0x75, 0x24,
	0x40, 0xbd, 0x0c, 0x45, 0xc3, 0x7c, 0xef, 0x35, 0xcb, 0xf3, 0x9d, 0x23, 0xd7, 0xec, 0x33, 0x23,
	0x69, 0x0f, 0x3b, 0xc7, 0xd4, 0x17, 0x41, 0x49, 0xcc, 0x98, 0xec, 0x1d, 0x85, 0x33, 0x3e, 0xd1,
	0x6f, 0x43, 0x5e, 0x36, 0x7d, 0x09, 0x7d, 0xfc, 0xb3, 0xd1, 0x3e, 0x7e, 0x21, 0xfa, 0x76, 0xf0,
	0xc6, 0x0e, 0x6b, 0xd6, 0xad, 0x8e, 0x8c, 0xd6, 0xbf, 0xd0, 0x60, 0x4a, 0x61, 0x91, 0x6c, 0xc0,
	0x6c, 0xcf, 0xf4, 0xa9, 0xdd, 0x39, 0x3d, 0xbc, 0x27, 0xd9, 0x13, 0x56, 0x19, 0xbe, 0x08, 0xa8,
	0xbc, 0x1b, 0x65, 0x81, 0x1f, 0x4a, 0xf3, 0x3f, 0x90, 0xf5, 0xa8, 0x6b, 0x09, 0xef, 0x57, 0x03,
	0x7c, 0xd0, 0xab, 0x0a, 0x04, 0x26, 0x38, 0x0f, 0x27, 0x42, 0xb1, 0x62, 0xa6, 0xff, 0x2d, 0x6a,
	0xdd, 0xc2, 0xb0, 0x46, 0x9f, 0x18, 0x1e, 0x70, 0x5b, 0x93, 0x89, 0xb7, 0x15, 0xf2, 0x97, 0x7a,
	0x10, 0x7f, 0x65, 0x48, 0x0d, 0x6e, 0xdc, 0x10, 0x0d, 0x3a, 0x1b, 0x72, 0xc8, 0x0b, 0x22, 0x5a,
	0xb3, 0x21, 0x87, 0xac, 0x89, 0xae, 0x94, 0x0d, 0x11, 0xf2, 0xc2, 0x9a, 0x68, 0x3f, 0xd9, 0x50,
	0x7f, 0x13, 0xaa, 0x49, 0x7e, 0x22, 0x4c, 0xf4, 0x06, 0x14, 0x3c, 0x04, 0x59, 0x74, 0x34, 0x04,
	0x24, 0xec, 0x0b, 0xb1, 0xf5, 0x5f, 0x6a, 0x50, 0x8a, 0x5c, 0x6c, 0x24, 0x53, 0x67, 0x44, 0xa6,
	0x2e, 0x82, 0xc6, 0x83, 0x56, 0xca, 0xd0, 0x6c, 0x36, 0xbb, 0x8b, 0xfa, 0xd6, 0x0c, 0xed, 0x2e,
	0x9b, 0x79, 0xe2, 0xbf, 0x06, 0xcd, 0x63, 0xb3, 0xb6, 0x08, 0xb2, 0x5a, 0x9b, 0xcd, 0xba, 0x42,
	0x30, 0xad, 0x8b, 0x2f, 0x22, 0xfc, 0x6f, 0x8d, 0x1c, 0xd2, 0x96, 0xff, 0x59, 0x10, 0x48, 0x1f,
	0x5b, 0x76, 0x17, 0x0b, 0xe6, 0x8c, 0x81, 0x63, 0x9d, 0xf2, 0xe7, 0x75, 0xc1, 0xf8, 0x96, 0xe9,
	0x9b, 0xac, 0x1a, 0x76, 0xa9, 0x37, 0xec, 0xf9, 0xad, 0xb0, 0x90, 0x50, 0x20, 0xac, 0x92, 0xe4,
	0x33, 0x61, 0x36, 0xd5, 0x44, 0x1f, 0x42, 0x0c, 0x43, 0x60, 0xb2, 0x28, 0x38, 0x3b, 0xb2, 0xca,
	0xcc, 0xa4, 0x67, 0xb6, 0x69, 0x4f, 0xa9, 0xea, 0x42, 0x00, 0xe3, 0x03, 0x27, 0x07, 0x4a, 0xed,
	0xa2, 0x40, 0xc8, 0x2a, 0x4c, 0xfa, 0xd2, 0x34, 0x96, 0xc6, 0xf3, 0xd0, 0x70, 0x2c, 0xdb, 0x37,
	0x26, 0x7d, 0x8f, 0xf9, 0xd0, 0x42, 0xf2, 0x32, 0x5e, 0x86, 0x25, 0x98, 0x28, 0x19, 0x38, 0x66,
	0xd6, 0x71, 0xdf, 0xec, 0xe1, 0xc1, 0x9a, 0xc1, 0x86, 0xac, 0x1a, 0xa0, 0x27, 0xb4, 0x3f, 0xe8,
	0x99, 0x6e, 0x4b, 0xbc, 0x87, 0xa6, 0xf0, 0xaf, 0xb4, 0x38, 0x98, 0x5c, 0x85, 0xb2, 0x04, 0xc9,
	0xff, 0x47, 0x84, 0x71, 0x8e, 0xc0, 0xf5, 0x26, 0xcc, 0xe1, 0x5f, 0x1d, 0xdb, 0xb6, 0xe7, 0x9b,
	0xb6, 0x7f, 0x76, 0x54, 0x0e, 0xa2, 0xac, 0x88, 0x34, 0x91, 0x28, 0xcb, 0x7d, 0x13, 0xa3, 0xec,
	0x09, 0xcc, 0x47, 0x89, 0x0a, 0x13, 0x5e, 0x09, 0x7c, 0x8a, 0xdb, 0x6f, 0x18, 0x76, 0x04, 0x66,
	0x13, 0x57, 0x03, 0xc7, 0x7a, 0xf4, 0x47, 0xe4, 0x1f, 0x6a, 0x50, 0x8a, 0xd0, 0x22, 0x37, 0x20,
	0x8b, 0xd7, 0x36, 0xea, 0x33, 0xa3, 0xaf, 0x63, 0xf2, 0x1f, 0x57, 0xbe, 0x21, 0x5a, 0xba, 0x6a,
	0x22, 0x18, 0x92, 0x25, 0x98, 0x1a, 0xb8, 0x4e, 0xff, 0x50, 0x50, 0xe5, 0x2f, 0xc9, 0xc0, 0x40,
	0x3b, 0x08, 0xd1, 0x7f, 0x9f, 0x82, 0x59, 0x14, 0xdf, 0x30, 0xed, 0x23, 0xfa, 0x58, 0x34, 0x8a,
	0x8d, 0xa3, 0x4f, 0x07, 0xe2, 0x1a, 0x71, 0x1c, 0xfd, 0xf7, 0x33, 0x17, 0xff, 0xf7, 0x53, 0x69,
	0xb6, 0xf3, 0x67, 0x34, 0xdb, 0x85, 0x07, 0x36, 0xdb, 0x90, 0xd4, 0x6c, 0x2b, 0x2d, 0xee, 0x54,
	0xb4, 0xc5, 0x55, 0xdb, 0xf0, 0x62, 0xac, 0x0d, 0x97, 0xed, 0x6f, 0x69, 0x6c, 0xfb, 0x3b, 0xfd,
	0x50, 0xed, 0xef, 0xcc, 0x23, 0xbf, 0x9a, 0xb0, 0xfc, 0x2e, 0x4c, 0xdf, 0xab, 0x94, 0xb9, 0xcc,
	0x01, 0x40, 0xf7, 0x80, 0xa8, 0x17, 0x26, 0xac, 0xf5, 0x99, 0x98, 0xb5, 0xce, 0x85, 0x49, 0xd2,
	0xea, 0xd3, 0xaf, 0x6d, 0xaa, 0xef, 0x43, 0xbe, 0x2e, 0x38, 0x78, 0xfc, 0x46, 0xfa, 0x24, 0x14,
	0x59, 0x18, 0xf1, 0x7c, 0xb3, 0x3f, 0x38, 0xec, 0x73, 0x2b, 0x4d, 0x19, 0x53, 0x01, 0x6c, 0xd7,
	0xd3, 0xd7, 0x21, 0xdb, 0x34, 0x59, 0x43, 0x32, 0x82, 0x3c, 0x39, 0x82, 0x1c, 0x9e, 0xa2, 0x29,
	0xa7, 0xe8, 0x9f, 0x68, 0x00, 0xa1, 0x2e, 0xbe, 0x8e, 0x14, 0xab, 0x90, 0xf3, 0x90, 0x19, 0x59,
	0x0e, 0xcc, 0x84, 0xea, 0x43, 0xb8, 0xc0, 0x97, 0x58, 0x0f, 0xf4, 0x42, 0xf2, 0x82, 0x7a, 0xe3,
	0xe9, 0x58, 0x0a, 0x97, 0x8a, 0x17, 0x54, 0x43, 0xcc, 0xab, 0x2f, 0x43, 0x4e, 0x7c, 0xa8, 0x41,
	0x2a, 0x30, 0x7f, 0x7b, 0x7f, 0xe3, 0xb0, 0xf5, 0xbd, 0x46, 0xfd, 0xf0, 0xce, 0x5e, 0xb3, 0x51,
	0xdf, 0xdc, 0x7e, 0x75, 0xbb, 0xbe, 0x55, 0x9e, 0x20, 0xe7, 0x61, 0x2e, 0x58, 0xd9, 0xdc, 0xdf,
	0x6d, 0xac, 0x6f, 0xb6, 0xb6, 0xf7, 0xf7, 0xca, 0xda, 0xd5, 0xb7, 0xf0, 0x0b, 0x17, 0xf1, 0x0f,
	0x7c, 0x15, 0x16, 0x18, 0x56, 0xb3, 0xb5, 0xde, 0xba, 0xd3, 0x8c, 0x51, 0x10, 0xb4, 0xc5, 0x5a,
	0xf3, 0xce, 0xe6, 0x66, 0xbd, 0xbe, 0x55, 0xdf, 0x2a, 0x6b, 0xe4, 0x1c, 0xcc, 0x2a, 0x2b, 0xaf,
	0xae, 0x6f, 0xef, 0xd4, 0xb7, 0xca, 0x93, 0x57, 0xdf, 0x86, 0x99, 0x58, 0x8f, 0x45, 0x8a, 0x90,
	0xdf, 0xdb, 0x3f, 0xac, 0x1b, 0xc6, 0xbe, 0x51, 0x9e, 0x20, 0x73, 0x30, 0xb3, 0xbb, 0xfe, 0xd6,
	0xe1, 0xce, 0xf6, 0x41, 0xfd, 0xb0, 0x65, 0xac, 0x6f, 0xd6, 0x9b, 0x65, 0x8d, 0x01, 0x71, 0x7c,
	0xd8, 0xda, 0xdf, 0x3f, 0xdc, 0x59, 0x37, 0x6e, 0xd5, 0xcb, 0x93, 0x64, 0x16, 0x4a, 0x77, 0xf6,
	0x5e, 0xdf, 0xdb, 0x7f, 0x73, 0x4f, 0x6c, 0x4e, 0xd5, 0x7e, 0xa6, 0x41, 0x96, 0x91, 0xa7, 0x2e,
	0xf9, 0x7f, 0x28, 0x04, 0x9d, 0x1a, 0xb9, 0x10, 0x69, 0xf0, 0xd4, 0xee, 0xad, 0x7a, 0x2e, 0xb2,
	0x24, 0x9d, 0x46, 0x9f, 0x20, 0xeb, 0x30, 0x15, 0x20, 0x1f, 0xd4, 0xbe, 0x0a, 0x89, 0xda, 0xbf,
	0x35, 0x28, 0x47, 0x5b, 0x26, 0x27, 0x60, 0x0c, 0xbb, 0xaf, 0x18, 0x55, 0xb5, 0x95, 0x1b, 0xcf,
	0xd8, 0x36, 0xc0, 0x2d, 0xea, 0xcb, 0x1a, 0xf6, 0x62, 0x72, 0xd2, 0xe6, 0x34, 0x2e, 0x8d, 0xc9,
	0xe8, 0x92, 0xd4, 0x2d, 0x80, 0x30, 0x60, 0x90, 0xb0, 0x06, 0x19, 0x09, 0xfb, 0xd5, 0x8b, 0x89,
	0x6b, 0x81, 0xa4, 0xbf, 0x49, 0x43, 0x8e, 0x2d, 0x58, 0xd4, 0x25, 0xaf, 0x41, 0xe9, 0x55, 0xcb,
	0xee, 0x06, 0x9f, 0x66, 0x90, 0x0b, 0x49, 0x5f, 0x84, 0x70, 0xb2, 0xd5, 0xf1, 0x1f, 0x8b, 0xe0,
	0x15, 0x14, 0xe5, 0x9f, 0xb8, 0x1d, 0x6a, 0xfb, 0x64, 0xcc, 0x97, 0x03, 0xd5, 0xf3, 0x23, 0xf0,
	0x80, 0x44, 0x1d, 0xa6, 0x94, 0xaf, 0x12, 0x54, 0x6d, 0x8d, 0x7c, 0xab, 0x70, 0x16, 0x99, 0x5b,
	0x00, 0xe1, 0x83, 0x1c, 0x39, 0xe3, 0xef, 0x85, 0xea, 0xc5, 0xc4, 0xb5, 0x80, 0xd0, 0xeb, 0x52,
	0x24, 0xfe, 0xb2, 0x77, 0x26, 0xa9, 0x27, 0x12, 0x5f, 0x17, 0x15, 0x62, 0x07, 0x30, 0x13, 0x7b,
	0x7c, 0x22, 0x0f, 0x7a, 0xc7, 0xae, 0x5e, 0x1e, 0x8f, 0x10, 0xd0, 0xfd, 0xbe, 0xf2, 0xfc, 0x28,
	0x1f, 0xb5, 0x1e, 0x4c, 0x59, 0x1f, 0x87, 0xa0, 0xf2, 0x5c, 0xfb, 0x6b, 0x1a, 0xca, 0x4d, 0xdf,
	0xa5, 0x66, 0xdf, 0xb2, 0x8f, 0xa4, 0xc9, 0xbc, 0x04, 0x59, 0x91, 0x90, 0x1f, 0xf5, 0x8a, 0xd7,
	0x34, 0xe6, 0x0f, 0x8f, 0xe5, 0x6e, 0xd6, 0x34, 0xb2, 0xfb, 0x18, 0x6f, 0x67, 0x4d, 0x23, 0x6f,
	0x7d, 0x33, 0xf7, 0xb3, 0xa6, 0x91, 0xb7, 0xbf, 0xb9, 0x1b, 0x5a, 0xd3, 0x48, 0x03, 0x66, 0x45,
	0xac, 0x78, 0x2c, 0xd1, 0x61, 0x4d, 0x23, 0x07, 0x30, 0xa7, 0x52, 0x14, 0xa5, 0x2d, 0xb9, 0x14,
	0xdd, 0x17, 0x2d, 0xde, 0x15, 0x0d, 0x27, 0x55, 0xe1, 0x8c, 0x6e, 0xed, 0x0f, 0x1a, 0xe4, 0x64,
	0x24, 0x3c, 0x4c, 0xec, 0xa2, 0xf5, 0xb3, 0x7a, 0x4b, 0x71, 0xd0, 0x53, 0x67, 0xe2, 0x3c, 0xfe,
	0x68, 0xf9, 0xa1, 0x06, 0xe5, 0x0d, 0xb3, 0x73, 0x4c, 0xed, 0x6e, 0xb3, 0x73, 0x8f, 0x76, 0x87,
	0x3d, 0xf4, 0x81, 0xf4, 0x1e, 0x3d, 0xf1, 0x49, 0x68, 0xe9, 0xd1, 0xcf, 0x3f, 0xab, 0x95, 0xd1,
	0x85, 0x80, 0xb5, 0x06, 0x14, 0x82, 0x2f, 0x1c, 0x15, 0x3b, 0x48, 0xfe, 0xd0, 0x52, 0xb1, 0xb1,
	0x31, 0x9f, 0x45, 0xea, 0x13, 0x1b, 0x95, 0x8f, 0x3f, 0x5f, 0xd4, 0x3e, 0xf9, 0x7c, 0x51, 0xfb,
	0xd7, 0xe7, 0x8b, 0xda, 0xcf, 0xbf, 0x58, 0x9c, 0xf8, 0xe4, 0x8b, 0xc5, 0x89, 0x4f, 0xbf, 0x58,
	0x9c, 0x68, 0x67, 0xf1, 0xfb, 0xd9, 0xe7, 0xff, 0x13, 0x00, 0x00, 0xff, 0xff, 0xa3, 0xb9, 0x72,
	0x9f, 0xc0, 0x2b, 0x00, 0x00,
}

func (this *CompactionDetail) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*CompactionDetail)
	if !ok {
		that2, ok := that.(CompactionDetail)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if len(this.Input) != len(that1.Input) {
		if len(this.Input) < len(that1.Input) {
			return -1
		}
		return 1
	}
	for i := range this.Input {
		if this.Input[i] != that1.Input[i] {
			if this.Input[i] < that1.Input[i] {
				return -1
			}
			return 1
		}
	}
	return 0
}
func (this *CompactionDetail) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CompactionDetail)
	if !ok {
		that2, ok := that.(CompactionDetail)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Input) != len(that1.Input) {
		return false
	}
	for i := range this.Input {
		if this.Input[i] != that1.Input[i] {
			return false
		}
	}
	return true
}
func (this *JobDetail) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JobDetail)
	if !ok {
		that2, ok := that.(JobDetail)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Tenant != that1.Tenant {
		return false
	}
	if !this.Compaction.Equal(that1.Compaction) {
		return false
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PusherClient is the client API for Pusher service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PusherClient interface {
	// different versions of PushBytes expect the trace data to be pushed in
	// different formats
	PushBytes(ctx context.Context, in *PushBytesRequest, opts ...grpc.CallOption) (*PushResponse, error)
	PushBytesV2(ctx context.Context, in *PushBytesRequest, opts ...grpc.CallOption) (*PushResponse, error)
}

type pusherClient struct {
	cc *grpc.ClientConn
}

func NewPusherClient(cc *grpc.ClientConn) PusherClient {
	return &pusherClient{cc}
}

func (c *pusherClient) PushBytes(ctx context.Context, in *PushBytesRequest, opts ...grpc.CallOption) (*PushResponse, error) {
	out := new(PushResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Pusher/PushBytes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pusherClient) PushBytesV2(ctx context.Context, in *PushBytesRequest, opts ...grpc.CallOption) (*PushResponse, error) {
	out := new(PushResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Pusher/PushBytesV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PusherServer is the server API for Pusher service.
type PusherServer interface {
	// different versions of PushBytes expect the trace data to be pushed in
	// different formats
	PushBytes(context.Context, *PushBytesRequest) (*PushResponse, error)
	PushBytesV2(context.Context, *PushBytesRequest) (*PushResponse, error)
}

// UnimplementedPusherServer can be embedded to have forward compatible implementations.
type UnimplementedPusherServer struct {
}

func (*UnimplementedPusherServer) PushBytes(ctx context.Context, req *PushBytesRequest) (*PushResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushBytes not implemented")
}
func (*UnimplementedPusherServer) PushBytesV2(ctx context.Context, req *PushBytesRequest) (*PushResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushBytesV2 not implemented")
}

func RegisterPusherServer(s *grpc.Server, srv PusherServer) {
	s.RegisterService(&_Pusher_serviceDesc, srv)
}

func _Pusher_PushBytes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushBytesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PusherServer).PushBytes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Pusher/PushBytes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PusherServer).PushBytes(ctx, req.(*PushBytesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pusher_PushBytesV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushBytesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PusherServer).PushBytesV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Pusher/PushBytesV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PusherServer).PushBytesV2(ctx, req.(*PushBytesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Pusher_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tempopb.Pusher",
	HandlerType: (*PusherServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PushBytes",
			Handler:    _Pusher_PushBytes_Handler,
		},
		{
			MethodName: "PushBytesV2",
			Handler:    _Pusher_PushBytesV2_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/tempopb/tempo.proto",
}

// MetricsGeneratorClient is the client API for MetricsGenerator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MetricsGeneratorClient interface {
	PushSpans(ctx context.Context, in *PushSpansRequest, opts ...grpc.CallOption) (*PushResponse, error)
	GetMetrics(ctx context.Context, in *SpanMetricsRequest, opts ...grpc.CallOption) (*SpanMetricsResponse, error)
	QueryRange(ctx context.Context, in *QueryRangeRequest, opts ...grpc.CallOption) (*QueryRangeResponse, error)
}

type metricsGeneratorClient struct {
	cc *grpc.ClientConn
}

func NewMetricsGeneratorClient(cc *grpc.ClientConn) MetricsGeneratorClient {
	return &metricsGeneratorClient{cc}
}

func (c *metricsGeneratorClient) PushSpans(ctx context.Context, in *PushSpansRequest, opts ...grpc.CallOption) (*PushResponse, error) {
	out := new(PushResponse)
	err := c.cc.Invoke(ctx, "/tempopb.MetricsGenerator/PushSpans", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metricsGeneratorClient) GetMetrics(ctx context.Context, in *SpanMetricsRequest, opts ...grpc.CallOption) (*SpanMetricsResponse, error) {
	out := new(SpanMetricsResponse)
	err := c.cc.Invoke(ctx, "/tempopb.MetricsGenerator/GetMetrics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metricsGeneratorClient) QueryRange(ctx context.Context, in *QueryRangeRequest, opts ...grpc.CallOption) (*QueryRangeResponse, error) {
	out := new(QueryRangeResponse)
	err := c.cc.Invoke(ctx, "/tempopb.MetricsGenerator/QueryRange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MetricsGeneratorServer is the server API for MetricsGenerator service.
type MetricsGeneratorServer interface {
	PushSpans(context.Context, *PushSpansRequest) (*PushResponse, error)
	GetMetrics(context.Context, *SpanMetricsRequest) (*SpanMetricsResponse, error)
	QueryRange(context.Context, *QueryRangeRequest) (*QueryRangeResponse, error)
}

// UnimplementedMetricsGeneratorServer can be embedded to have forward compatible implementations.
type UnimplementedMetricsGeneratorServer struct {
}

func (*UnimplementedMetricsGeneratorServer) PushSpans(ctx context.Context, req *PushSpansRequest) (*PushResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushSpans not implemented")
}
func (*UnimplementedMetricsGeneratorServer) GetMetrics(ctx context.Context, req *SpanMetricsRequest) (*SpanMetricsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMetrics not implemented")
}
func (*UnimplementedMetricsGeneratorServer) QueryRange(ctx context.Context, req *QueryRangeRequest) (*QueryRangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRange not implemented")
}

func RegisterMetricsGeneratorServer(s *grpc.Server, srv MetricsGeneratorServer) {
	s.RegisterService(&_MetricsGenerator_serviceDesc, srv)
}

func _MetricsGenerator_PushSpans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushSpansRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricsGeneratorServer).PushSpans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.MetricsGenerator/PushSpans",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricsGeneratorServer).PushSpans(ctx, req.(*PushSpansRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetricsGenerator_GetMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpanMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricsGeneratorServer).GetMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.MetricsGenerator/GetMetrics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricsGeneratorServer).GetMetrics(ctx, req.(*SpanMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetricsGenerator_QueryRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricsGeneratorServer).QueryRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.MetricsGenerator/QueryRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricsGeneratorServer).QueryRange(ctx, req.(*QueryRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MetricsGenerator_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tempopb.MetricsGenerator",
	HandlerType: (*MetricsGeneratorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PushSpans",
			Handler:    _MetricsGenerator_PushSpans_Handler,
		},
		{
			MethodName: "GetMetrics",
			Handler:    _MetricsGenerator_GetMetrics_Handler,
		},
		{
			MethodName: "QueryRange",
			Handler:    _MetricsGenerator_QueryRange_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/tempopb/tempo.proto",
}

// QuerierClient is the client API for Querier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QuerierClient interface {
	FindTraceByID(ctx context.Context, in *TraceByIDRequest, opts ...grpc.CallOption) (*TraceByIDResponse, error)
	SearchRecent(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	SearchBlock(ctx context.Context, in *SearchBlockRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	SearchTags(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (*SearchTagsResponse, error)
	SearchTagsV2(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (*SearchTagsV2Response, error)
	SearchTagValues(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (*SearchTagValuesResponse, error)
	SearchTagValuesV2(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (*SearchTagValuesV2Response, error)
}

type querierClient struct {
	cc *grpc.ClientConn
}

func NewQuerierClient(cc *grpc.ClientConn) QuerierClient {
	return &querierClient{cc}
}

func (c *querierClient) FindTraceByID(ctx context.Context, in *TraceByIDRequest, opts ...grpc.CallOption) (*TraceByIDResponse, error) {
	out := new(TraceByIDResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/FindTraceByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchRecent(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	out := new(SearchResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchRecent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchBlock(ctx context.Context, in *SearchBlockRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	out := new(SearchResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchTags(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (*SearchTagsResponse, error) {
	out := new(SearchTagsResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchTagsV2(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (*SearchTagsV2Response, error) {
	out := new(SearchTagsV2Response)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchTagsV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchTagValues(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (*SearchTagValuesResponse, error) {
	out := new(SearchTagValuesResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchTagValues", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchTagValuesV2(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (*SearchTagValuesV2Response, error) {
	out := new(SearchTagValuesV2Response)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchTagValuesV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QuerierServer is the server API for Querier service.
type QuerierServer interface {
	FindTraceByID(context.Context, *TraceByIDRequest) (*TraceByIDResponse, error)
	SearchRecent(context.Context, *SearchRequest) (*SearchResponse, error)
	SearchBlock(context.Context, *SearchBlockRequest) (*SearchResponse, error)
	SearchTags(context.Context, *SearchTagsRequest) (*SearchTagsResponse, error)
	SearchTagsV2(context.Context, *SearchTagsRequest) (*SearchTagsV2Response, error)
	SearchTagValues(context.Context, *SearchTagValuesRequest) (*SearchTagValuesResponse, error)
	SearchTagValuesV2(context.Context, *SearchTagValuesRequest) (*SearchTagValuesV2Response, error)
}

// UnimplementedQuerierServer can be embedded to have forward compatible implementations.
type UnimplementedQuerierServer struct {
}

func (*UnimplementedQuerierServer) FindTraceByID(ctx context.Context, req *TraceByIDRequest) (*TraceByIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindTraceByID not implemented")
}
func (*UnimplementedQuerierServer) SearchRecent(ctx context.Context, req *SearchRequest) (*SearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchRecent not implemented")
}
func (*UnimplementedQuerierServer) SearchBlock(ctx context.Context, req *SearchBlockRequest) (*SearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchBlock not implemented")
}
func (*UnimplementedQuerierServer) SearchTags(ctx context.Context, req *SearchTagsRequest) (*SearchTagsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchTags not implemented")
}
func (*UnimplementedQuerierServer) SearchTagsV2(ctx context.Context, req *SearchTagsRequest) (*SearchTagsV2Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchTagsV2 not implemented")
}
func (*UnimplementedQuerierServer) SearchTagValues(ctx context.Context, req *SearchTagValuesRequest) (*SearchTagValuesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchTagValues not implemented")
}
func (*UnimplementedQuerierServer) SearchTagValuesV2(ctx context.Context, req *SearchTagValuesRequest) (*SearchTagValuesV2Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchTagValuesV2 not implemented")
}

func RegisterQuerierServer(s *grpc.Server, srv QuerierServer) {
	s.RegisterService(&_Querier_serviceDesc, srv)
}

func _Querier_FindTraceByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TraceByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).FindTraceByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/FindTraceByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).FindTraceByID(ctx, req.(*TraceByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchRecent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchRecent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchRecent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchRecent(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchBlock(ctx, req.(*SearchBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchTags(ctx, req.(*SearchTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchTagsV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchTagsV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchTagsV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchTagsV2(ctx, req.(*SearchTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchTagValues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchTagValuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchTagValues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchTagValues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchTagValues(ctx, req.(*SearchTagValuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchTagValuesV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchTagValuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchTagValuesV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchTagValuesV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchTagValuesV2(ctx, req.(*SearchTagValuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Querier_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tempopb.Querier",
	HandlerType: (*QuerierServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FindTraceByID",
			Handler:    _Querier_FindTraceByID_Handler,
		},
		{
			MethodName: "SearchRecent",
			Handler:    _Querier_SearchRecent_Handler,
		},
		{
			MethodName: "SearchBlock",
			Handler:    _Querier_SearchBlock_Handler,
		},
		{
			MethodName: "SearchTags",
			Handler:    _Querier_SearchTags_Handler,
		},
		{
			MethodName: "SearchTagsV2",
			Handler:    _Querier_SearchTagsV2_Handler,
		},
		{
			MethodName: "SearchTagValues",
			Handler:    _Querier_SearchTagValues_Handler,
		},
		{
			MethodName: "SearchTagValuesV2",
			Handler:    _Querier_SearchTagValuesV2_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/tempopb/tempo.proto",
}

// StreamingQuerierClient is the client API for StreamingQuerier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StreamingQuerierClient interface {
	Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchClient, error)
	SearchTags(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagsClient, error)
	SearchTagsV2(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagsV2Client, error)
	SearchTagValues(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagValuesClient, error)
	SearchTagValuesV2(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagValuesV2Client, error)
	MetricsQueryRange(ctx context.Context, in *QueryRangeRequest, opts ...grpc.CallOption) (StreamingQuerier_MetricsQueryRangeClient, error)
	MetricsQueryInstant(ctx context.Context, in *QueryInstantRequest, opts ...grpc.CallOption) (StreamingQuerier_MetricsQueryInstantClient, error)
}

type streamingQuerierClient struct {
	cc *grpc.ClientConn
}

func NewStreamingQuerierClient(cc *grpc.ClientConn) StreamingQuerierClient {
	return &streamingQuerierClient{cc}
}

func (c *streamingQuerierClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamingQuerier_serviceDesc.Streams[0], "/tempopb.StreamingQuerier/Search", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingQuerierSearchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingQuerier_SearchClient interface {
	Recv() (*SearchResponse, error)
	grpc.ClientStream
}

type streamingQuerierSearchClient struct {
	grpc.ClientStream
}

func (x *streamingQuerierSearchClient) Recv() (*SearchResponse, error) {
	m := new(SearchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamingQuerierClient) SearchTags(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamingQuerier_serviceDesc.Streams[1], "/tempopb.StreamingQuerier/SearchTags", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingQuerierSearchTagsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingQuerier_SearchTagsClient interface {
	Recv() (*SearchTagsResponse, error)
	grpc.ClientStream
}

type streamingQuerierSearchTagsClient struct {
	grpc.ClientStream
}

func (x *streamingQuerierSearchTagsClient) Recv() (*SearchTagsResponse, error) {
	m := new(SearchTagsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamingQuerierClient) SearchTagsV2(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagsV2Client, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamingQuerier_serviceDesc.Streams[2], "/tempopb.StreamingQuerier/SearchTagsV2", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingQuerierSearchTagsV2Client{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingQuerier_SearchTagsV2Client interface {
	Recv() (*SearchTagsV2Response, error)
	grpc.ClientStream
}

type streamingQuerierSearchTagsV2Client struct {
	grpc.ClientStream
}

func (x *streamingQuerierSearchTagsV2Client) Recv() (*SearchTagsV2Response, error) {
	m := new(SearchTagsV2Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamingQuerierClient) SearchTagValues(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagValuesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamingQuerier_serviceDesc.Streams[3], "/tempopb.StreamingQuerier/SearchTagValues", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingQuerierSearchTagValuesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingQuerier_SearchTagValuesClient interface {
	Recv() (*SearchTagValuesResponse, error)
	grpc.ClientStream
}

type streamingQuerierSearchTagValuesClient struct {
	grpc.ClientStream
}

func (x *streamingQuerierSearchTagValuesClient) Recv() (*SearchTagValuesResponse, error) {
	m := new(SearchTagValuesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamingQuerierClient) SearchTagValuesV2(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagValuesV2Client, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamingQuerier_serviceDesc.Streams[4], "/tempopb.StreamingQuerier/SearchTagValuesV2", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingQuerierSearchTagValuesV2Client{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingQuerier_SearchTagValuesV2Client interface {
	Recv() (*SearchTagValuesV2Response, error)
	grpc.ClientStream
}

type streamingQuerierSearchTagValuesV2Client struct {
	grpc.ClientStream
}

func (x *streamingQuerierSearchTagValuesV2Client) Recv() (*SearchTagValuesV2Response, error) {
	m := new(SearchTagValuesV2Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamingQuerierClient) MetricsQueryRange(ctx context.Context, in *QueryRangeRequest, opts ...grpc.CallOption) (StreamingQuerier_MetricsQueryRangeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamingQuerier_serviceDesc.Streams[5], "/tempopb.StreamingQuerier/MetricsQueryRange", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingQuerierMetricsQueryRangeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingQuerier_MetricsQueryRangeClient interface {
	Recv() (*QueryRangeResponse, error)
	grpc.ClientStream
}

type streamingQuerierMetricsQueryRangeClient struct {
	grpc.ClientStream
}

func (x *streamingQuerierMetricsQueryRangeClient) Recv() (*QueryRangeResponse, error) {
	m := new(QueryRangeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamingQuerierClient) MetricsQueryInstant(ctx context.Context, in *QueryInstantRequest, opts ...grpc.CallOption) (StreamingQuerier_MetricsQueryInstantClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamingQuerier_serviceDesc.Streams[6], "/tempopb.StreamingQuerier/MetricsQueryInstant", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingQuerierMetricsQueryInstantClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingQuerier_MetricsQueryInstantClient interface {
	Recv() (*QueryInstantResponse, error)
	grpc.ClientStream
}

type streamingQuerierMetricsQueryInstantClient struct {
	grpc.ClientStream
}

func (x *streamingQuerierMetricsQueryInstantClient) Recv() (*QueryInstantResponse, error) {
	m := new(QueryInstantResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StreamingQuerierServer is the server API for StreamingQuerier service.
type StreamingQuerierServer interface {
	Search(*SearchRequest, StreamingQuerier_SearchServer) error
	SearchTags(*SearchTagsRequest, StreamingQuerier_SearchTagsServer) error
	SearchTagsV2(*SearchTagsRequest, StreamingQuerier_SearchTagsV2Server) error
	SearchTagValues(*SearchTagValuesRequest, StreamingQuerier_SearchTagValuesServer) error
	SearchTagValuesV2(*SearchTagValuesRequest, StreamingQuerier_SearchTagValuesV2Server) error
	MetricsQueryRange(*QueryRangeRequest, StreamingQuerier_MetricsQueryRangeServer) error
	MetricsQueryInstant(*QueryInstantRequest, StreamingQuerier_MetricsQueryInstantServer) error
}

// UnimplementedStreamingQuerierServer can be embedded to have forward compatible implementations.
type UnimplementedStreamingQuerierServer struct {
}

func (*UnimplementedStreamingQuerierServer) Search(req *SearchRequest, srv StreamingQuerier_SearchServer) error {
	return status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (*UnimplementedStreamingQuerierServer) SearchTags(req *SearchTagsRequest, srv StreamingQuerier_SearchTagsServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchTags not implemented")
}
func (*UnimplementedStreamingQuerierServer) SearchTagsV2(req *SearchTagsRequest, srv StreamingQuerier_SearchTagsV2Server) error {
	return status.Errorf(codes.Unimplemented, "method SearchTagsV2 not implemented")
}
func (*UnimplementedStreamingQuerierServer) SearchTagValues(req *SearchTagValuesRequest, srv StreamingQuerier_SearchTagValuesServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchTagValues not implemented")
}
func (*UnimplementedStreamingQuerierServer) SearchTagValuesV2(req *SearchTagValuesRequest, srv StreamingQuerier_SearchTagValuesV2Server) error {
	return status.Errorf(codes.Unimplemented, "method SearchTagValuesV2 not implemented")
}
func (*UnimplementedStreamingQuerierServer) MetricsQueryRange(req *QueryRangeRequest, srv StreamingQuerier_MetricsQueryRangeServer) error {
	return status.Errorf(codes.Unimplemented, "method MetricsQueryRange not implemented")
}
func (*UnimplementedStreamingQuerierServer) MetricsQueryInstant(req *QueryInstantRequest, srv StreamingQuerier_MetricsQueryInstantServer) error {
	return status.Errorf(codes.Unimplemented, "method MetricsQueryInstant not implemented")
}

func RegisterStreamingQuerierServer(s *grpc.Server, srv StreamingQuerierServer) {
	s.RegisterService(&_StreamingQuerier_serviceDesc, srv)
}

func _StreamingQuerier_Search_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingQuerierServer).Search(m, &streamingQuerierSearchServer{stream})
}

type StreamingQuerier_SearchServer interface {
	Send(*SearchResponse) error
	grpc.ServerStream
}

type streamingQuerierSearchServer struct {
	grpc.ServerStream
}

func (x *streamingQuerierSearchServer) Send(m *SearchResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _StreamingQuerier_SearchTags_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchTagsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingQuerierServer).SearchTags(m, &streamingQuerierSearchTagsServer{stream})
}

type StreamingQuerier_SearchTagsServer interface {
	Send(*SearchTagsResponse) error
	grpc.ServerStream
}

type streamingQuerierSearchTagsServer struct {
	grpc.ServerStream
}

func (x *streamingQuerierSearchTagsServer) Send(m *SearchTagsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _StreamingQuerier_SearchTagsV2_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchTagsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingQuerierServer).SearchTagsV2(m, &streamingQuerierSearchTagsV2Server{stream})
}

type StreamingQuerier_SearchTagsV2Server interface {
	Send(*SearchTagsV2Response) error
	grpc.ServerStream
}

type streamingQuerierSearchTagsV2Server struct {
	grpc.ServerStream
}

func (x *streamingQuerierSearchTagsV2Server) Send(m *SearchTagsV2Response) error {
	return x.ServerStream.SendMsg(m)
}

func _StreamingQuerier_SearchTagValues_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchTagValuesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingQuerierServer).SearchTagValues(m, &streamingQuerierSearchTagValuesServer{stream})
}

type StreamingQuerier_SearchTagValuesServer interface {
	Send(*SearchTagValuesResponse) error
	grpc.ServerStream
}

type streamingQuerierSearchTagValuesServer struct {
	grpc.ServerStream
}

func (x *streamingQuerierSearchTagValuesServer) Send(m *SearchTagValuesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _StreamingQuerier_SearchTagValuesV2_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchTagValuesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingQuerierServer).SearchTagValuesV2(m, &streamingQuerierSearchTagValuesV2Server{stream})
}

type StreamingQuerier_SearchTagValuesV2Server interface {
	Send(*SearchTagValuesV2Response) error
	grpc.ServerStream
}

type streamingQuerierSearchTagValuesV2Server struct {
	grpc.ServerStream
}

func (x *streamingQuerierSearchTagValuesV2Server) Send(m *SearchTagValuesV2Response) error {
	return x.ServerStream.SendMsg(m)
}

func _StreamingQuerier_MetricsQueryRange_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(QueryRangeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingQuerierServer).MetricsQueryRange(m, &streamingQuerierMetricsQueryRangeServer{stream})
}

type StreamingQuerier_MetricsQueryRangeServer interface {
	Send(*QueryRangeResponse) error
	grpc.ServerStream
}

type streamingQuerierMetricsQueryRangeServer struct {
	grpc.ServerStream
}

func (x *streamingQuerierMetricsQueryRangeServer) Send(m *QueryRangeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _StreamingQuerier_MetricsQueryInstant_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(QueryInstantRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingQuerierServer).MetricsQueryInstant(m, &streamingQuerierMetricsQueryInstantServer{stream})
}

type StreamingQuerier_MetricsQueryInstantServer interface {
	Send(*QueryInstantResponse) error
	grpc.ServerStream
}

type streamingQuerierMetricsQueryInstantServer struct {
	grpc.ServerStream
}

func (x *streamingQuerierMetricsQueryInstantServer) Send(m *QueryInstantResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _StreamingQuerier_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tempopb.StreamingQuerier",
	HandlerType: (*StreamingQuerierServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Search",
			Handler:       _StreamingQuerier_Search_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchTags",
			Handler:       _StreamingQuerier_SearchTags_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchTagsV2",
			Handler:       _StreamingQuerier_SearchTagsV2_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchTagValues",
			Handler:       _StreamingQuerier_SearchTagValues_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchTagValuesV2",
			Handler:       _StreamingQuerier_SearchTagValuesV2_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MetricsQueryRange",
			Handler:       _StreamingQuerier_MetricsQueryRange_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MetricsQueryInstant",
			Handler:       _StreamingQuerier_MetricsQueryInstant_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/tempopb/tempo.proto",
}

// MetricsClient is the client API for Metrics service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MetricsClient interface {
	SpanMetricsSummary(ctx context.Context, in *SpanMetricsSummaryRequest, opts ...grpc.CallOption) (*SpanMetricsSummaryResponse, error)
	QueryRange(ctx context.Context, in *QueryRangeRequest, opts ...grpc.CallOption) (*QueryRangeResponse, error)
}

type metricsClient struct {
	cc *grpc.ClientConn
}

func NewMetricsClient(cc *grpc.ClientConn) MetricsClient {
	return &metricsClient{cc}
}

func (c *metricsClient) SpanMetricsSummary(ctx context.Context, in *SpanMetricsSummaryRequest, opts ...grpc.CallOption) (*SpanMetricsSummaryResponse, error) {
	out := new(SpanMetricsSummaryResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Metrics/SpanMetricsSummary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metricsClient) QueryRange(ctx context.Context, in *QueryRangeRequest, opts ...grpc.CallOption) (*QueryRangeResponse, error) {
	out := new(QueryRangeResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Metrics/QueryRange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MetricsServer is the server API for Metrics service.
type MetricsServer interface {
	SpanMetricsSummary(context.Context, *SpanMetricsSummaryRequest) (*SpanMetricsSummaryResponse, error)
	QueryRange(context.Context, *QueryRangeRequest) (*QueryRangeResponse, error)
}

// UnimplementedMetricsServer can be embedded to have forward compatible implementations.
type UnimplementedMetricsServer struct {
}

func (*UnimplementedMetricsServer) SpanMetricsSummary(ctx context.Context, req *SpanMetricsSummaryRequest) (*SpanMetricsSummaryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SpanMetricsSummary not implemented")
}
func (*UnimplementedMetricsServer) QueryRange(ctx context.Context, req *QueryRangeRequest) (*QueryRangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRange not implemented")
}

func RegisterMetricsServer(s *grpc.Server, srv MetricsServer) {
	s.RegisterService(&_Metrics_serviceDesc, srv)
}

func _Metrics_SpanMetricsSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpanMetricsSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricsServer).SpanMetricsSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Metrics/SpanMetricsSummary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricsServer).SpanMetricsSummary(ctx, req.(*SpanMetricsSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metrics_QueryRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricsServer).QueryRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Metrics/QueryRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricsServer).QueryRange(ctx, req.(*QueryRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Metrics_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tempopb.Metrics",
	HandlerType: (*MetricsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SpanMetricsSummary",
			Handler:    _Metrics_SpanMetricsSummary_Handler,
		},
		{
			MethodName: "QueryRange",
			Handler:    _Metrics_QueryRange_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/tempopb/tempo.proto",
}

// BackendSchedulerClient is the client API for BackendScheduler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BackendSchedulerClient interface {
	// Get next available job
	Next(ctx context.Context, in *NextJobRequest, opts ...grpc.CallOption) (*NextJobResponse, error)
	// Update job status
	UpdateJob(ctx context.Context, in *UpdateJobStatusRequest, opts ...grpc.CallOption) (*UpdateJobStatusResponse, error)
}

type backendSchedulerClient struct {
	cc *grpc.ClientConn
}

func NewBackendSchedulerClient(cc *grpc.ClientConn) BackendSchedulerClient {
	return &backendSchedulerClient{cc}
}

func (c *backendSchedulerClient) Next(ctx context.Context, in *NextJobRequest, opts ...grpc.CallOption) (*NextJobResponse, error) {
	out := new(NextJobResponse)
	err := c.cc.Invoke(ctx, "/tempopb.BackendScheduler/Next", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendSchedulerClient) UpdateJob(ctx context.Context, in *UpdateJobStatusRequest, opts ...grpc.CallOption) (*UpdateJobStatusResponse, error) {
	out := new(UpdateJobStatusResponse)
	err := c.cc.Invoke(ctx, "/tempopb.BackendScheduler/UpdateJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BackendSchedulerServer is the server API for BackendScheduler service.
type BackendSchedulerServer interface {
	// Get next available job
	Next(context.Context, *NextJobRequest) (*NextJobResponse, error)
	// Update job status
	UpdateJob(context.Context, *UpdateJobStatusRequest) (*UpdateJobStatusResponse, error)
}

// UnimplementedBackendSchedulerServer can be embedded to have forward compatible implementations.
type UnimplementedBackendSchedulerServer struct {
}

func (*UnimplementedBackendSchedulerServer) Next(ctx context.Context, req *NextJobRequest) (*NextJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Next not implemented")
}
func (*UnimplementedBackendSchedulerServer) UpdateJob(ctx context.Context, req *UpdateJobStatusRequest) (*UpdateJobStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateJob not implemented")
}

func RegisterBackendSchedulerServer(s *grpc.Server, srv BackendSchedulerServer) {
	s.RegisterService(&_BackendScheduler_serviceDesc, srv)
}

func _BackendScheduler_Next_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NextJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendSchedulerServer).Next(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.BackendScheduler/Next",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendSchedulerServer).Next(ctx, req.(*NextJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendScheduler_UpdateJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateJobStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendSchedulerServer).UpdateJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.BackendScheduler/UpdateJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendSchedulerServer).UpdateJob(ctx, req.(*UpdateJobStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BackendScheduler_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tempopb.BackendScheduler",
	HandlerType: (*BackendSchedulerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Next",
			Handler:    _BackendScheduler_Next_Handler,
		},
		{
			MethodName: "UpdateJob",
			Handler:    _BackendScheduler_UpdateJob_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/tempopb/tempo.proto",
}

func (m *CompactionDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactionDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactionDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Input) > 0 {
		for iNdEx := len(m.Input) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Input[iNdEx])
			copy(dAtA[i:], m.Input[iNdEx])
			i = encodeVarintTempo(dAtA, i, uint64(len(m.Input[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *JobDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Compaction != nil {
		{
			size, err := m.Compaction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Tenant) > 0 {
		i -= len(m.Tenant)
		copy(dAtA[i:], m.Tenant)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Tenant)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NextJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NextJobRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NextJobRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.WorkerId) > 0 {
		i -= len(m.WorkerId)
		copy(dAtA[i:], m.WorkerId)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.WorkerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NextJobResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NextJobResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NextJobResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Detail.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTempo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Type != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateJobStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateJobStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateJobStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateJobStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateJobStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateJobStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TraceByIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceByIDRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceByIDRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllowPartialTrace {
		i--
		if m.AllowPartialTrace {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.QueryMode) > 0 {
		i -= len(m.QueryMode)
		copy(dAtA[i:], m.QueryMode)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.QueryMode)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BlockEnd) > 0 {
		i -= len(m.BlockEnd)
		copy(dAtA[i:], m.BlockEnd)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.BlockEnd)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BlockStart) > 0 {
		i -= len(m.BlockStart)
		copy(dAtA[i:], m.BlockStart)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.BlockStart)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TraceID) > 0 {
		i -= len(m.TraceID)
		copy(dAtA[i:], m.TraceID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.TraceID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TraceByIDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceByIDResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceByIDResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x22
	}
	if m.Status != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Trace != nil {
		{
			size, err := m.Trace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TraceByIDMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceByIDMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceByIDMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InspectedBytes != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.InspectedBytes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SearchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SpansPerSpanSet != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.SpansPerSpanSet))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x42
	}
	if m.End != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x30
	}
	if m.Start != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x28
	}
	if m.Limit != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxDurationMs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.MaxDurationMs))
		i--
		dAtA[i] = 0x18
	}
	if m.MinDurationMs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.MinDurationMs))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTempo(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTempo(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTempo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SearchBlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchBlockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchBlockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DedicatedColumns) > 0 {
		for iNdEx := len(m.DedicatedColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DedicatedColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.FooterSize != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.FooterSize))
		i--
		dAtA[i] = 0x58
	}
	if m.Size_ != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.DataEncoding) > 0 {
		i -= len(m.DataEncoding)
		copy(dAtA[i:], m.DataEncoding)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.DataEncoding)))
		i--
		dAtA[i] = 0x42
	}
	if m.TotalRecords != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalRecords))
		i--
		dAtA[i] = 0x38
	}
	if m.IndexPageSize != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.IndexPageSize))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Encoding) > 0 {
		i -= len(m.Encoding)
		copy(dAtA[i:], m.Encoding)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Encoding)))
		i--
		dAtA[i] = 0x2a
	}
	if m.PagesToSearch != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.PagesToSearch))
		i--
		dAtA[i] = 0x20
	}
	if m.StartPage != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StartPage))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BlockID) > 0 {
		i -= len(m.BlockID)
		copy(dAtA[i:], m.BlockID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.BlockID)))
		i--
		dAtA[i] = 0x12
	}
	if m.SearchReq != nil {
		{
			size, err := m.SearchReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DedicatedColumn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DedicatedColumn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DedicatedColumn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Scope != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Scope))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SearchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Traces) > 0 {
		for iNdEx := len(m.Traces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Traces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TraceSearchMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceSearchMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceSearchMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ServiceStats) > 0 {
		for k := range m.ServiceStats {
			v := m.ServiceStats[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTempo(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTempo(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTempo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.SpanSets) > 0 {
		for iNdEx := len(m.SpanSets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpanSets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.SpanSet != nil {
		{
			size, err := m.SpanSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.DurationMs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.DurationMs))
		i--
		dAtA[i] = 0x28
	}
	if m.StartTimeUnixNano != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StartTimeUnixNano))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RootTraceName) > 0 {
		i -= len(m.RootTraceName)
		copy(dAtA[i:], m.RootTraceName)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.RootTraceName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RootServiceName) > 0 {
		i -= len(m.RootServiceName)
		copy(dAtA[i:], m.RootServiceName)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.RootServiceName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TraceID) > 0 {
		i -= len(m.TraceID)
		copy(dAtA[i:], m.TraceID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.TraceID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ErrorCount != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.ErrorCount))
		i--
		dAtA[i] = 0x10
	}
	if m.SpanCount != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.SpanCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpanSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Matched != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Matched))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Span) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Span) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Span) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.DurationNanos != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.DurationNanos))
		i--
		dAtA[i] = 0x20
	}
	if m.StartTimeUnixNano != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StartTimeUnixNano))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpanID) > 0 {
		i -= len(m.SpanID)
		copy(dAtA[i:], m.SpanID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.SpanID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InspectedSpans != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.InspectedSpans))
		i--
		dAtA[i] = 0x38
	}
	if m.TotalBlockBytes != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalBlockBytes))
		i--
		dAtA[i] = 0x30
	}
	if m.TotalJobs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalJobs))
		i--
		dAtA[i] = 0x28
	}
	if m.CompletedJobs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.CompletedJobs))
		i--
		dAtA[i] = 0x20
	}
	if m.TotalBlocks != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalBlocks))
		i--
		dAtA[i] = 0x18
	}
	if m.InspectedBytes != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.InspectedBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.InspectedTraces != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.InspectedTraces))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StaleValuesThreshold != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StaleValuesThreshold))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxTagsPerScope != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.MaxTagsPerScope))
		i--
		dAtA[i] = 0x28
	}
	if m.End != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x20
	}
	if m.Start != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Scope) > 0 {
		i -= len(m.Scope)
		copy(dAtA[i:], m.Scope)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Scope)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagsBlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagsBlockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagsBlockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StaleValueThreshold != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StaleValueThreshold))
		i--
		dAtA[i] = 0x70
	}
	if m.MaxTagsPerScope != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.MaxTagsPerScope))
		i--
		dAtA[i] = 0x68
	}
	if len(m.DedicatedColumns) > 0 {
		for iNdEx := len(m.DedicatedColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DedicatedColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.FooterSize != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.FooterSize))
		i--
		dAtA[i] = 0x58
	}
	if m.Size_ != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.DataEncoding) > 0 {
		i -= len(m.DataEncoding)
		copy(dAtA[i:], m.DataEncoding)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.DataEncoding)))
		i--
		dAtA[i] = 0x42
	}
	if m.TotalRecords != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalRecords))
		i--
		dAtA[i] = 0x38
	}
	if m.IndexPageSize != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.IndexPageSize))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Encoding) > 0 {
		i -= len(m.Encoding)
		copy(dAtA[i:], m.Encoding)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Encoding)))
		i--
		dAtA[i] = 0x2a
	}
	if m.PagesToSearch != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.PagesToSearch))
		i--
		dAtA[i] = 0x20
	}
	if m.StartPage != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StartPage))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BlockID) > 0 {
		i -= len(m.BlockID)
		copy(dAtA[i:], m.BlockID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.BlockID)))
		i--
		dAtA[i] = 0x12
	}
	if m.SearchReq != nil {
		{
			size, err := m.SearchReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagValuesBlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagValuesBlockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagValuesBlockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DedicatedColumns) > 0 {
		for iNdEx := len(m.DedicatedColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DedicatedColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.FooterSize != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.FooterSize))
		i--
		dAtA[i] = 0x58
	}
	if m.Size_ != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.DataEncoding) > 0 {
		i -= len(m.DataEncoding)
		copy(dAtA[i:], m.DataEncoding)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.DataEncoding)))
		i--
		dAtA[i] = 0x42
	}
	if m.TotalRecords != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalRecords))
		i--
		dAtA[i] = 0x38
	}
	if m.IndexPageSize != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.IndexPageSize))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Encoding) > 0 {
		i -= len(m.Encoding)
		copy(dAtA[i:], m.Encoding)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Encoding)))
		i--
		dAtA[i] = 0x2a
	}
	if m.PagesToSearch != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.PagesToSearch))
		i--
		dAtA[i] = 0x20
	}
	if m.StartPage != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StartPage))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BlockID) > 0 {
		i -= len(m.BlockID)
		copy(dAtA[i:], m.BlockID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.BlockID)))
		i--
		dAtA[i] = 0x12
	}
	if m.SearchReq != nil {
		{
			size, err := m.SearchReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.TagNames) > 0 {
		for iNdEx := len(m.TagNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TagNames[iNdEx])
			copy(dAtA[i:], m.TagNames[iNdEx])
			i = encodeVarintTempo(dAtA, i, uint64(len(m.TagNames[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagsV2Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagsV2Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagsV2Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Scopes) > 0 {
		for iNdEx := len(m.Scopes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Scopes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagsV2Scope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagsV2Scope) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagsV2Scope) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintTempo(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagValuesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagValuesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagValuesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StaleValueThreshold != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StaleValueThreshold))
		i--
		dAtA[i] = 0x38
	}
	if m.MaxTagValues != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.MaxTagValues))
		i--
		dAtA[i] = 0x30
	}
	if m.End != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x28
	}
	if m.Start != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TagName) > 0 {
		i -= len(m.TagName)
		copy(dAtA[i:], m.TagName)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.TagName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagValuesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagValuesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagValuesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.TagValues) > 0 {
		for iNdEx := len(m.TagValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TagValues[iNdEx])
			copy(dAtA[i:], m.TagValues[iNdEx])
			i = encodeVarintTempo(dAtA, i, uint64(len(m.TagValues[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TagValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagValuesV2Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagValuesV2Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagValuesV2Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.TagValues) > 0 {
		for iNdEx := len(m.TagValues) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TagValues[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MetadataMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetadataMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetadataMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalBlockBytes != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalBlockBytes))
		i--
		dAtA[i] = 0x28
	}
	if m.TotalBlocks != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalBlocks))
		i--
		dAtA[i] = 0x20
	}
	if m.CompletedJobs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.CompletedJobs))
		i--
		dAtA[i] = 0x18
	}
	if m.TotalJobs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalJobs))
		i--
		dAtA[i] = 0x10
	}
	if m.InspectedBytes != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.InspectedBytes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Trace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Trace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResourceSpans) > 0 {
		for iNdEx := len(m.ResourceSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResourceSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PushResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorsByTrace) > 0 {
		dAtA16 := make([]byte, len(m.ErrorsByTrace)*10)
		var j15 int
		for _, num := range m.ErrorsByTrace {
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		i -= j15
		copy(dAtA[i:], dAtA16[:j15])
		i = encodeVarintTempo(dAtA, i, uint64(j15))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PushBytesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushBytesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushBytesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SkipMetricsGeneration {
		i--
		if m.SkipMetricsGeneration {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Ids) > 0 {
		for iNdEx := len(m.Ids) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Ids[iNdEx])
			copy(dAtA[i:], m.Ids[iNdEx])
			i = encodeVarintTempo(dAtA, i, uint64(len(m.Ids[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Traces) > 0 {
		for iNdEx := len(m.Traces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.Traces[iNdEx].Size()
				i -= size
				if _, err := m.Traces[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *PushSpansRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushSpansRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushSpansRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SkipMetricsGeneration {
		i--
		if m.SkipMetricsGeneration {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Batches) > 0 {
		for iNdEx := len(m.Batches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Batches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TraceBytes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceBytes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceBytes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Traces) > 0 {
		for iNdEx := len(m.Traces) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Traces[iNdEx])
			copy(dAtA[i:], m.Traces[iNdEx])
			i = encodeVarintTempo(dAtA, i, uint64(len(m.Traces[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LinkSlice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkSlice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LinkSlice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Links) > 0 {
		for iNdEx := len(m.Links) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Links[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x28
	}
	if m.Start != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x20
	}
	if m.Limit != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if len(m.GroupBy) > 0 {
		i -= len(m.GroupBy)
		copy(dAtA[i:], m.GroupBy)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.GroupBy)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsSummaryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsSummaryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsSummaryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x28
	}
	if m.Start != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x20
	}
	if m.Limit != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if len(m.GroupBy) > 0 {
		i -= len(m.GroupBy)
		copy(dAtA[i:], m.GroupBy)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.GroupBy)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metrics) > 0 {
		for iNdEx := len(m.Metrics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metrics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ErrorSpanCount != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.ErrorSpanCount))
		i--
		dAtA[i] = 0x18
	}
	if m.SpanCount != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.SpanCount))
		i--
		dAtA[i] = 0x10
	}
	if m.Estimated {
		i--
		if m.Estimated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RawHistogram) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawHistogram) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawHistogram) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.Bucket != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Bucket))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *KeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Errors != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Errors))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Series) > 0 {
		for iNdEx := len(m.Series) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Series[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.LatencyHistogram) > 0 {
		for iNdEx := len(m.LatencyHistogram) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LatencyHistogram[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.P50 != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.P50))
		i--
		dAtA[i] = 0x38
	}
	if m.P90 != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.P90))
		i--
		dAtA[i] = 0x30
	}
	if m.P95 != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.P95))
		i--
		dAtA[i] = 0x28
	}
	if m.P99 != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.P99))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Series) > 0 {
		for iNdEx := len(m.Series) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Series[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ErrorSpanCount != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.ErrorSpanCount))
		i--
		dAtA[i] = 0x10
	}
	if m.SpanCount != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.SpanCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsSummaryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsSummaryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsSummaryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Summaries) > 0 {
		for iNdEx := len(m.Summaries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Summaries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TraceQLStatic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceQLStatic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceQLStatic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x40
	}
	if m.Status != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if m.D != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.D))
		i--
		dAtA[i] = 0x30
	}
	if m.B {
		i--
		if m.B {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.S) > 0 {
		i -= len(m.S)
		copy(dAtA[i:], m.S)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.S)))
		i--
		dAtA[i] = 0x22
	}
	if m.F != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.F))))
		i--
		dAtA[i] = 0x19
	}
	if m.N != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.N))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ResultType) > 0 {
		i -= len(m.ResultType)
		copy(dAtA[i:], m.ResultType)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.ResultType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ts) > 0 {
		for iNdEx := len(m.Ts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.LabelValue) > 0 {
		i -= len(m.LabelValue)
		copy(dAtA[i:], m.LabelValue)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.LabelValue)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.LabelName) > 0 {
		i -= len(m.LabelName)
		copy(dAtA[i:], m.LabelName)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.LabelName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsResultPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsResultPoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsResultPoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExemplarDuration != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.ExemplarDuration))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ExemplarTraceID) > 0 {
		i -= len(m.ExemplarTraceID)
		copy(dAtA[i:], m.ExemplarTraceID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.ExemplarTraceID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Val != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Val))))
		i--
		dAtA[i] = 0x11
	}
	if m.Time != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryInstantRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryInstantRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryInstantRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x18
	}
	if m.Start != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryInstantResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryInstantResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryInstantResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Series) > 0 {
		for iNdEx := len(m.Series) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Series[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *InstantSeries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstantSeries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstantSeries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PromLabels) > 0 {
		i -= len(m.PromLabels)
		copy(dAtA[i:], m.PromLabels)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.PromLabels)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Value != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Labels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Exemplars != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Exemplars))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.DedicatedColumns) > 0 {
		for iNdEx := len(m.DedicatedColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DedicatedColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.FooterSize != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.FooterSize))
		i--
		dAtA[i] = 0x70
	}
	if m.Size_ != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x68
	}
	if len(m.Encoding) > 0 {
		i -= len(m.Encoding)
		copy(dAtA[i:], m.Encoding)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Encoding)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x5a
	}
	if m.PagesToSearch != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.PagesToSearch))
		i--
		dAtA[i] = 0x50
	}
	if m.StartPage != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StartPage))
		i--
		dAtA[i] = 0x48
	}
	if len(m.BlockID) > 0 {
		i -= len(m.BlockID)
		copy(dAtA[i:], m.BlockID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.BlockID)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.QueryMode) > 0 {
		i -= len(m.QueryMode)
		copy(dAtA[i:], m.QueryMode)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.QueryMode)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Step != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Step))
		i--
		dAtA[i] = 0x20
	}
	if m.End != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x18
	}
	if m.Start != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Series) > 0 {
		for iNdEx := len(m.Series) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Series[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Exemplar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Exemplar) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Exemplar) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimestampMs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TimestampMs))
		i--
		dAtA[i] = 0x18
	}
	if m.Value != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Labels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Sample) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sample) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sample) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimestampMs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TimestampMs))
		i--
		dAtA[i] = 0x10
	}
	if m.Value != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *TimeSeries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeSeries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimeSeries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Exemplars) > 0 {
		for iNdEx := len(m.Exemplars) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Exemplars[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PromLabels) > 0 {
		i -= len(m.PromLabels)
		copy(dAtA[i:], m.PromLabels)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.PromLabels)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Samples) > 0 {
		for iNdEx := len(m.Samples) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Samples[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Labels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTempo(dAtA []byte, offset int, v uint64) int {
	offset -= sovTempo(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CompactionDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Input) > 0 {
		for _, s := range m.Input {
			l = len(s)
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *JobDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Compaction != nil {
		l = m.Compaction.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *NextJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WorkerId)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTempo(uint64(m.Type))
	}
	return n
}

func (m *NextJobResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTempo(uint64(m.Type))
	}
	l = m.Detail.Size()
	n += 1 + l + sovTempo(uint64(l))
	return n
}

func (m *UpdateJobStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTempo(uint64(m.Status))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *UpdateJobStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *TraceByIDRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TraceID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.BlockStart)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.BlockEnd)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.QueryMode)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.AllowPartialTrace {
		n += 2
	}
	return n
}

func (m *TraceByIDResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Trace != nil {
		l = m.Trace.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTempo(uint64(m.Status))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *TraceByIDMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InspectedBytes != 0 {
		n += 1 + sovTempo(uint64(m.InspectedBytes))
	}
	return n
}

func (m *SearchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTempo(uint64(len(k))) + 1 + len(v) + sovTempo(uint64(len(v)))
			n += mapEntrySize + 1 + sovTempo(uint64(mapEntrySize))
		}
	}
	if m.MinDurationMs != 0 {
		n += 1 + sovTempo(uint64(m.MinDurationMs))
	}
	if m.MaxDurationMs != 0 {
		n += 1 + sovTempo(uint64(m.MaxDurationMs))
	}
	if m.Limit != 0 {
		n += 1 + sovTempo(uint64(m.Limit))
	}
	if m.Start != 0 {
		n += 1 + sovTempo(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTempo(uint64(m.End))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.SpansPerSpanSet != 0 {
		n += 1 + sovTempo(uint64(m.SpansPerSpanSet))
	}
	return n
}

func (m *SearchBlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SearchReq != nil {
		l = m.SearchReq.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.BlockID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.StartPage != 0 {
		n += 1 + sovTempo(uint64(m.StartPage))
	}
	if m.PagesToSearch != 0 {
		n += 1 + sovTempo(uint64(m.PagesToSearch))
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.IndexPageSize != 0 {
		n += 1 + sovTempo(uint64(m.IndexPageSize))
	}
	if m.TotalRecords != 0 {
		n += 1 + sovTempo(uint64(m.TotalRecords))
	}
	l = len(m.DataEncoding)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovTempo(uint64(m.Size_))
	}
	if m.FooterSize != 0 {
		n += 1 + sovTempo(uint64(m.FooterSize))
	}
	if len(m.DedicatedColumns) > 0 {
		for _, e := range m.DedicatedColumns {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *DedicatedColumn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTempo(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Scope != 0 {
		n += 1 + sovTempo(uint64(m.Scope))
	}
	return n
}

func (m *SearchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Traces) > 0 {
		for _, e := range m.Traces {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *TraceSearchMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TraceID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.RootServiceName)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.RootTraceName)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.StartTimeUnixNano != 0 {
		n += 1 + sovTempo(uint64(m.StartTimeUnixNano))
	}
	if m.DurationMs != 0 {
		n += 1 + sovTempo(uint64(m.DurationMs))
	}
	if m.SpanSet != nil {
		l = m.SpanSet.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	if len(m.SpanSets) > 0 {
		for _, e := range m.SpanSets {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if len(m.ServiceStats) > 0 {
		for k, v := range m.ServiceStats {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTempo(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTempo(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTempo(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ServiceStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpanCount != 0 {
		n += 1 + sovTempo(uint64(m.SpanCount))
	}
	if m.ErrorCount != 0 {
		n += 1 + sovTempo(uint64(m.ErrorCount))
	}
	return n
}

func (m *SpanSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Matched != 0 {
		n += 1 + sovTempo(uint64(m.Matched))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *Span) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpanID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.StartTimeUnixNano != 0 {
		n += 1 + sovTempo(uint64(m.StartTimeUnixNano))
	}
	if m.DurationNanos != 0 {
		n += 1 + sovTempo(uint64(m.DurationNanos))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SearchMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InspectedTraces != 0 {
		n += 1 + sovTempo(uint64(m.InspectedTraces))
	}
	if m.InspectedBytes != 0 {
		n += 1 + sovTempo(uint64(m.InspectedBytes))
	}
	if m.TotalBlocks != 0 {
		n += 1 + sovTempo(uint64(m.TotalBlocks))
	}
	if m.CompletedJobs != 0 {
		n += 1 + sovTempo(uint64(m.CompletedJobs))
	}
	if m.TotalJobs != 0 {
		n += 1 + sovTempo(uint64(m.TotalJobs))
	}
	if m.TotalBlockBytes != 0 {
		n += 1 + sovTempo(uint64(m.TotalBlockBytes))
	}
	if m.InspectedSpans != 0 {
		n += 1 + sovTempo(uint64(m.InspectedSpans))
	}
	return n
}

func (m *SearchTagsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Scope)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovTempo(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTempo(uint64(m.End))
	}
	if m.MaxTagsPerScope != 0 {
		n += 1 + sovTempo(uint64(m.MaxTagsPerScope))
	}
	if m.StaleValuesThreshold != 0 {
		n += 1 + sovTempo(uint64(m.StaleValuesThreshold))
	}
	return n
}

func (m *SearchTagsBlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SearchReq != nil {
		l = m.SearchReq.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.BlockID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.StartPage != 0 {
		n += 1 + sovTempo(uint64(m.StartPage))
	}
	if m.PagesToSearch != 0 {
		n += 1 + sovTempo(uint64(m.PagesToSearch))
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.IndexPageSize != 0 {
		n += 1 + sovTempo(uint64(m.IndexPageSize))
	}
	if m.TotalRecords != 0 {
		n += 1 + sovTempo(uint64(m.TotalRecords))
	}
	l = len(m.DataEncoding)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovTempo(uint64(m.Size_))
	}
	if m.FooterSize != 0 {
		n += 1 + sovTempo(uint64(m.FooterSize))
	}
	if len(m.DedicatedColumns) > 0 {
		for _, e := range m.DedicatedColumns {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.MaxTagsPerScope != 0 {
		n += 1 + sovTempo(uint64(m.MaxTagsPerScope))
	}
	if m.StaleValueThreshold != 0 {
		n += 1 + sovTempo(uint64(m.StaleValueThreshold))
	}
	return n
}

func (m *SearchTagValuesBlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SearchReq != nil {
		l = m.SearchReq.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.BlockID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.StartPage != 0 {
		n += 1 + sovTempo(uint64(m.StartPage))
	}
	if m.PagesToSearch != 0 {
		n += 1 + sovTempo(uint64(m.PagesToSearch))
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.IndexPageSize != 0 {
		n += 1 + sovTempo(uint64(m.IndexPageSize))
	}
	if m.TotalRecords != 0 {
		n += 1 + sovTempo(uint64(m.TotalRecords))
	}
	l = len(m.DataEncoding)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovTempo(uint64(m.Size_))
	}
	if m.FooterSize != 0 {
		n += 1 + sovTempo(uint64(m.FooterSize))
	}
	if len(m.DedicatedColumns) > 0 {
		for _, e := range m.DedicatedColumns {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SearchTagsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TagNames) > 0 {
		for _, s := range m.TagNames {
			l = len(s)
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *SearchTagsV2Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Scopes) > 0 {
		for _, e := range m.Scopes {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *SearchTagsV2Scope) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SearchTagValuesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TagName)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovTempo(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTempo(uint64(m.End))
	}
	if m.MaxTagValues != 0 {
		n += 1 + sovTempo(uint64(m.MaxTagValues))
	}
	if m.StaleValueThreshold != 0 {
		n += 1 + sovTempo(uint64(m.StaleValueThreshold))
	}
	return n
}

func (m *SearchTagValuesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TagValues) > 0 {
		for _, s := range m.TagValues {
			l = len(s)
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *TagValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *SearchTagValuesV2Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TagValues) > 0 {
		for _, e := range m.TagValues {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *MetadataMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InspectedBytes != 0 {
		n += 1 + sovTempo(uint64(m.InspectedBytes))
	}
	if m.TotalJobs != 0 {
		n += 1 + sovTempo(uint64(m.TotalJobs))
	}
	if m.CompletedJobs != 0 {
		n += 1 + sovTempo(uint64(m.CompletedJobs))
	}
	if m.TotalBlocks != 0 {
		n += 1 + sovTempo(uint64(m.TotalBlocks))
	}
	if m.TotalBlockBytes != 0 {
		n += 1 + sovTempo(uint64(m.TotalBlockBytes))
	}
	return n
}

func (m *Trace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResourceSpans) > 0 {
		for _, e := range m.ResourceSpans {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *PushResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ErrorsByTrace) > 0 {
		l = 0
		for _, e := range m.ErrorsByTrace {
			l += sovTempo(uint64(e))
		}
		n += 1 + sovTempo(uint64(l)) + l
	}
	return n
}

func (m *PushBytesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Traces) > 0 {
		for _, e := range m.Traces {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if len(m.Ids) > 0 {
		for _, b := range m.Ids {
			l = len(b)
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.SkipMetricsGeneration {
		n += 2
	}
	return n
}

func (m *PushSpansRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Batches) > 0 {
		for _, e := range m.Batches {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.SkipMetricsGeneration {
		n += 2
	}
	return n
}

func (m *TraceBytes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Traces) > 0 {
		for _, b := range m.Traces {
			l = len(b)
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *LinkSlice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Links) > 0 {
		for _, e := range m.Links {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SpanMetricsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.GroupBy)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovTempo(uint64(m.Limit))
	}
	if m.Start != 0 {
		n += 1 + sovTempo(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTempo(uint64(m.End))
	}
	return n
}

func (m *SpanMetricsSummaryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.GroupBy)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovTempo(uint64(m.Limit))
	}
	if m.Start != 0 {
		n += 1 + sovTempo(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTempo(uint64(m.End))
	}
	return n
}

func (m *SpanMetricsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Estimated {
		n += 2
	}
	if m.SpanCount != 0 {
		n += 1 + sovTempo(uint64(m.SpanCount))
	}
	if m.ErrorSpanCount != 0 {
		n += 1 + sovTempo(uint64(m.ErrorSpanCount))
	}
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *RawHistogram) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bucket != 0 {
		n += 1 + sovTempo(uint64(m.Bucket))
	}
	if m.Count != 0 {
		n += 1 + sovTempo(uint64(m.Count))
	}
	return n
}

func (m *KeyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *SpanMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LatencyHistogram) > 0 {
		for _, e := range m.LatencyHistogram {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if len(m.Series) > 0 {
		for _, e := range m.Series {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Errors != 0 {
		n += 1 + sovTempo(uint64(m.Errors))
	}
	return n
}

func (m *SpanMetricsSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpanCount != 0 {
		n += 1 + sovTempo(uint64(m.SpanCount))
	}
	if m.ErrorSpanCount != 0 {
		n += 1 + sovTempo(uint64(m.ErrorSpanCount))
	}
	if len(m.Series) > 0 {
		for _, e := range m.Series {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.P99 != 0 {
		n += 1 + sovTempo(uint64(m.P99))
	}
	if m.P95 != 0 {
		n += 1 + sovTempo(uint64(m.P95))
	}
	if m.P90 != 0 {
		n += 1 + sovTempo(uint64(m.P90))
	}
	if m.P50 != 0 {
		n += 1 + sovTempo(uint64(m.P50))
	}
	return n
}

func (m *SpanMetricsSummaryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Summaries) > 0 {
		for _, e := range m.Summaries {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *TraceQLStatic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTempo(uint64(m.Type))
	}
	if m.N != 0 {
		n += 1 + sovTempo(uint64(m.N))
	}
	if m.F != 0 {
		n += 9
	}
	l = len(m.S)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.B {
		n += 2
	}
	if m.D != 0 {
		n += 1 + sovTempo(uint64(m.D))
	}
	if m.Status != 0 {
		n += 1 + sovTempo(uint64(m.Status))
	}
	if m.Kind != 0 {
		n += 1 + sovTempo(uint64(m.Kind))
	}
	return n
}

func (m *SpanMetricsData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResultType)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SpanMetricsResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LabelName)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.LabelValue)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if len(m.Ts) > 0 {
		for _, e := range m.Ts {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SpanMetricsResultPoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovTempo(uint64(m.Time))
	}
	if m.Val != 0 {
		n += 9
	}
	l = len(m.ExemplarTraceID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.ExemplarDuration != 0 {
		n += 1 + sovTempo(uint64(m.ExemplarDuration))
	}
	return n
}

func (m *QueryInstantRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovTempo(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTempo(uint64(m.End))
	}
	return n
}

func (m *QueryInstantResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Series) > 0 {
		for _, e := range m.Series {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *InstantSeries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Value != 0 {
		n += 9
	}
	l = len(m.PromLabels)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *QueryRangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovTempo(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTempo(uint64(m.End))
	}
	if m.Step != 0 {
		n += 1 + sovTempo(uint64(m.Step))
	}
	l = len(m.QueryMode)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.BlockID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.StartPage != 0 {
		n += 1 + sovTempo(uint64(m.StartPage))
	}
	if m.PagesToSearch != 0 {
		n += 1 + sovTempo(uint64(m.PagesToSearch))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovTempo(uint64(m.Size_))
	}
	if m.FooterSize != 0 {
		n += 1 + sovTempo(uint64(m.FooterSize))
	}
	if len(m.DedicatedColumns) > 0 {
		for _, e := range m.DedicatedColumns {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Exemplars != 0 {
		n += 2 + sovTempo(uint64(m.Exemplars))
	}
	return n
}

func (m *QueryRangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Series) > 0 {
		for _, e := range m.Series {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *Exemplar) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Value != 0 {
		n += 9
	}
	if m.TimestampMs != 0 {
		n += 1 + sovTempo(uint64(m.TimestampMs))
	}
	return n
}

func (m *Sample) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 9
	}
	if m.TimestampMs != 0 {
		n += 1 + sovTempo(uint64(m.TimestampMs))
	}
	return n
}

func (m *TimeSeries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if len(m.Samples) > 0 {
		for _, e := range m.Samples {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	l = len(m.PromLabels)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if len(m.Exemplars) > 0 {
		for _, e := range m.Exemplars {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func sovTempo(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTempo(x uint64) (n int) {
	return sovTempo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CompactionDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactionDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactionDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Input = append(m.Input, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Compaction == nil {
				m.Compaction = &CompactionDetail{}
			}
			if err := m.Compaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NextJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NextJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NextJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= JobType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NextJobResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NextJobResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NextJobResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= JobType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Detail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateJobStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateJobStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateJobStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= JobStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateJobStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateJobStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateJobStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceByIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceByIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceByIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraceID = append(m.TraceID[:0], dAtA[iNdEx:postIndex]...)
			if m.TraceID == nil {
				m.TraceID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockStart", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockStart = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockEnd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockEnd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowPartialTrace", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowPartialTrace = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceByIDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceByIDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceByIDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Trace == nil {
				m.Trace = &Trace{}
			}
			if err := m.Trace.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &TraceByIDMetrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TraceByIDResponse_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceByIDMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceByIDMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceByIDMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InspectedBytes", wireType)
			}
			m.InspectedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InspectedBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTempo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTempo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTempo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTempo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTempo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTempo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTempo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTempo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTempo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDurationMs", wireType)
			}
			m.MinDurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinDurationMs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDurationMs", wireType)
			}
			m.MaxDurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDurationMs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpansPerSpanSet", wireType)
			}
			m.SpansPerSpanSet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpansPerSpanSet |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchBlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchBlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchBlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SearchReq == nil {
				m.SearchReq = &SearchRequest{}
			}
			if err := m.SearchReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPage", wireType)
			}
			m.StartPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PagesToSearch", wireType)
			}
			m.PagesToSearch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PagesToSearch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPageSize", wireType)
			}
			m.IndexPageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexPageSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRecords", wireType)
			}
			m.TotalRecords = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRecords |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataEncoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataEncoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FooterSize", wireType)
			}
			m.FooterSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FooterSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DedicatedColumns = append(m.DedicatedColumns, &DedicatedColumn{})
			if err := m.DedicatedColumns[len(m.DedicatedColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DedicatedColumn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DedicatedColumn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DedicatedColumn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= DedicatedColumn_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			m.Scope = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scope |= DedicatedColumn_Scope(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Traces = append(m.Traces, &TraceSearchMetadata{})
			if err := m.Traces[len(m.Traces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &SearchMetrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceSearchMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceSearchMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceSearchMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootTraceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootTraceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimeUnixNano", wireType)
			}
			m.StartTimeUnixNano = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimeUnixNano |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationMs", wireType)
			}
			m.DurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurationMs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpanSet == nil {
				m.SpanSet = &SpanSet{}
			}
			if err := m.SpanSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpanSets = append(m.SpanSets, &SpanSet{})
			if err := m.SpanSets[len(m.SpanSets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceStats == nil {
				m.ServiceStats = make(map[string]*ServiceStats)
			}
			var mapkey string
			var mapvalue *ServiceStats
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTempo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTempo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTempo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTempo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTempo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTempo
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTempo
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ServiceStats{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTempo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTempo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ServiceStats[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanCount", wireType)
			}
			m.SpanCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpanCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCount", wireType)
			}
			m.ErrorCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, &Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Matched", wireType)
			}
			m.Matched = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Matched |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &v1.KeyValue{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Span) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Span: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Span: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpanID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimeUnixNano", wireType)
			}
			m.StartTimeUnixNano = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimeUnixNano |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationNanos", wireType)
			}
			m.DurationNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurationNanos |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &v1.KeyValue{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InspectedTraces", wireType)
			}
			m.InspectedTraces = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InspectedTraces |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InspectedBytes", wireType)
			}
			m.InspectedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InspectedBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBlocks", wireType)
			}
			m.TotalBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBlocks |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedJobs", wireType)
			}
			m.CompletedJobs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletedJobs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalJobs", wireType)
			}
			m.TotalJobs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalJobs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBlockBytes", wireType)
			}
			m.TotalBlockBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBlockBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InspectedSpans", wireType)
			}
			m.InspectedSpans = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InspectedSpans |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scope = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTagsPerScope", wireType)
			}
			m.MaxTagsPerScope = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTagsPerScope |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaleValuesThreshold", wireType)
			}
			m.StaleValuesThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StaleValuesThreshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagsBlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagsBlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagsBlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SearchReq == nil {
				m.SearchReq = &SearchTagsRequest{}
			}
			if err := m.SearchReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPage", wireType)
			}
			m.StartPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PagesToSearch", wireType)
			}
			m.PagesToSearch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PagesToSearch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPageSize", wireType)
			}
			m.IndexPageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexPageSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRecords", wireType)
			}
			m.TotalRecords = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRecords |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataEncoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataEncoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FooterSize", wireType)
			}
			m.FooterSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FooterSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DedicatedColumns = append(m.DedicatedColumns, &DedicatedColumn{})
			if err := m.DedicatedColumns[len(m.DedicatedColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTagsPerScope", wireType)
			}
			m.MaxTagsPerScope = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTagsPerScope |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaleValueThreshold", wireType)
			}
			m.StaleValueThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StaleValueThreshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagValuesBlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagValuesBlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagValuesBlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SearchReq == nil {
				m.SearchReq = &SearchTagValuesRequest{}
			}
			if err := m.SearchReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPage", wireType)
			}
			m.StartPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PagesToSearch", wireType)
			}
			m.PagesToSearch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PagesToSearch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPageSize", wireType)
			}
			m.IndexPageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexPageSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRecords", wireType)
			}
			m.TotalRecords = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRecords |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataEncoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataEncoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FooterSize", wireType)
			}
			m.FooterSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FooterSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DedicatedColumns = append(m.DedicatedColumns, &DedicatedColumn{})
			if err := m.DedicatedColumns[len(m.DedicatedColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagNames = append(m.TagNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &MetadataMetrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagsV2Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagsV2Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagsV2Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scopes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scopes = append(m.Scopes, &SearchTagsV2Scope{})
			if err := m.Scopes[len(m.Scopes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &MetadataMetrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagsV2Scope) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagsV2Scope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagsV2Scope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagValuesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagValuesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagValuesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTagValues", wireType)
			}
			m.MaxTagValues = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTagValues |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaleValueThreshold", wireType)
			}
			m.StaleValueThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StaleValueThreshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagValuesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagValuesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagValuesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagValues = append(m.TagValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &MetadataMetrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagValuesV2Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagValuesV2Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagValuesV2Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagValues = append(m.TagValues, &TagValue{})
			if err := m.TagValues[len(m.TagValues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &MetadataMetrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetadataMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetadataMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetadataMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InspectedBytes", wireType)
			}
			m.InspectedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InspectedBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalJobs", wireType)
			}
			m.TotalJobs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalJobs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedJobs", wireType)
			}
			m.CompletedJobs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletedJobs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBlocks", wireType)
			}
			m.TotalBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBlocks |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBlockBytes", wireType)
			}
			m.TotalBlockBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBlockBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceSpans = append(m.ResourceSpans, &v11.ResourceSpans{})
			if err := m.ResourceSpans[len(m.ResourceSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v PushErrorReason
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTempo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= PushErrorReason(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ErrorsByTrace = append(m.ErrorsByTrace, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTempo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTempo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTempo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ErrorsByTrace) == 0 {
					m.ErrorsByTrace = make([]PushErrorReason, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v PushErrorReason
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTempo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= PushErrorReason(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ErrorsByTrace = append(m.ErrorsByTrace, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorsByTrace", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushBytesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushBytesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushBytesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traces", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v PreallocBytes
			m.Traces = append(m.Traces, v)
			if err := m.Traces[len(m.Traces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ids = append(m.Ids, make([]byte, postIndex-iNdEx))
			copy(m.Ids[len(m.Ids)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipMetricsGeneration", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipMetricsGeneration = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushSpansRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushSpansRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushSpansRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Batches = append(m.Batches, &v11.ResourceSpans{})
			if err := m.Batches[len(m.Batches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipMetricsGeneration", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipMetricsGeneration = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceBytes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceBytes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceBytes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traces", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Traces = append(m.Traces, make([]byte, postIndex-iNdEx))
			copy(m.Traces[len(m.Traces)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkSlice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkSlice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkSlice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Links = append(m.Links, &v11.Span_Link{})
			if err := m.Links[len(m.Links)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsSummaryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsSummaryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsSummaryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Estimated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Estimated = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanCount", wireType)
			}
			m.SpanCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpanCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorSpanCount", wireType)
			}
			m.ErrorSpanCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorSpanCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, &SpanMetrics{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawHistogram) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawHistogram: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawHistogram: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			m.Bucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &TraceQLStatic{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyHistogram", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatencyHistogram = append(m.LatencyHistogram, &RawHistogram{})
			if err := m.LatencyHistogram[len(m.LatencyHistogram)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Series = append(m.Series, &KeyValue{})
			if err := m.Series[len(m.Series)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			m.Errors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanCount", wireType)
			}
			m.SpanCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpanCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorSpanCount", wireType)
			}
			m.ErrorSpanCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorSpanCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Series = append(m.Series, &KeyValue{})
			if err := m.Series[len(m.Series)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field P99", wireType)
			}
			m.P99 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.P99 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field P95", wireType)
			}
			m.P95 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.P95 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field P90", wireType)
			}
			m.P90 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.P90 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field P50", wireType)
			}
			m.P50 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.P50 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsSummaryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsSummaryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsSummaryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summaries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summaries = append(m.Summaries, &SpanMetricsSummary{})
			if err := m.Summaries[len(m.Summaries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceQLStatic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceQLStatic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceQLStatic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			m.N = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.N |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.F = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.B = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field D", wireType)
			}
			m.D = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.D |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResultType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &SpanMetricsResult{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabelName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabelValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ts = append(m.Ts, &SpanMetricsResultPoint{})
			if err := m.Ts[len(m.Ts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsResultPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsResultPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsResultPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Val = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExemplarTraceID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExemplarTraceID = append(m.ExemplarTraceID[:0], dAtA[iNdEx:postIndex]...)
			if m.ExemplarTraceID == nil {
				m.ExemplarTraceID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExemplarDuration", wireType)
			}
			m.ExemplarDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExemplarDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryInstantRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryInstantRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryInstantRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryInstantResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryInstantResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryInstantResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Series = append(m.Series, &InstantSeries{})
			if err := m.Series[len(m.Series)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &SearchMetrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstantSeries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstantSeries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstantSeries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, v1.KeyValue{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromLabels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PromLabels = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			m.Step = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Step |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPage", wireType)
			}
			m.StartPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PagesToSearch", wireType)
			}
			m.PagesToSearch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PagesToSearch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FooterSize", wireType)
			}
			m.FooterSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FooterSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DedicatedColumns = append(m.DedicatedColumns, &DedicatedColumn{})
			if err := m.DedicatedColumns[len(m.DedicatedColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exemplars", wireType)
			}
			m.Exemplars = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exemplars |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Series = append(m.Series, &TimeSeries{})
			if err := m.Series[len(m.Series)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &SearchMetrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Exemplar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Exemplar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Exemplar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, v1.KeyValue{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMs", wireType)
			}
			m.TimestampMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sample) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sample: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sample: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMs", wireType)
			}
			m.TimestampMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeSeries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeSeries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeSeries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, v1.KeyValue{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Samples", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Samples = append(m.Samples, Sample{})
			if err := m.Samples[len(m.Samples)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromLabels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PromLabels = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exemplars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exemplars = append(m.Exemplars, Exemplar{})
			if err := m.Exemplars[len(m.Exemplars)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTempo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTempo
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTempo
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTempo
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTempo        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTempo          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTempo = fmt.Errorf("proto: unexpected end of group")
)

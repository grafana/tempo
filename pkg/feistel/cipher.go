// Package feistel provides an implementation of the Feistel cipher,
// a symmetric structure used in the construction of block ciphers.
//
// The encryption and decryption process is divided into several rounds, as defined by the constant `rounds`.
// In each round, a round key is generated by XORing the data with a secret key.
// This round key is then used to XOR with the other half of the data, and the halves are swapped.
// This process is repeated for the specified number of rounds.
//
// Encryption is reversible.
// https://en.wikipedia.org/wiki/Feistel_cipher
package feistel

const (
	rounds = 4 // TODO(mapno): How many rounds should we use?
)

// TODO(mapno): What makes for a good key?
var key = []byte{73, 116, 39, 115, 32, 109, 101, 44, 32, 77, 97, 114, 105, 111, 33} // Random key

// Encrypt function encrypts the given data using the Feistel cipher.
// If `inPlace` is true, it modifies the input data directly (in-place encryption).
// Otherwise, it creates a new byte slice and leaves the input data unchanged (out-of-place encryption).
func Encrypt(data []byte, inPlace bool) []byte {
	if len(data)%2 != 0 {
		// TODO(mapno): Add padding
		panic("data must be an even number of bytes")
	}
	if inPlace {
		inPlaceEncrypt(data, rounds)
		return data
	}
	return encrypt(data, rounds)
}

// Decrypt function decrypts the given data using the Feistel cipher.
// Similar to `Encrypt`, if `inPlace` is true, it modifies the input data directly (in-place decryption).
// Otherwise, it creates a new byte slice and leaves the input data unchanged (out-of-place decryption).
func Decrypt(data []byte, inPlace bool) []byte {
	if len(data)%2 != 0 {
		panic("data must be an even number of bytes")
	}
	if inPlace {
		inPlaceDecrypt(data, rounds)
		return data
	}
	return decrypt(data, rounds)
}

func encrypt(data []byte, rounds int) []byte {
	half := len(data) / 2
	left, right := data[:half], data[half:]
	key := make([]byte, half)
	for i := 0; i < rounds; i++ {
		roundKey(right, key)
		newRight := xor(left, key)
		left, right = right, newRight
	}
	return append(left, right...)
}

func decrypt(data []byte, rounds int) []byte {
	half := len(data) / 2
	left, right := data[:half], data[half:]
	key := make([]byte, half)
	for i := 0; i < rounds; i++ {
		roundKey(left, key)
		newLeft := xor(right, key)
		left, right = newLeft, left
	}
	return append(left, right...)
}

func inPlaceEncrypt(data []byte, rounds int) {
	half := len(data) / 2
	key := make([]byte, half)
	for i := 0; i < rounds; i++ {
		roundKey(data[half:], key)
		for j := 0; j < half; j++ {
			data[j], data[half+j] = data[half+j], data[j]^key[j]
		}
	}
}

func inPlaceDecrypt(data []byte, rounds int) {
	half := len(data) / 2
	key := make([]byte, half)
	for i := 0; i < rounds; i++ {
		roundKey(data[:half], key)
		for j := 0; j < half; j++ {
			data[j], data[half+j] = data[half+j]^key[j], data[j]
		}
	}
}

// roundKey generates a round key by XORing the data with a secret key.
// The `xor` function performs a bitwise XOR operation on two byte slices.
func roundKey(data []byte, hash []byte) {
	for i := range data {
		hash[i] = data[i] ^ key[i] // TODO(mapno): This is lazy, what if the key is shorter than the data?
	}
}

// xor performs a bitwise XOR operation on two byte slices.
// The two slices must be of equal length.
func xor(a, b []byte) []byte {
	if len(a) > len(b) {
		panic("xor: a must be shorter than or equal to b")
	}
	res := make([]byte, len(a))
	for i := range a {
		res[i] = a[i] ^ b[i]
	}
	return res
}
